## 组合数学

### 组合数

#### debug

提供一组测试数据：$\binom{132}{66}=$ 377'389'666'165'540'953'244'592'352'291'892'721'700，模数为 $998244353$ 时为 $241'200'029$；$10^9+7$ 时为 $598375978$。

#### 逆元+卢卡斯定理（质数取模）

$\mathcal O(N)$ ，模数必须为质数。

```cpp
struct Comb {
    int n;
    vector<Z> _fac, _inv;

    Comb() : _fac{1}, _inv{0} {}
    Comb(int n) : Comb() {
        init(n);
    }
    void init(int m) {
        if (m <= n) return;
        _fac.resize(m + 1);
        _inv.resize(m + 1);
        for (int i = n + 1; i <= m; i++) {
            _fac[i] = _fac[i - 1] * i;
        }
        _inv[m] = _fac[m].inv();
        for (int i = m; i > n; i--) {
            _inv[i - 1] = _inv[i] * i;
        }
        n = m;
    }
    Z fac(int x) {
        if (x > n) init(x);
        return _fac[x];
    }
    Z inv(int x) {
        if (x > n) init(x);
        return _inv[x];
    }
    Z C(int x, int y) {
        if (x < 0 || y < 0 || x < y) return 0;
        return fac(x) * inv(y) * inv(x - y);
    }
    Z P(int x, int y) {
        if (x < 0 || y < 0 || x < y) return 0;
        return fac(x) * inv(x - y);
    }
} comb(1 << 21);
```

#### 质因数分解

此法适用于：$1 \lt n, m, MOD \lt 10^7$ 的情况。

```cpp
int n,m,p,b[10000005],prime[1000005],t,min_prime[10000005];
void euler_Prime(int n){//用欧拉筛求出1~n中每个数的最小质因数的编号是多少，保存在min_prime中
    for(int i=2;i<=n;i++){
        if(b[i]==0){
            prime[++t]=i;
            min_prime[i]=t;
        }
        for(int j=1;j<=t&&i*prime[j]<=n;j++){
            b[prime[j]*i]=1;
            min_prime[prime[j]*i]=j;
            if(i%prime[j]==0) break;
        }
    }
}
long long c(int n,int m,int p){//计算C(n,m)%p的值
    euler_Prime(n);
    int a[t+5];//t代表1~n中质数的个数 ，a[i]代表编号为i的质数在答案中出现的次数
    for(int i=1;i<=t;i++) a[i]=0;//注意清0，一开始是随机数
    for(int i=n;i>=n-m+1;i--){//处理分子
        int x=i;
        while (x!=1){
            a[min_prime[x]]++;//注意min_prime中保存的是这个数的最小质因数的编号（1~t）
            x/=prime[min_prime[x]];
        }
    }
    for(int i=1;i<=m;i++){//处理分母
        int x=i;
        while (x!=1){
            a[min_prime[x]]--;
            x/=prime[min_prime[x]];
        }
    }
    long long ans=1;
    for(int i=1;i<=t;i++){//枚举质数的编号，看它出现了几次
        while(a[i]>0){
            ans=ans*prime[i]%p;
            a[i]--;
        }
    }
    return ans;
}
int main(){
    cin>>n>>m;
    m=min(m,n-m);//小优化
    cout<<c(n,m,MOD);
}
```

#### 杨辉三角（精确计算）

$60$ 以内 `long long` 可解，$130$ 以内 `__int128` 可解。

```cpp
vector C(n + 1, vector<int>(n + 1));
C[0][0] = 1;
for (int i = 1; i <= n; i++) {
    C[i][0] = 1;
    for (int j = 1; j <= n; j++) {
        C[i][j] = C[i - 1][j] + C[i - 1][j - 1];
    }
}
cout << C[n][m] << endl;
```

### 常用组合数公式

- $k *C^k_n=n*C^{k-1}_{n-1}$ ；
- $C_k^n*C_m^k=C_m^n*C_{m-n}^{m-k}$ ；
- $C_n^k+C_n^{k+1}=C_{n+1}^{k+1}$ ；
- $\sum_{i=0}^n C_n^i=2^n$ ；
- $\sum_{k=0}^n(-1)^k*C_n^k=0$ 。
- 二项式反演：$\left\{\begin{matrix} \displaystyle f*n=\sum*{i=0}^n{n\choose i}g*i\Leftrightarrow g_n=\sum*{i=0}^n(-1)^{n-i}{n\choose i}f*i \\
  \displaystyle f_k=\sum*{i=k}^n{i\choose k}g*i\Leftrightarrow g_k=\sum*{i=k}^n(-1)^{i-k}{i\choose k}f_i \end{matrix}\right. $ ；
- $\displaystyle \sum_{i=1}^{n}i{n\choose i}=n * 2^{n-1}$ ；
- $\displaystyle \sum_{i=1}^{n}i^2{n\choose i}=n*(n+1)*2^{n-2}$ ；
- $\displaystyle \sum_{i=1}^{n}\dfrac{1}{i}{n\choose i}=\sum_{i=1}^{n}\dfrac{1}{i}$ ；
- $\displaystyle \sum_{i=0}^{n}{n\choose i}^2={2n\choose n}$ ；
- 拉格朗日恒等式：$\displaystyle \sum_{i=1}^{n}\sum_{j=i+1}^{n}(a_ib_j-a_jb_i)^2=(\sum_{i=1}^{n}a_i)^2(\sum_{i=1}^{n}b_i)^2-(\sum_{i=1}^{n}a_ib_i)^2$ 。

### lucas 定理

Lucas 定理内容如下：对于质数 $p$，有

$$
\binom{n}{m}\bmod p = \binom{\left\lfloor n/p \right\rfloor}{\left\lfloor m/p\right\rfloor}\cdot\binom{n\bmod p}{m\bmod p}\bmod p
$$

观察上述表达式，可知 $n\bmod p$ 和 $m\bmod p$ 一定是小于 $p$ 的数，可以直接求解，$\displaystyle\binom{\left\lfloor n/p \right\rfloor}{\left\lfloor m/p\right\rfloor}$ 可以继续用 Lucas 定理求解。这也就要求 $p$ 的范围不能够太大，一般在 $10^5$ 左右。边界条件：当 $m=0$ 的时候，返回 $1$。

时间复杂度为 $O(f(p) + g(n)\log n)$，其中 $f(n)$ 为预处理组合数的复杂度，$g(n)$ 为单次求组合数的复杂度。

```cpp
long long Lucas(long long n, long lm, long long p) {
  if (m == 0) return 1;
  return (C(n % p, m % p, p) * Lucas(n / p, m / p, p)) % p;
}
```

```python
def Lucas(n, m, p):
    if m == 0:
        return 1
    return (C(n % p, m % p, p) * Lucas(n // p, m // p, p)) % p
```

### 范德蒙德卷积公式

在数量为 $n+m$ 的堆中选 $k$ 个元素，和分别在数量为 $n、m$ 的堆中选 $i、k-i$ 个元素的方案数是相同的，即$\displaystyle{\sum_{i=0}^k\binom{n}{i}\binom{m}{k-i}=\binom{n+m}{k}}$ ；

变体：

- $\sum_{i=0}^k C_{i+n}^{i}=C_{k+n+1}^{k}$ ；
- $\sum_{i=0}^k C_{n}^{i}*C_m^i=\sum_{i=0}^k C_{n}^{i}*C_m^{m-i}=C_{n+m}^{n}$ 。

##### 推论 1 及证明

$$
\sum_{i=-r}^{s}\binom{n}{r+i}\binom{m}{s-i}=\binom{n+m}{r+s}
$$

##### 推论 2 及证明

$$
\sum_{i=1}^n\binom{n}{i}\binom{n}{i-1}=\sum_{i=0}^{n-1}\binom{n}{i+1}\binom{n}{i}=\sum_{i=0}^{n-1}\binom{n}{n-1-i}\binom{n}{i}=\binom{2n}{n-1}
$$

##### 推论 3 及证明

$$
\sum_{i=0}^n\binom{n}{i}^2=\sum_{i=0}^n\binom{n}{i}\binom{n}{n-i}=\binom{2n}{n}
$$

##### 推论 4 及证明

$$
\sum_{i=0}^m\binom{n}{i}\binom{m}{i}=\sum_{i=0}^m\binom{n}{i}\binom{m}{m-i}=\binom{n+m}{m}
$$

其中 $\binom{n+m}{m}$ 是我们较为熟悉的网格图路径计数的方案数。所以我们可以考虑其组合意义的证明。

在一张网格图中，从 $(0,0)$ 走到 $(n,m)$ 共走 $n+m$ 步。规定 $(0,0)$ 位于网格图左上角，其中向下走了 $n$ 步，向右走了 $m$ 步，方案数为 $\binom{n+m}{m}$。

换个视角，我们将 $n+m$ 步拆成两部分走，先走 $n$ 步，再走 $m$ 步，那么 $n$ 步中若有 $i$ 步向右，则 $m$ 步中就有 $m-i$ 步向右，故得证。

### 卡特兰数

是一类奇特的组合数，前几项为 $1,1,2,5,14,42,132,429,1430,4862$ 。如遇到以下问题，则直接套用即可。

- 【括号匹配问题】 $n$ 个左括号和 $n$ 个右括号组成的合法括号序列的数量，为 $Cat_n$ 。
- 【进出栈问题】 $1,2,…,n$ 经过一个栈，形成的合法出栈序列的数量，为 $Cat_n$ 。
- 【二叉树生成问题】 $n$ 个节点构成的不同二叉树的数量，为 $Cat_n$ 。
- 【路径数量问题】在平面直角坐标系上，每一步只能**向上**或**向右**走，从 $(0,0)$ 走到 $(n,n)$ ，并且除两个端点外不接触直线 $y=x$ 的路线数量，为 $2Cat_{n-1}$ 。

计算公式：$Cat_n=\dfrac{C^n_{2n}}{n+1}$ ，$Cat_n=\dfrac{Cat_{n-1}*(4n-2)}{n+1}$ 。

### 斯特林数

#### 第一类斯特林数

- **递推公式**
  $[n, m] = [n-1, m-1] + (n-1) \cdot [n-1, m]$
  从组合意义上讲即自己作为一个新的轮换 或者自己插入到已有的人的左边
- **递推边界**
  $ = 1$

#### 第二类斯特林数

- **递推公式**
  $\{n, m\} = \{n-1, m-1\} + m \cdot \{n-1, m\}$
  从组合意义上讲即自己作为一个新的子集 或者自己插入已有的子集中
- **常用公式**
  $x^n = \sum_{k=0}^n \{n, k\} (x)_k$ 常用化简 $n^m$
- **递推边界**
  $\{0,0\} = 1$
- **计算公式**
  $\{n, m\} = \frac{1}{m!} \sum_{i=0}^m (-1)^{m-i} \binom{m}{i} i^n$

#### 普通幂 下降幂 上升幂互化

$x^n = \sum_{k=0}^n \{n,k\}x^{\underline k}$ 普通幂转下降幂
$x^{\underline n} = \sum_{k=0}^n [n,k](-1)^{n-k}x^k$ 下降幂转普通幂
$x^n = \sum_{k=0}^n \{n,k\}(-1)^{n-k}x^{\overline k}$ 普通幂转上升幂
$x^{\overline n} = \sum_{k=0}^n [n,k]x^k$ 上升幂转普通幂

#### 斯特林数恒等式

- $n! = \sum_{k=0}^n [n,k]$

- $\sum_{k=1}^{n+1} [n,k]\{k,m\} = \binom{n}{m}$

- $\sum_{k=1}^{n+1} \{n,k\}[k,m] = \binom{n}{m}$

- $\{n,n-1\} = \binom{n}{2}$

- **第二类斯特林数 行 即求出** $\{n,0\}, \{n,1\}, \dots, \{n,n\}$
  显然公式就是卷积形式 NTT 即可
- **第二类斯特林数 列 即** $\{0,k\}, \{1,k\}, \dots, \{n,k\}$
  我们考虑设出其生成函数然后递推
  根据递推式我们有 $H(n) = \sum_i (\{i-1,k-1\} + k\{i-1,k\})x^i$
  那么有 $H(n) = \frac{xH(n-1)}{1-kx}$ 也即 $H(n) = \frac{x^k}{\prod_{i=0}^k (1-ix)}$
  十分需要注意的是我们需要在分治以后把多项式的$size$重置为$k$ (开小会 RE)
  之后再求逆
- **第二类斯特林数求和 即** $\sum_{i=0}^n \sum_{j=0}^i \{i,j\}$
  考虑按公式展开并交换求和次序 即 $\sum_{j=0}^n \frac{1}{j!} \sum_{k=0}^j (-1)^{j-k}\binom{j}{k} \sum_{i=0}^n k^i$
  发现后面是个卷积形式 然后$O(n \log n)$求得 $O(n)$遍历即可

### 莫茨金数

$M_n = M_{n-1} + \sum_{i=0}^{n-2} M_i M_{n-2-i} = \frac{(2n+1)M_{n-1} + 3(n-1)M_{n-2}}{n+2}$
$M_n = \sum_{k=0}^{\lfloor n/2 \rfloor} \binom{n}{2k} C_k$ (C 为卡特兰数)
1, 1, 2, 4, 9, 21, 51, 127, 323, 835, ...

##### **经典应用场景:**

1.一个圆上有 n 个点,画若干条不相交弦的方案数 2.在一个二维网格从$(0,0)$走到$(n,0)$,$k_1$表示向右上走一步,$k_0$表示向右走一步,$k_{-1}$表示向右下走一步
要求路径中始终不能低于 x 轴,终点必须在 $(n,0)$ ，问方案数。

### 球盒模型

#### $n$ 个球 全部放入 $m$ 个盒子

##### I：球互不相同，盒子互不相同。

每个球都有 m 种选择，根据乘法原理，答案是$m^n$

##### II：球互不相同，盒子互不相同，每个盒子至多装一个球。

$n > m$ , 放不下，$0$ 种可能
$n <= m$ , $ A(m, n) $

##### III：球互不相同，盒子互不相同，每个盒子至少装一个球。+

容斥枚举空盒个数
$$\sum_{i=0}^m {(-1)^i} * C(m, i) * (m - i)^n$$

或 第二类斯特林数乘上 $m$ 的阶乘 $m!\cdot{\tt Stirling2}(n,m)$ ，答案为 $dp[n][m] * m!$ 。

##### IV：球互不相同，盒子全部相同。

枚举几个盒子有球，第二类斯特林数，设 $f[k][b]$ 为将 $k$ 个互异元素分为 $b$ 个不为空的集合
$$ ans = \sum\_{i = 0}^m {f[n][i]}$$

##### V：球互不相同，盒子全部相同，每个盒子至多装一个球。

$n > m, 0$
$n <= m, 1$

##### VI：球互不相同，盒子全部相同，每个盒子至少装一个球。

正是第二类斯特林数的定义，答案是 $f[n][m]$ .

$$
dp[n][m]=
\left\{\begin{matrix}
m*dp[n-1][m]+dp[n-1][m-1] & 1 \le m \lt n\\
1 & 0 \le n == m\\
0 & m == 0 且 1 \le n
\end{matrix}\right.
$$

##### VII：球全部相同，盒子互不相同。

插板法， $C(n + m - 1, m - 1)$ .

##### VIII：球全部相同，盒子互不相同，每个盒子至多装一个球。

选$n$个盒子放球， $C(m, n)$ .

##### IX：球全部相同，盒子互不相同，每个盒子至少装一个球。

先把每个盒子放一个球，然后转化为第 VII 个问题，插板法
$C(n - 1, m - 1)$

##### X：球全部相同，盒子全部相同。

解 1：

问题等价于将 $n+m$ 拆分为 $m$ 个无序的正整数，根据 $Ferrers$ 图的理论，
等价于将 $n+m$ 拆分成若干个不超过 $m$ 的正整数，直接生成函数做。
$$T(n,m)=T(n,m−1)+T(n−m,m)$$
$$ [x ^ {n + m - m}]\prod\_{i = 1}^m\frac{1}{1 - x ^ i}$$

解 2：

$\dfrac{1}{(1-x)(1-x^2)\dots(1-x^m)}$ 的 $x^n$ 项的系数。动态规划，答案为

$$
dp[i][j]=
\left\{\begin{matrix}
dp[i][j-1]+dp[i-j][j]     & i\geq j  \\
dp[i][j-1]                            & i \lt j   \\
1                                             & j==1 \ || \ i \leq 1
\end{matrix}\right.
$$

##### XI：球全部相同，盒子全部相同，每个盒子至多装一个球。

同 V

##### XII：球全部相同，盒子全部相同，每个盒子至少装一个球。

解 1：

$$ [x ^ {n - m}]\prod\_{i = 1}^m\frac{1}{1 - x ^ i}$$

解 2：

$\dfrac{x^m}{(1-x)(1-x^2)\dots(1-x^m)}$ 的 $x^n$ 项的系数。动态规划，答案为

$$
dp[n][m]=
\left\{\begin{matrix}
dp[n-m][m]     & n\ge m  \\
0                            & n \lt m   \\
\end{matrix}\right.
$$

```cpp
#include <algorithm>
#include <cstdio>
int n, m, fac[400010], minv[400010];
int const mod = 998244353, g = 3, gi = (mod + 1) / g;
int C(int x, int y)
{
    if (x < 0 || y < 0 || x < y)
        return 0;
    else
        return 1ll * fac[x] * minv[y] % mod * minv[x - y] % mod;
}
int pow(int x, int y)
{
    int res = 1;
    while (y) {
        if (y & 1)
            res = 1ll * res * x % mod;
        x = 1ll * x * x % mod;
        y >>= 1;
    }
    return res;
}
struct NTT {
    int r[800010], lim;
    NTT()
        : r()
        , lim()
    {
    }
    void getr(int lm)
    {
        lim = lm;
        for (int i = 0; i < lim; i++)
            r[i] = (r[i >> 1] >> 1) | ((i & 1) * (lim >> 1));
    }
    void operator()(int* a, int type)
    {
        for (int i = 0; i < lim; i++)
            if (i < r[i])
                std::swap(a[i], a[r[i]]);
        for (int mid = 1; mid < lim; mid <<= 1) {
            int rt = pow(type == 1 ? g : gi, (mod - 1) / (mid << 1));
            for (int j = 0, r = mid << 1; j < lim; j += r) {
                int p = 1;
                for (int k = 0; k < mid; k++, p = 1ll * p * rt % mod) {
                    int x = a[j + k], y = 1ll * a[j + mid + k] * p % mod;
                    a[j + k] = (x + y) % mod, a[j + mid + k] = (x - y + mod) % mod;
                }
            }
        }
        if (type == -1)
            for (int i = 0, p = pow(lim, mod - 2); i < lim; i++)
                a[i] = 1ll * a[i] * p % mod;
    }
} ntt;
void inv(int const* a, int* ans, int n)
{
    static int tmp[800010];
    for (int i = 0; i < n << 1; i++)
        tmp[i] = ans[i] = 0;
    ans[0] = pow(a[0], mod - 2);
    for (int m = 2; m <= n; m <<= 1) {
        int lim = m << 1;
        ntt.getr(lim);
        for (int i = 0; i < m; i++)
            tmp[i] = a[i];
        ntt(tmp, 1), ntt(ans, 1);
        for (int i = 0; i < lim; i++)
            ans[i] = ans[i] * (2 - 1ll * ans[i] * tmp[i] % mod + mod) % mod, tmp[i] = 0;
        ntt(ans, -1);
        for (int i = m; i < lim; i++)
            ans[i] = 0;
    }
}
void inte(int const* a, int* ans, int n)
{
    for (int i = n - 1; i; i--)
        ans[i] = 1ll * a[i - 1] * pow(i, mod - 2) % mod;
    ans[0] = 0;
}
void der(int const* a, int* ans, int n)
{
    for (int i = 1; i < n; i++)
        ans[i - 1] = 1ll * i * a[i] % mod;
    ans[n - 1] = 0;
}
void ln(int const* a, int* ans, int n)
{
    static int b[800010];
    for (int i = 0; i < n << 1; i++)
        ans[i] = b[i] = 0;
    inv(a, ans, n);
    der(a, b, n);
    int lim = n << 1;
    ntt.getr(lim);
    ntt(b, 1), ntt(ans, 1);
    for (int i = 0; i < lim; i++)
        b[i] = 1ll * ans[i] * b[i] % mod, ans[i] = 0;
    ntt(b, -1);
    for (int i = n; i < lim; i++)
        b[i] = 0;
    inte(b, ans, n);
}
void exp(int const* a, int* ans, int n)
{
    static int f[800010];
    for (int i = 0; i < n << 1; i++)
        ans[i] = f[i] = 0;
    ans[0] = 1;
    for (int m = 2; m <= n; m <<= 1) {
        int lim = m << 1;
        ln(ans, f, m);
        f[0] = (a[0] + 1 - f[0] + mod) % mod;
        for (int i = 1; i < m; i++)
            f[i] = (a[i] - f[i] + mod) % mod;
        ntt.getr(lim);
        ntt(f, 1), ntt(ans, 1);
        for (int i = 0; i < lim; i++)
            ans[i] = 1ll * ans[i] * f[i] % mod, f[i] = 0;
        ntt(ans, -1);
        for (int i = m; i < lim; i++)
            ans[i] = 0;
    }
}
void solve1() { printf("%d\n", pow(m, n)); }
void solve2()
{
    if (m < n)
        puts("0");
    else
        printf("%lld\n", 1ll * fac[m] * minv[m - n] % mod);
}
void solve3()
{
    if (n < m)
        return puts("0"), void();
    int ans = 0;
    for (int i = 0; i <= m; i++)
        ans = (ans + 1ll * pow(mod - 1, i) * C(m, i) % mod * pow(m - i, n)) % mod;
    printf("%d\n", ans);
}
int s[800010];
void solve4()
{
    static int tmp[800010];
    for (int i = 0; i <= n; i++)
        tmp[i] = (i & 1 ? mod - 1ll : 1ll) * minv[i] % mod, s[i] = 1ll * pow(i, n) * minv[i] % mod;
    int lim = 1;
    for (lim = 1; lim <= n + n; lim <<= 1)
        ;
    ntt.getr(lim);
    ntt(tmp, 1), ntt(s, 1);
    for (int i = 0; i < lim; i++)
        s[i] = 1ll * s[i] * tmp[i] % mod;
    ntt(s, -1);
    for (int i = n + 1; i < lim; i++)
        s[i] = 0;
    int ans = 0;
    for (int i = 0; i <= m; i++)
        ans = (ans + s[i]) % mod;
    printf("%d\n", ans);
}
void solve5() { printf("%d\n", int(m >= n)); }
void solve6() { printf("%d\n", s[m]); }
void solve7() { printf("%d\n", C(n + m - 1, m - 1)); }
void solve8() { printf("%d\n", C(m, n)); }
void solve9() { printf("%d\n", C(n - 1, m - 1)); }
int ans[800010];
void solve10()
{
    static int tmp[800010];
    for (int i = 1; i <= m; i++)
        for (int j = 1; j * i <= n; j++)
            ans[i * j] = (ans[i * j] - 1ll * minv[j] * fac[j - 1] % mod + mod) % mod;
    int lim = 1;
    for (; lim <= n; lim <<= 1)
        ;

    exp(ans, tmp, lim);
    for (int i = 0; i < lim; i++)
        ans[i] = 0;
    inv(tmp, ans, lim);
    printf("%d\n", ans[n]);
}
void solve11() { printf("%d\n", int(m >= n)); }
void solve12()
{
    printf("%d\n", n - m >= 0 ? ans[n - m] : 0);
}
int main()
{
    scanf("%d%d", &n, &m);
    fac[0] = 1;
    for (int i = 1; i <= n + m; i++)
        fac[i] = 1ll * fac[i - 1] * i % mod;
    minv[n + m] = pow(fac[n + m], mod - 2);
    for (int i = n + m; i; i--)
        minv[i - 1] = 1ll * minv[i] * i % mod;
    solve1();
    solve2();
    solve3();
    solve4();
    solve5();
    solve6();
    solve7();
    solve8();
    solve9();
    solve10();
    solve11();
    solve12();
    return 0;
}
```

### 容斥原理

> 定义：$\big|S_1 \cup S_2 \cup S_3 \cup … \cup S_n \big | =\sum_{i=1}^N|S_i|   -   \sum_{i,j=1}^N \big| S_i \cap S_j \big|   +   \sum_{i,j,k=1}^N \big| S_i \cap S_j \cap S_k \big| -…$

例题：给定一个整数 $n$ 和 $m$ 个不同的质数 $p_1, p_2, ..., p_m$，请你求出 1 ∼ $n$ 中能被 $p_1, p_2, ..., p_m$ 中的至少一个数整除的整数有多少个。

#### 二进制枚举解

```cpp
int main(){
    ios::sync_with_stdio(false);cin.tie(0);
    LL n, m;
    cin >> n >> m;
    vector <LL> p(m);
    for (int i = 0; i < m; i ++ )
        cin >> p[i];
    LL ans = 0;
    for (int i = 1; i < (1 << m); i ++ ){
        LL t = 1, cnt = 0;
        for (int j = 0; j < m; j ++ ){
            if (i >> j & 1){
                cnt ++ ;
                t *= p[j];
                if (t > n){
                    t = -1;
                    break;
                }
            }
        }
        if (t != -1){
            if (cnt & 1) ans += n / t;
            else ans -= n / t;
        }
    }
    cout << ans << "\n";
    return 0;
}
```

#### dfs 解

```cpp
int main(){
    ios::sync_with_stdio(false);cin.tie(0);
    LL n, m;
    cin >> n >> m;
    vector <LL> p(m);
    for (int i = 0; i < m; i ++ )
        cin >> p[i];
    LL ans = 0;
    function<void(LL, LL, LL)> dfs = [&](LL x, LL s, LL odd){
        if (x == m){
            if (s == 1) return;
            ans += odd * (n / s);
            return;
        }
        dfs(x + 1, s, odd);
        if (s <= n / p[x]) dfs(x + 1, s * p[x], -odd);
    };
    dfs(0, 1, -1);
    cout << ans << "\n";
    return 0;
}
```

### 群论计数

#### Burnside 引理

给定群 $G$ 在集合 $X$ 上的作用，则所有不同的轨道的数目

$$
|X/G|=\frac{1}{|G|}\sum_{g\in G}|X^g|.
$$

这里，$X^g=\{x\in X:gx=x\}$ 是 $g\in G$ 的作用下的不动点集合。

#### Polya 引理

给定群 $G$ 在集合 $X$ 上的作用和颜色集合 $C$，则不同的染色方案的数目

$$
|C^X/G|=\frac{1}{|G|}\sum_{g\in G}m^{c(g)},
$$

这里，$m$ 是颜色数目，$c(g)$ 是元素 $g\in G$ 的置换表示的轮换分解中的轮换数目。

#### 带权重形式的推广

无权重版本的 Pólya 计数原理只能够给出所有的本质不同的染色问题的计数，但是在处理更为精细的问题时就无能为力了。比如说，如果在上述染色问题中，给定每种可以使用的颜色的数目，就不能套用上面的 Pólya 计数公式。在实际求解这类问题时，需要再次使用 Burnside 引理加以推导；而将这些结果总结为生成函数的形式，就是带权重版本的 Pólya 计数原理。

#### 例子

##### 项链染色（带限制）

现在有一串共四个珠子的项链，每个珠子可以是红色或者蓝色，恰有两个红色珠子、两个蓝色珠子可以使用，计算共有几种本质不同的珠子。（如果两种染色的结果可以通过旋转项链重合，就认为是相同的。)

##### 解答和分析

考虑使用 Burnside 引理。红色、蓝色珠子各两个，共计有 $\dbinom{4}{2}=6$ 种染色方案。空间对称群 $G=\{r_0,r_1,r_2,r_3\}$ 分别对应旋转 $0\sim3$ 次，则它们对应的不动点集合分析如下：

- 旋转零次 $r_0=(1)$，全部 $6$ 个染色方案都是不动点；
- 旋转一次 $r_1=(1234)$，不动点要求所有珠子染同样的颜色，没有不动点；
- 旋转两次 $r_2=(13)(24)$，有两个可独立染色的区域，大小都是 $2$，它们要分别染成红色和蓝色，则不动点集合的大小为 $2$；
- 旋转三次 $r_3=(1432)$，与旋转一次的情形相同，没有不动点。

所以，根据 Burnside 引理，本质不同的染色数目为

$$
\frac{6+0+2+0}{4}=2.
$$

从这个例子中可以总结出如下计算方法。对于限制不同颜色个数的问题，同样是要把空间对称群中各个置换的轮换分别染色，但是需要让染色用到的颜色数目恰好等于给定的颜色个数。这样的组合问题通常没有显式解，除了可以通过 [排列组合方法](../combinatorics/combination.md) 计算的特殊情形外，需要看做 [背包问题](../../dp/knapsack.md) 进行求解。

通过生成函数可以给出这类计数问题的答案。给定置换 $g$，如果它的 [型](../permutation.md#置换的型) 是 $1^{\alpha_1}2^{\alpha_2}\cdots n^{\alpha_n}$，即它有 $\alpha_k$ 个长度为 $k$ 的轮换，且对于每个轮换可以染成 $m$ 种颜色中的一种，那么生成函数

$$
\prod_{k=1}^n\left(\sum_{i=1}^mx_i^k\right)^{\alpha_k}
$$

中单项式 $x_1^{\beta_1}x_2^{\beta_2}\cdots x_m^{\beta_m}$ 的系数就是第 $i$ 种颜色用了 $\beta_i$ 次的计数。这里圆括号中的表达式 $\sum_{i=1}^mx_i^k$ 的组合意义是，对于长度为 $k$ 的轮换，用到 $k$ 次颜色 $i$ 的染色方法的计数是 $1$，对于其它情形，计数是 $0$；这正描述了同一轮换中各位置染色一致的要求。

给定置换 $g$ 下染色计数的生成函数，对各个单项式应用 Burnside 引理，就得到各种颜色组合下的本质不同的计数。因为生成函数对各个单项式是线性的，所以本质不同染色方案的计数的生成函数是

$$
\frac1{|G|}\sum_{g\in G}\prod_{k=1}^n\left(\sum_{i=1}^mx_i^k\right)^{\alpha_k}.
$$

展开这个式子，每个单项式的系数就给出了给定颜色组合下的本质不同染色的计数。

在上述过程中，对每个轮换进行染色的生成函数 $\sum_{i=1}^mx_i^k$ 并无特殊之处，可以替换成其它的生成函数。因而，有如下的一般版本的 Pólya 计数原理。

##### 置换群的轮换指标

给定置换群 $G$，则群 $G$ 的 **轮换指标**（cycle index），定义为

$$
Z_G(t_1,t_2,\cdots,t_n)=\frac{1}{|G|}\sum_{g\in G}t_1^{c_1(g)}t_2^{c_2(g)}\cdots t_n^{c_n(g)},
$$

其中，$c_k(g)$ 是置换 $g$ 的轮换分解中长度为 $k$ 的轮换的个数，即 $1^{c_1(g)}2^{c_2(g)}\cdots n^{c_n(g)}$ 是置换 $g$ 的型。

##### Pólya 计数原理（带权重版本）

给定群 $G$ 在集合 $X$ 上的作用，对每个点的染色方法由它的染色方案的计数的生成函数 $f(x_1,x_2,\cdots,x_m)$ 给出，那么集合 $X$ 的本质不同染色方案的计数的生成函数是

$$
Z_G(f(x_1^1,x_2^1,\cdots,x_m^1),f(x_1^2,x_2^2,\cdots,x_m^2),\cdots,f(x_1^n,x_2^n,\cdots,x_m^n)),
$$

这里，$Z_G(t_1,t_2,\cdots,t_n)$ 是群 $G$ 的轮换指标。

这里，如果单个位置的染色的生成函数是 $f(x_1,x_2,\cdots,x_m)$，那么长度为 $k$ 的轮换的染色的生成函数就是 $f(x_1^k,x_2^k,\cdots,x_m^k)$。这反映了如果某一染色方案是给定置换的不动点，那么同一轮换中的所有位置必须染相同的颜色。如果将生成函数在 $x_i=1$ 处取值，就得到上文的无权重版本的 Pólya 计数原理。

定理的叙述用到了置换群的轮换指标的概念。它和具体的染色问题无关。它描述了置换群的结构。

### 康拓展开

#### 正向展开普通解法

将一个字典序排列转换成序号。例如：12345->1，12354->2。

```cpp
int f[20];
void jie_cheng(int n) { // 打出1-n的阶乘表
    f[0] = f[1] = 1; // 0的阶乘为1
    for (int i = 2; i <= n; i++) f[i] = f[i - 1] * i;
}
string str;
int kangtuo() {
    int ans = 1; // 注意，因为 12345 是算作0开始计算的，最后结果要把12345看作是第一个
    int len = str.length();
    for (int i = 0; i < len; i++) {
        int tmp = 0; // 用来计数的
        // 计算str[i]是第几大的数，或者说计算有几个比他小的数
        for (int j = i + 1; j < len; j++)
            if (str[i] > str[j]) tmp++;
        ans += tmp * f[len - i - 1];
    }
    return ans;
}
int main() {
    jie_cheng(10);
    string str = "52413";
    cout << kangtuo() << endl;
}
```

#### 正向展开树状数组解

给定一个全排列，求出它是 1 ~ $n$ 所有全排列的第几个，答案对 $998244353$ 取模。

答案就是 $\sum_{i = 1}^{n} res_{a_i} (n - i)!$ 。$res_x$ 表示剩下的比 $x$ 小的数字的数量，通过**树状数组**处理。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define LL long long
const int mod = 998244353, N = 1e6 + 10;
LL fact[N];
struct fwt{
    LL n;
    vector <LL> a;
    fwt(LL n) : n(n), a(n + 1) {}
    LL sum(LL x){
        LL res = 0;
        for (; x; x -= x & -x)
            res += a[x];
        return res;
    }
    void add(LL x, LL k){
        for (; x <= n; x += x & -x)
            a[x] += k;
    }
    LL query(LL x, LL y){
        return sum(y) - sum(x - 1);
    }
};
int main(){
    ios::sync_with_stdio(false);cin.tie(0);
    LL n;
    cin >> n;
    fwt a(n);
    fact[0] = 1;
    for (int i = 1; i <= n; i ++ ){
        fact[i] = fact[i - 1] * i % mod;
        a.add(i, 1);
    }
    LL ans = 0;
    for (int i = 1; i <= n; i ++ ){
        LL x;
        cin >> x;
        ans = (ans + a.query(1, x - 1) * fact[n - i] % mod ) % mod;
        a.add(x, -1);
    }
    cout << (ans + 1) % mod << "\n";
    return 0;
}
```

#### 逆向还原

```cpp
string str;
int kangtuo(){
    int ans = 1;  //注意，因为 12345 是算作0开始计算的，最后结果要把12345看作是第一个
    int len = str.length();
    for(int i = 0; i < len; i++){
        int tmp = 0;//用来计数的
        for(int j = i + 1; j < len; j++){
            if(str[i] > str[j]) tmp++;
            //计算str[i]是第几大的数，或者说计算有几个比他小的数
        }
        ans += tmp * f[len - i - 1];
    }
    return ans;
}
int main(){
    jie_cheng(10);
    string str = "52413";
    cout<<kangtuo()<<endl;
}
```

### 基本格路计数问题

**问题描述:**
在平面上有多少从 $(0,0)$ 到 $(m, n) \in N \times N$ 点的格路经,其每一步都具有形式 $(1,0)$ 或 $(0,1)$(即每一步沿水平方向向右走或沿铅直方向向上走一个单位距离)。

**推导与结论:**
从 $(0,0)$ 到 $(m,n)$ 的路径,记沿水平方向向右走一个单位距离为 $E$,记沿竖直方向向上走一个单位距离为 $N$。其与多重集 $\{m \cdot E, n \cdot N\}$ 的排列一一对应,一条路径对应该多重集上的一个全排列。
所以共有:

$$
\frac{(m+n)!}{m!n!} = \binom{m+n}{m}
$$

种不同的走法。

### Dyck 路计数问题

格路模型是信息学竞赛中一种常见的问题模型,其中较为常见的一种是 **Dyck 路计数**的相关问题。

#### 定义

- **格路 (Lattice Path):** 在平面直角坐标系中,横坐标和纵坐标都是整数的点称为格点,平面格路是指从一个格点到另一格点只走格点的路,格路的**长度**是指其所走的路的步数。
- **自由路 (Free Path):** 对于一条从 $(0,0)$ 到 $(m,n)$ 的格路,若其只使用了上步 $U=(0,1)$,水平步 $L=(1,0)$,则我们称其为 $(m,n)$ **自由路**。
- **自由路计数:** 记 $F(n,m)$ 为 $(n,m)$ 自由路的全集,$F(n,m) = \#F(n,m)$ 为 $(n,m)$ 自由路的总个数,即 $F(n,m)$ 的元素个数。可以发现,一条 $(0,0)$ 到 $(n,m)$ 的自由路可以唯一地对应到一个含有 $n$ 个水平步 $L$ 和 $m$ 个上步 $U$ 的序列。因此,$(n,m)$ 自由路的条数等于从 $n+m$ 个位置中选出 $n$ 个位置的方案数,即 $\binom{n+m}{n}$。
  $$ F(n,m) = \binom{n+m}{n} $$
- **(n,m)-Dyck 路:** 对于一条从 $(0,0)$ 到 $(n,m)$ 的自由路,若其始终不经过对角线 $y = \frac{m}{n}x$ 下方,则我们称之为 $(n,m)$**-Dyck 路**。记 $D(n,m)$ 为 $(n,m)$-Dyck 路的集合,$D(n,m) = \#D(n,m)$ 为 $(n,m)$-Dyck 路的数量。
- **t-Dyck 路:** 特别地,若 $m=t \cdot n$,则我们称之为 $n$ 阶 **t-Dyck 路**。

#### (n,m)-Dyck 路的计数

**定理 2.2 (互质情况):** 当 $n,m$ 互质时,$(n,m)$-Dyck 路的数量为:
$$ D(n,m) = \frac{1}{n+m} \binom{n+m}{n} $$
**证明思路:** 利用 **Raney 引理** 的推广或通过更复杂的双射构造。一个关键引理是,当 $n,m$ 互质时,对任意一个 $(n,m)$ 自由路,通过循环移位(将其看作一个环),恰好只有一个循环同构的路径是 $(n,m)$-Dyck 路。总共有 $n+m$ 种循环移位,因此 Dyck 路占总数的 $\frac{1}{n+m}$。

#### 有 k 个峰的 (n,m)-Dyck 路计数

- **峰 (peak):** 对于一条从 $(0,0)$ 到 $(n,m)$ 的自由路中的连续两步,若其为 $UL$,则我们称之为**峰**。
- **谷 (valley):** 若其为 $LU$,则我们称之为一个**谷**。

**定理 2.3:** 记 $F(n,m;k)$ 为所有有恰好 $k$ 个峰的 $(n,m)$ 自由路的集合。则:
$$ F(n,m;k) = \binom{n}{k} \binom{m}{k} $$
**证明:** 将 $UL$ 之间的格点叫做峰点。一个有 $k$ 个峰的路径,其峰点坐标为 $(x_1, y_1), \dots, (x_k, y_k)$,满足 $0 \le x_1 < x_2 < \dots < x_k \le n-1$ 和 $1 \le y_1 < y_2 < \dots < y_k \le m$。选择 $k$ 个 $x$ 坐标和 $k$ 个 $y$ 坐标可以唯一确定一条有 $k$ 个峰的路径,反之亦然。因此方案数为 $\binom{n}{k}\binom{m}{k}$。

**定理 2.4:** 记 $F^{UL}(n,m;k)$ 为所有有恰好 $k$ 个峰,且首步为 $U$,末步为 $L$ 的 $(n,m)$ 自由路的集合。则:
$$ F^{UL}(n,m;k) = \binom{n-1}{k-1} \binom{m-1}{k-1} $$

**定理 2.5:** 记 $D(n,m;k)$ 为所有有恰好 $k$ 个峰的 $(n,m)$-Dyck 路的集合。当 $n,m$ 互质时:
$$ D(n,m;k) = \frac{1}{k} \binom{n-1}{k-1} \binom{m-1}{k-1} $$
**证明思路:** 对于任意一条 $F^{UL}(n,m;k)$ 中的路径,其 $k$ 个峰点可以循环映射到 $k-1$ 条不同的不合法路径上。因此,恰好有 $\frac{1}{k}$ 的路径是 Dyck 路。

**定理 2.6 (t-Dyck 路):** 有 $k$ 个峰的 $n$ 阶 $t$-Dyck 路的个数是:
$$ D(n,tn;k) = \frac{1}{n}\binom{n}{k}\binom{tn}{k-1} $$
将 $k$ 从 1 到 $n$ 求和,可以得到 **$n$ 阶 $t$-Dyck 路的总数**:
$$ D(n,tn) = \frac{1}{tn+1}\binom{tn+n}{n} $$

**定理 2.8:** 从 $(0,0)$ 到 $(n,m)$ 的有 $k$ 个峰的 $t$-Dyck 路($m=tn$)的个数是:
$$ D_t(n,m;k) = \frac{m-tn+1}{n}\binom{n}{k}\binom{m}{k-1} $$
**定理 2.9:** 从 $(0,0)$ 到 $(n,m)$ 的 $t$-Dyck 路的总个数是:
$$ D_t(n,m) = \frac{m-tn+1}{n+m+1}\binom{n+m+1}{n} $$

### 不相交格路问题

#### n 阶不交 Dyck 路计数

**定义 3.1:** 从 $(0,0)$ 到 $(n,n)$ 的两条 Dyck 路 $P, Q$。若 $Q$ 始终不穿过 $P$ (即 $Q$ 在 $P$ 的下方或与之重合),则称 $(P,Q)$ 是一对**不交 Dyck 路**。

**定理 3.1:** $n$ 阶不交 Dyck 路对数为:
$$ C*{n+2} - C*{n+1}^2 $$
**证明思路:** 通过构造一个巧妙的双射 $\theta$,将一对不交的 Dyck 路 $(P,Q)$ 映射到从 $(0,0)$ 到 $(n+1, n+1)$ 的一条 Dyck 路和从 $(1,1)$ 到 $(n+2, n+2)$ 的一条 Dyck 路。利用这个双射关系,结合卡特兰数的性质进行推导。

#### 不交自由路计数

**定义 3.2:** 设 $P,Q$ 是两条自由路,如果 $Q$ 始终不穿越 $P$,则称 $(P,Q)$ 是从 $(0,0)$ 到 $(n,m)$ 的两条**不相交自由路对**。$F_{nc}(n,m)$ 表示不相交自由路对的个数。

**定理 3.3:** 从 $(0,0)$ 到 $(n,m)$ 的不接触自由路对(除了起点和终点)的个数为:
$$ F*{nt}(n,m) = \frac{1}{n+m-1}\binom{n+m-2}{n-1}\binom{n+m-2}{n-1} $$
**定理 3.4:** 从 $(0,0)$ 到 $(n,m)$ 的不交自由路对个数是:
$$ F*{nc}(n,m) = \frac{1}{n+m+1}\binom{n+m+1}{n}\binom{n+m+1}{n} $$
**证明思路:** 类似于不交 Dyck 路,通过双射将问题转化。将两条不交的 $(n,m)$ 自由路 $(P,Q)$ 构造成一条从 $(0,0)$ 到 $(n+1, m+1)$ 的不接触自由路对,从而建立数量关系。

### 类 Dyck 路计数问题(斜向行走)

从 $(0, 0)$ 走到 $(a, b)$,规定每次只能从 $(x, y)$ 走到左下或者右下,方案数记为 $f(a,b)$ 。

- $f(a,b)=\dbinom{a}{\tfrac{a+b}{2}}$ ；
- 若路径和直线 $y=k,k\notin [0,b]$ 不能有交点,则方案数为 $f(a,b)-f(a,2k-b)$ ；
- 若路径和两条直线 $y=k_1,y=k_2(k_1 < 0 \le b <k_2)$ 不能有交点,方案数记为 $g(a,b,k_1,k_2)$ ,可以使用 $\mathcal O(N)$ 递归求解；
- 若路径必须碰到 $y=k_1$ 但是不能碰到 $y=k_2$ ,方案数记为 $h(a,b,k_1,k_2)$,可以使用 $\mathcal O(N)$ 递归求解(递归过程中两条直线距离会越来越大)。

从 $(0, 0)$ 走到 $(a, 0)$,规定每次只能走到左下或者右下,且必须有**恰好一次**传送(向下 $b$ 单位),且不能走到 $x$ 轴下方,方案数为 $\dbinom{a+1}{\frac{a-b}{2}+k+1}$ 。

### 格路计数与经典分拆恒等式

格路计数方法可以用于建立和证明关于基本超几何函数和整数分拆的恒等式。

#### 枚举函数与 q-升阶乘

- **q-升阶乘符号:** $(x;q)_n = \prod_{k=0}^{n-1} (1-xq^k)$

- **引理 1:**
  i) 纵向步骤 $V$ 起始的格路枚举函数为 $\prod_{i=1}^m (1-tq^{i-1})^{-1}$。
  ii) 纵向步骤 $V$ 起始且终点高度为 $n$ 的格路枚举函数为 $t^n/(q;q)_n$。
  iii) 具有不等水平矢量表示的纵向步骤 $V$ 起始的格路枚举函数为 $(-tq;q)_\infty$。

#### Gauss 二项式系数

**定义:** $[^n_k]_q = \frac{(q;q)_n}{(q;q)_k(q;q)_{n-k}}$

**命题 3:** 终点坐标为 $(m,n)$ 的格路枚举函数为 Gauss 二项式系数 $[^{m+n}_n]_q$。

#### Durfee 矩与经典分拆恒等式

通过将格路按其所包容的最大 $(k+r) \times k$ **Durfee 矩形**进行分类,可以推导出复杂的组合恒等式。

- **定理 5:**
  $$ (tq)_\infty^{-1} = \sum_{k=0}^m \begin{bmatrix} m-r \\ k \end{bmatrix} t^k q^{k(k+r)} / (tq)\_{k+r} $$
- **系理 6 (Kummer 定理的有限形式):**
  i) $(tq)_\infty^{-1} = \sum_{k=0}^m \begin{bmatrix} m \\ k \end{bmatrix} t^k q^k / (tq)_k$
  ii) $(tq)_\infty^{-1} = \sum_{k=0}^\infty t^k q^{k(k+r)} / (q)_k(tq)_{k+r}$

通过对这些公式取极限或特定值,可以得到 **Euler 五角数定理**,**Cauchy 恒等式**,**Jacobi 三重积恒等式**等著名结论。

**Euler 五角数定理**的极限形式为:
$$ (q)_\infty = \sum_{k=-\infty}^{\infty} (-1)^k q^{k(3k+1)/2} $$

#### 格路计数的常用结论

##### 反射原理 (Reflection Principle)

反射原理是一种巧妙的组合计数技巧,用于处理带有**边界限制**的格路计数问题。其核心思想如下:

1. **转化问题:** 将直接求解“合法路径数”的难题,转化为求解“总路径数”减去“不合法路径数”。总路径数通常很容易计算。

2. **建立一一对应:** 将**每一条不合法的路径**(即触碰或穿越了限制边界的路径),通过一次**轴对称变换(反射)**,**唯一地**映射到另一条从**新的起点**出发到**原终点**的无限制路径。

3. **计数替换:** 由于不合法路径与新起点路径之间存在一一对应关系,因此“不合法路径的数量”就等于“从新起点到原终点的路径总数”。后者是一个无限制的格路问题,可以直接用组合数公式计算。

简单来说,就是用**反射起点的无限制路径数**来等价替换**原起点的非法路径数**。

_图示:一条从 A 到 B 的不合法路径(红色),在第一个接触点 P 处,将 A 到 P 段关于直线 L 反射,得到一条从反射点 A'到 B 的路径(绿色)。_

---

#### 模型一:标准格路模型

- **移动方式:** 每步只能向右 $(+1, 0)$ 或向上 $(0, +1)$。
- **总路径数:** 从 $(a, b)$ 到 $(c, d)$ 的总路径数为 $\binom{(c-a)+(d-b)}{c-a}$。

**定理 1.1:单条边界线(不能触碰)**

- **问题:** 从 $(a,b)$ 到 $(c,d)$,路径不能触碰直线 $L: y=x+k$。

- **前提:** 起点和终点都在直线 $L$ 的同一侧(通常是下方)。

- **反射起点:** 将起点 $(a,b)$ 关于直线 $L: y=x+k$ 反射,得到新起点 $A'(b-k, a+k)$。

- **公式:**
  $$
  \text{合法路径数} = \binom{(c-a)+(d-b)}{c-a} - \binom{(c-(b-k))+(d-(a+k))}{c-(b-k)}
  $$
  即: **(从原起点到终点的总路径数) - (从反射起点到终点的总路径数)**

**定理 1.2:卡特兰数 (Catalan Number)**

- **问题:** 从 $(0,0)$ 到 $(n,n)$,路径不能越过对角线 $y=x$(即不能到达 $y=x$ 上方)。

- **等价问题:** 路径不能触碰直线 $y=x+1$。

- **公式:**
  $$
  C_n = \binom{2n}{n} - \binom{2n}{n+1} = \frac{1}{n+1}\binom{2n}{n}
  $$

#### 模型二:斜向格路模型

- **移动方式:** 每步只能右上 $(+1, +1)$ 或右下 $(+1, -1)$。
- **总路径数:** 从 $(0,0)$ 到 $(a,b)$ 的总路径数为 $\binom{a}{\frac{a+b}{2}}$。(要求 $a+b$ 为偶数且 $a \ge |b|$)

**定理 2.1:单条水平边界线(不能触碰)**

- **问题:** 从 $(a,b)$ 到 $(c,d)$,路径不能触碰水平直线 $L: y=k$。

- **前提:** 起点和终点都在直线 $L$ 的同一侧。

- **反射终点:** 将终点 $(c,d)$ 关于直线 $L: y=k$ 反射,得到新终点 $B'(c, 2k-d)$。

- **公式:**
  $$
  \text{合法路径数} = \binom{c-a}{\frac{(c-a)+(d-b)}{2}} - \binom{c-a}{\frac{(c-a)+(2k-d-b)}{2}}
  $$
  即: **(从起点到原终点的总路径数) - (从起点到反射终点的总路径数)**

**说明:**

- 在这两个模型中,反射起点还是终点是等价的,选择计算更方便的一个即可。
- **"不能越过"** 和 **"不能触碰"** 是有区别的。“不能越过 $y=x$” 意味着路径上的点 $(x_p, y_p)$ 始终满足 $y_p \le x_p$。这等价于“不能触碰 $y=x+1$”。在比赛中要仔细审题。

### 杂项

1. 考虑不定方程 $X_1+X_2+\dots+X_n=m, (X_i>0)$ 的解的数量
   也就是把$m$分成$n$堆的方案数,我们运用插空法为 $\binom{m-1}{n-1}$
2. 考虑不定方程 $X_1+X_2+\dots+X_n=m, (X_i>=0)$ 的解的数量
   我们把所有的$X_i$变为$X_i+1$那么套用结论 1,方案数为 $C(m+n-1, n-1)$
3. 在$n$个红球中插入$m$个蓝球,空格大小不限,可以插入两边,方案数为 $C(n+m,m)$
   证明:考虑有$n+1$个空格可以插入,那么问题转化为不定方程 $X_1+\dots+X_{n+1}=m, (X_i\geq 0)$ 的解的个数
4. 在$n$个红球中插入$m$个蓝球,空格大小不限,不可插入两边,方案数为 $C(n+m-2, m-2)$
   证明:考虑有$n-1$个空格可以插入,那么问题转化为不定方程 $X_1+\dots+X_{n-1}=m, (X_i\geq 0)$ 的解的个数
5. 考虑在$[1,n]$区间内选$k$个数,满足$k$个数都不相邻 问选法多少种
   考虑到不能相邻的原因,我们不妨考虑把每个选的数字和它的下一个数字绑在一起,特别地最后一个数字不用捆绑,那么答案为$\binom{n-k+1}{k}$
