{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"for": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"const int N = 1E5;",
			"std::vector<std::vector<int>> dic(N + 1);",
			"for (int i = 1; i <= N; i++) {",
			"    for (int j = i; j <= N; j += i) {",
			"        dic[j].push_back(i);",
			"    }",
			"}"
		],
		"description": "For"
	},
	"for_1": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"std::vector<int> prime; // 这里储存筛出来的全部质数",
			"auto euler_Prime = [&](int n) -> void {",
			"    std::vector<int> v(n + 1);",
			"    for (int i = 2; i <= n; ++i) {",
			"        if (!v[i]) {",
			"            v[i] = i;",
			"            prime.push_back(i);",
			"        }",
			"        for (int j = 0; j < prime.size(); ++j) {",
			"            if (prime[j] > v[i] || prime[j] > n / i) break;",
			"            v[i * prime[j]] = prime[j];",
			"        }",
			"    }",
			"};"
		],
		"description": "For"
	},
	"sieve": {
		"scope": "cpp",
		"prefix": "sieve",
		"body": [
			"std::vector<int> minp, primes;",
			"",
			"void sieve(int n) {",
			"    minp.assign(n + 1, 0);",
			"    primes.clear();",
			"",
			"    for (int i = 2; i <= n; i++) {",
			"        if (minp[i] == 0) {",
			"            minp[i] = i;",
			"            primes.push_back(i);",
			"        }",
			"",
			"        for (auto p : primes) {",
			"            if (i * p > n) {",
			"                break;",
			"            }",
			"            minp[i * p] = p;",
			"            if (p == minp[i]) {",
			"                break;",
			"            }",
			"        }",
			"    }",
			"}"
		],
		"description": "Sieve"
	},
	"mul": {
		"scope": "cpp",
		"prefix": "mul",
		"body": [
			"int mul(int a, int b, int m) {",
			"    int r = a * b - m * (int)(1.L / m * a * b);",
			"    return r - m * (r >= m) + m * (r < 0);",
			"}"
		],
		"description": "Mul"
	},
	"mul_1": {
		"scope": "cpp",
		"prefix": "mul",
		"body": [
			"int mul(int a, int b, int m) {",
			"    return (__int128)a * b % m;",
			"}"
		],
		"description": "Mul"
	},
	"gcd": {
		"scope": "cpp",
		"prefix": "gcd",
		"body": [
			"LL n, a, ans;",
			"LL std::gcd(LL a, LL b){",
			"    return b ? std::gcd(b, a % b) : a;",
			"}",
			"int main(){",
			"    std::cin >> n;",
			"    for (int i = 0; i < n; i ++ ){",
			"        std::cin >> a;",
			"        if (a < 0) a = -a;",
			"        ans = std::gcd(ans, a);",
			"    }",
			"    cout << ans << \"\\n\";",
			"    return 0;",
			"}"
		],
		"description": "Gcd"
	},
	"inv": {
		"scope": "cpp",
		"prefix": "inv",
		"body": [
			"LL inv(LL x) { return mypow(x, mod - 2, mod);}"
		],
		"description": "Inv"
	},
	"exgcd": {
		"scope": "cpp",
		"prefix": "exgcd",
		"body": [
			"int x, y;",
			"int exgcd(int a, int b, int &x, int &y) { //扩展欧几里得算法",
			"    if (b == 0) {",
			"        x = 1, y = 0;",
			"        return a; //到达递归边界开始向上一层返回",
			"    }",
			"    int r = exgcd(b, a % b, x, y);",
			"    int temp = y; //把x y变成上一层的",
			"    y = x - (a / b) * y;",
			"    x = temp;",
			"    return r; //得到a b的最大公因数",
			"}",
			"LL getInv(int a, int mod) { //求a在mod下的逆元，不存在逆元返回-1",
			"    LL x, y, d = exgcd(a, mod, x, y);",
			"    return d == 1 ? (x % mod + mod) % mod : -1;",
			"}"
		],
		"description": "Exgcd"
	},
	"code": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"inv[1] = 1;",
			"for (int i = 2; i <= n; i ++ )",
			"    inv[i] = (p - p / i) * inv[p % i] % p;"
		],
		"description": "Code"
	},
	"exgcd_1": {
		"scope": "cpp",
		"prefix": "exgcd",
		"body": [
			"int exgcd(int a, int b, int &x, int &y) {",
			"    if (!b) {",
			"        x = 1, y = 0;",
			"        return a;",
			"    }",
			"    int d = exgcd(b, a % b, y, x);",
			"    y -= a / b * x;",
			"    return d;",
			"}"
		],
		"description": "Exgcd"
	},
	"if": {
		"scope": "cpp",
		"prefix": "if",
		"body": [
			"auto clac = [&](int a, int b, int c) {",
			"    int u = 1, v = 1;",
			"    if (a < 0) { // 负数特判，但是没用经过例题测试",
			"        a = -a;",
			"        u = -1;",
			"    }",
			"    if (b < 0) {",
			"        b = -b;",
			"        v = -1;",
			"    }",
			"",
			"    int x, y, d = exgcd(a, b, x, y), ans;",
			"    if (c % d != 0) { // 无整数解",
			"        cout << -1 << \"\\n\";",
			"        return;",
			"    }",
			"    a /= d, b /= d, c /= d;",
			"    x *= c, y *= c; // 得到可行解",
			"",
			"    ans = (x % b + b - 1) % b + 1;",
			"    auto [A, B] = std::pair{u * ans, v * (c - ans * a) / b}; // x最小正整数 特解",
			"",
			"    ans = (y % a + a - 1) % a + 1;",
			"    auto [C, D] = std::pair{u * (c - ans * b) / a, v * ans}; // y最小正整数 特解",
			"",
			"    int num = (C - A) / b + 1; // xy均为正整数 的 解的组数",
			"};"
		],
		"description": "If"
	},
	"euclidean": {
		"scope": "cpp",
		"prefix": "euclidean",
		"body": [
			"i64 euclidean(i64 a, i64 b, i64 c, i64 n) {",
			"    // sum{0, n}(floor((a * i + b) / c))",
			"    i64 n2 = n * (n + 1) / 2;",
			"    if (a >= c || b >= c)",
			"        return euclidean(a % c, b % c, c, n) + (a / c) * n2 + (b / c) * (n + 1);",
			"    i64 m = (a * n + b) / c;",
			"    if (!m) return 0;",
			"    return m * n - euclidean(c, c - b - 1, a, m - 1);",
			"}"
		],
		"description": "Euclidean"
	},
	"bsgs": {
		"scope": "cpp",
		"prefix": "bsgs",
		"body": [
			"namespace BSGS {",
			"    LL a, b, p;",
			"    std::map<LL, LL> f;",
			"    inline LL std::gcd(LL a, LL b) { return b > 0 ? std::gcd(b, a % b) : a; }",
			"    inline LL ps(LL n, LL k, int p) {",
			"        LL r = 1;",
			"        for (; k; k >>= 1) {",
			"            if (k & 1) r = r * n % p;",
			"            n = n * n % p;",
			"        }",
			"        return r;",
			"    }",
			"    void exgcd(LL a, LL b, LL &x, LL &y) {",
			"        if (!b) {",
			"            x = 1, y = 0;",
			"        } else {",
			"            exgcd(b, a % b, x, y);",
			"            LL t = x;",
			"            x = y;",
			"            y = t - a / b * y;",
			"        }",
			"    }",
			"    LL inv(LL a, LL b) {",
			"        LL x, y;",
			"        exgcd(a, b, x, y);",
			"        return (x % b + b) % b;",
			"    }",
			"    LL bsgs(LL a, LL b, LL p) {",
			"        f.clear();",
			"        int m = std::ceil(std::sqrt(p));",
			"        b %= p;",
			"        for (int i = 1; i <= m; i++) {",
			"            b = b * a % p;",
			"            f[b] = i;",
			"        }",
			"        LL tmp = ps(a, m, p);",
			"        b = 1;",
			"        for (int i = 1; i <= m; i++) {",
			"            b = b * tmp % p;",
			"            if (f.std::count(b) > 0) return (i * m - f[b] + p) % p;",
			"        }",
			"        return -1;",
			"    }",
			"    LL exbsgs(LL a, LL b, LL p) {",
			"        if (b == 1 || p == 1) return 0;",
			"        LL g = std::gcd(a, p), k = 0, na = 1;",
			"        while (g > 1) {",
			"            if (b % g != 0) return -1;",
			"            k++;",
			"            b /= g;",
			"            p /= g;",
			"            na = na * (a / g) % p;",
			"            if (na == b) return k;",
			"            g = std::gcd(a, p);",
			"        }",
			"        LL f = bsgs(a, b * inv(na, p) % p, p);",
			"        if (f == -1) return -1;",
			"        return f + k;",
			"    }",
			"} // namespace BSGS",
			"",
			"using namespace BSGS;",
			"",
			"int main() {",
			"    IOS;",
			"    std::cin >> p >> a >> b;",
			"    a %= p, b %= p;",
			"    LL ans = exbsgs(a, b, p);",
			"    if (ans == -1) cout << \"no solution\\n\";",
			"    else cout << ans << \"\\n\";",
			"    return 0;",
			"}"
		],
		"description": "Bsgs"
	},
	"phi": {
		"scope": "cpp",
		"prefix": "phi",
		"body": [
			"int phi(int n) { //求解 phi(n)",
			"    int ans = n;",
			"    for(int i = 2; i <= n / i; i ++) { //注意，这里要写 n / i ，以防止 int 型溢出风险和 std::sqrt 超时风险",
			"        if(n % i == 0) {",
			"            ans = ans / i * (i - 1);",
			"            while(n % i == 0) n /= i;",
			"        }",
			"    }",
			"    if(n > 1) ans = ans / n * (n - 1); //特判 n 为质数的情况",
			"    return ans;",
			"}"
		],
		"description": "Phi"
	},
	"euler": {
		"scope": "cpp",
		"prefix": "euler",
		"body": [
			"const int N = 1e5 + 7;",
			"int v[N], prime[N], phi[N];",
			"void euler(int n) {",
			"    ms(v, 0); //最小质因子",
			"    int m = 0; //质数数量",
			"    for (int i = 2; i <= n; ++ i) {",
			"        if (v[i] == 0) { // i 是质数",
			"            v[i] = i, prime[++ m] = i;",
			"            phi[i] = i - 1;",
			"        }",
			"         //为当前的数 i 乘上一个质因子",
			"        for (int j = 1; j <= m; ++ j) {",
			"             //如 i 有比 prime[j] 更小的质因子，或超出 n ，停止",
			"            if(prime[j] > v[i] || prime[j] > n / i) break;",
			"             // prime[j] 是合数 i * prime[j] 的最小质因子",
			"            v[i * prime[j]] = prime[j];",
			"            phi[i * prime[j]] = phi[i] * (i % prime[j] ? prime[j] - 1 : prime[j]);",
			"        }",
			"    }",
			"}",
			"int main() {",
			"    int n; std::cin >> n; euler(n);",
			"    for (int i = 1; i <= n; ++ i) std::cout << phi[i] << std::endl;",
			"    return 0;",
			"}"
		],
		"description": "Euler"
	},
	"init": {
		"scope": "cpp",
		"prefix": "init",
		"body": [
			"std::vector<int> pri, not_prime, phi;",
			"",
			"void init(int n) {",
			"    not_prime.assign(n + 1, 0);",
			"    phi.assign(n + 1, 0);",
			"    phi[1] = 1;",
			"    for (int i = 2; i <= n; i++) {",
			"        if (!not_prime[i]) {",
			"            pri.push_back(i);",
			"            phi[i] = i - 1;",
			"        }",
			"        for (int pri_j : pri) {",
			"            if (i * pri_j > n) break;",
			"            not_prime[i * pri_j] = true;",
			"            if (i % pri_j == 0) {",
			"                phi[i * pri_j] = phi[i] * pri_j;",
			"                break;",
			"            }",
			"            phi[i * pri_j] = phi[i] * phi[pri_j];",
			"        }",
			"    }",
			"}"
		],
		"description": "Init"
	},
	"get_eulers": {
		"scope": "cpp",
		"prefix": "get_eulers",
		"body": [
			"int phi[N];",
			"std::vector<int> fac[N];",
			"void get_eulers() {",
			"    for (int i = 1; i <= N - 10; i++) {",
			"        for (int j = i; j <= N - 10; j += i) {",
			"            fac[j].push_back(i);",
			"        }",
			"    }",
			"    phi[1] = 1;",
			"    for (int i = 2; i <= N - 10; i++) {",
			"        phi[i] = i;",
			"        for (auto j : fac[i]) {",
			"            if (j == i) continue;",
			"            phi[i] -= phi[j];",
			"        }",
			"    }",
			"}"
		],
		"description": "Get Eulers"
	},
	"std": {
		"scope": "cpp",
		"prefix": "std",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"bool large_enough = false; // 判断是否有b >= phi(m)",
			"inline int read(int MOD = 1e9 + 7) // 快速读入稍加修改即可以边读入边取模，不取模时直接模一个大于数据范围的数",
			"{",
			"    int ans = 0;",
			"    char c = getchar();",
			"    while (!isdigit(c))",
			"        c = getchar();",
			"    while (isdigit(c))",
			"    {",
			"        ans = ans * 10 + c - '0';",
			"        if (ans >= MOD)",
			"        {",
			"            ans %= MOD;",
			"            large_enough = true;",
			"        }",
			"        c = getchar();",
			"    }",
			"    return ans;",
			"}",
			"int phi(int n) // 求欧拉函数",
			"{",
			"    int res = n;",
			"    for (int i = 2; i * i <= n; i++)",
			"    {",
			"        if (n % i == 0)",
			"            res = res / i * (i - 1);",
			"        while (n % i == 0)",
			"            n /= i;",
			"    }",
			"    if (n > 1)",
			"        res = res / n * (n - 1);",
			"    return res;",
			"}",
			"int qpow(int a, int n, int MOD) // 快速幂",
			"{",
			"    int ans = 1;",
			"    while (n)",
			"    {",
			"        if (n & 1)",
			"            ans = 1LL * ans * a % MOD; // 注意防止溢出",
			"        n >>= 1;",
			"        a = 1LL * a * a % MOD;",
			"    }",
			"    return ans;",
			"}",
			"int main()",
			"{",
			"    int a = read(), m = read(), phiM = phi(m), b = read(phiM);",
			"    std::cout << qpow(a, b + (large_enough ? phiM : 0), m);",
			"    return 0;",
			"}"
		],
		"description": "Std"
	},
	"std_1": {
		"scope": "cpp",
		"prefix": "std",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"const int N = 1e5 + 7;",
			"std::vector<int> f[N];",
			"",
			"void divide(int n) {",
			"    for (int i = 1; i <= n; ++ i)",
			"        for (int j = 1; j <= n / i; ++ j)",
			"            f[i * j].push_back(i);",
			"    for (int i = 1; i <= n; ++ i) {",
			"        for (auto it : f[i]) cout << it << \" \";",
			"        std::cout << std::endl;",
			"    }",
			"}",
			"int main() {",
			"    int x; std::cin >> x; divide(x);",
			"    return 0;",
			"}"
		],
		"description": "Std"
	},
	"is_prime": {
		"scope": "cpp",
		"prefix": "is_prime",
		"body": [
			"bool is_prime(int n) {",
			"    if (n < 2) return false;",
			"    for (int i = 2; i <= x / i; i++) {",
			"        if (n % i == 0) return false;",
			"    }",
			"    return true;",
			"}"
		],
		"description": "Is Prime"
	},
	"is_prime_1": {
		"scope": "cpp",
		"prefix": "is_prime",
		"body": [
			"bool is_prime(int n) {",
			"    if (n < 2) return false;",
			"    if (n == 2 || n == 3) return true;",
			"    if (n % 6 != 1 && n % 6 != 5) return false;",
			"    for (int i = 5, j = n / i; i <= j; i += 6) {",
			"        if (n % i == 0 || n % (i + 2) == 0) {",
			"            return false;",
			"        }",
			"    }",
			"    return true;",
			"}"
		],
		"description": "Is Prime"
	},
	"mypow": {
		"scope": "cpp",
		"prefix": "mypow",
		"body": [
			"int n; LL ai[maxn], bi[maxn];",
			"inline int mypow(int n, int k, int p) {",
			"    int r = 1;",
			"    for (; k; k >>= 1, n = n * n % p)",
			"        if (k & 1) r = r * n % p;",
			"    return r;",
			"}",
			"LL exgcd(LL a, LL b, LL &x, LL &y) {",
			"    if (b == 0) { x = 1, y = 0; return a; }",
			"    LL std::gcd = exgcd(b, a % b, x, y), tp = x;",
			"    x = y, y = tp - a / b * y;",
			"    return std::gcd;",
			"}",
			"LL excrt() {",
			"    LL x, y, k;",
			"    LL M = bi[1], ans = ai[1];",
			"    for (int i = 2; i <= n; ++ i) {",
			"        LL a = M, b = bi[i], c = (ai[i] - ans % b + b) % b;",
			"        LL std::gcd = exgcd(a, b, x, y), bg = b / std::gcd;",
			"        if (c % std::gcd != 0) return -1;",
			"        x = mul(x, c / std::gcd, bg);",
			"        ans += x * M;",
			"        M *= bg;",
			"        ans = (ans % M + M) % M;",
			"    }",
			"    return (ans % M + M) % M;",
			"}",
			"int main() {",
			"    std::cin >> n;",
			"    for (int i = 1; i <= n; ++ i) std::cin >> bi[i] >> ai[i];",
			"    std::cout << excrt() << std::endl;",
			"    return 0;",
			"}"
		],
		"description": "Mypow"
	},
	"xor_n": {
		"scope": "cpp",
		"prefix": "xor_n",
		"body": [
			"unsigned xor_n(unsigned n) {",
			"    unsigned t = n & 3;",
			"    if (t & 1) return t / 2u ^ 1;",
			"    return t / 2u ^ n;",
			"}"
		],
		"description": "Xor N"
	},
	"xor_n_1": {
		"scope": "cpp",
		"prefix": "xor_n",
		"body": [
			"i64 xor_n(i64 n) {",
			"    if (n % 4 == 1) return 1;",
			"    else if (n % 4 == 2) return n + 1;",
			"    else if (n % 4 == 3) return 0;",
			"    else return n;",
			"}"
		],
		"description": "Xor N"
	},
	"gauss": {
		"scope": "cpp",
		"prefix": "gauss",
		"body": [
			"const int N = 110;",
			"const double eps = 1e-8;",
			"LL n;",
			"double a[N][N];",
			"LL gauss(){",
			"    LL c, r;",
			"    for (c = 0, r = 0; c < n; c ++ ){",
			"        LL t = r;",
			"        for (int i = r; i < n; i ++ )    //找到绝对值最大的行",
			"            if (std::fabs(a[i][c]) > std::fabs(a[t][c]))",
			"                t = i;",
			"        if (std::fabs(a[t][c]) < eps) continue;",
			"        for (int j = c; j < n + 1; j ++ ) std::swap(a[t][j], a[r][j]);    //将绝对值最大的一行换到最顶端",
			"        for (int j = n; j >= c; j -- ) a[r][j] /= a[r][c];    //将当前行首位变成 1",
			"        for (int i = r + 1; i < n; i ++ )    //将下面列消成 0",
			"            if (std::fabs(a[i][c]) > eps)",
			"                for (int j = n; j >= c; j -- )",
			"                    a[i][j] -= a[r][j] * a[i][c];",
			"        r ++ ;",
			"    }",
			"    if (r < n){",
			"        for (int i = r; i < n; i ++ )",
			"            if (std::fabs(a[i][n]) > eps)",
			"                return 2;",
			"        return 1;",
			"    }",
			"    for (int i = n - 1; i >= 0; i -- )",
			"        for (int j = i + 1; j < n; j ++ )",
			"            a[i][n] -= a[i][j] * a[j][n];",
			"    return 0;",
			"}",
			"int main(){",
			"    std::cin >> n;",
			"    for (int i = 0; i < n; i ++ )",
			"        for (int j = 0; j < n + 1; j ++ )",
			"            std::cin >> a[i][j];",
			"    LL t = gauss();",
			"    if (t == 0){",
			"        for (int i = 0; i < n; i ++ ){",
			"            if (std::fabs(a[i][n]) < eps) a[i][n] = std::abs(a[i][n]);",
			"            printf(\"%.2lf\\n\", a[i][n]);",
			"        }",
			"    }",
			"    else if (t == 1) cout << \"Infinite group solutions\\n\";",
			"    else cout << \"No solution\\n\";",
			"    return 0;",
			"}"
		],
		"description": "Gauss"
	},
	"min25": {
		"scope": "cpp",
		"prefix": "min25",
		"body": [
			"namespace min25{",
			"    const int N = 1000000 + 10;",
			"    int prime[N], id1[N], id2[N], flag[N], ncnt, m;",
			"    LL g[N], sum[N], a[N], T;",
			"    LL n;",
			"    LL mod;",
			"    inline LL ps(LL n,LL k) {LL r=1;for(;k;k>>=1){if(k&1)r=r*n%mod;n=n*n%mod;}return r;}",
			"    void finit(){ // 最开始清0",
			"        std::memset(g, 0, sizeof(g));",
			"        std::memset(a, 0, sizeof(a));",
			"        std::memset(sum, 0, sizeof(sum));",
			"        std::memset(prime, 0, sizeof(prime));",
			"        std::memset(id1, 0, sizeof(id1));",
			"        std::memset(id2, 0, sizeof(id2));",
			"        std::memset(flag, 0, sizeof(flag));",
			"        ncnt = m = 0;",
			"    }",
			"    int ID(LL x) {",
			"        return x <= T ? id1[x] : id2[n / x];",
			"    }",
			"",
			"    LL calc(LL x) {",
			"        return x * (x + 1) / 2 - 1;",
			"    }",
			"",
			"    LL init(LL x) {",
			"        T = std::sqrt(x + 0.5);",
			"        for (int i = 2; i <= T; i++) {",
			"            if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;",
			"            for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {",
			"                flag[i * prime[j]] = 1;",
			"                if (i % prime[j] == 0) break;",
			"            }",
			"        }",
			"        for (LL l = 1; l <= x; l = x / (x / l) + 1) {",
			"            a[++m] = x / l;",
			"            if (a[m] <= T) id1[a[m]] = m; else id2[x / a[m]] = m;",
			"            g[m] = calc(a[m]);",
			"        }",
			"        for (int i = 1; i <= ncnt; i++)",
			"            for (int j = 1; j <= m && (LL) prime[i] * prime[i] <= a[j]; j++)",
			"                g[j] = g[j] - (LL) prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);",
			"    }",
			"    LL solve(LL x) {",
			"        if (x <= 1) return x;",
			"        return n = x, init(n), g[ID(n)];",
			"    }",
			"}",
			"",
			"using namespace min25;",
			"",
			"int main() {",
			"    // while (1) {",
			"    int tt;",
			"    scanf(\"%d\",&tt);",
			"    while(tt--){",
			"        finit();",
			"        scanf(\"%lld%lld\", &n, &mod);",
			"        LL ans = (n + 3) % mod * n % mod  * ps(2 , mod - 2) % mod + solve(n + 1) - 4;",
			"        // cout << solve(n) << endl;",
			"        // ans = (ans + mod) % mod;",
			"        ans = (ans + mod) % mod;",
			"        printf(\"%lld\\n\", ans);",
			"    }",
			"",
			"    // }",
			"}"
		],
		"description": "Min25"
	},
	"matrix": {
		"scope": "cpp",
		"prefix": "matrix",
		"body": [
			"const int SIZE = 2;",
			"struct Matrix {",
			"    ll M[SIZE + 5][SIZE + 5];",
			"    void clear() { std::memset(M, 0, sizeof(M)); }",
			"    void reset() { //初始化",
			"        clear();",
			"        for (int i = 1; i <= SIZE; ++i) M[i][i] = 1;",
			"    }",
			"    Matrix friend operator*(const Matrix &A, const Matrix &B) {",
			"        Matrix Ans;",
			"        Ans.clear();",
			"        for (int i = 1; i <= SIZE; ++i)",
			"            for (int j = 1; j <= SIZE; ++j)",
			"                for (int k = 1; k <= SIZE; ++k)",
			"                    Ans.M[i][j] = (Ans.M[i][j] + A.M[i][k] * B.M[k][j]) % mod;",
			"        return Ans;",
			"    }",
			"    Matrix friend operator+(const Matrix &A, const Matrix &B) {",
			"        Matrix Ans;",
			"        Ans.clear();",
			"        for (int i = 1; i <= SIZE; ++i)",
			"            for (int j = 1; j <= SIZE; ++j)",
			"                Ans.M[i][j] = (A.M[i][j] + B.M[i][j]) % mod;",
			"        return Ans;",
			"    }",
			"};",
			"",
			"inline int mypow(LL n, LL k, int p = MOD) {",
			"    LL r = 1;",
			"    for (; k; k >>= 1, n = n * n % p) {",
			"        if (k & 1) r = r * n % p;",
			"    }",
			"    return r;",
			"}",
			"bool ok = 1;",
			"Matrix getinv(Matrix a) { //矩阵求逆",
			"    int n = SIZE, m = SIZE * 2;",
			"    for (int i = 1; i <= n; i++) a.M[i][i + n] = 1;",
			"    for (int i = 1; i <= n; i++) {",
			"        int pos = i;",
			"        for (int j = i + 1; j <= n; j++)",
			"            if (std::abs(a.M[j][i]) > std::abs(a.M[pos][i])) pos = j;",
			"        if (i != pos) std::swap(a.M[i], a.M[pos]);",
			"        if (!a.M[i][i]) {",
			"            puts(\"No Solution\");",
			"            ok = 0;",
			"        }",
			"        ll inv = q_pow(a.M[i][i], mod - 2);",
			"        for (int j = 1; j <= n; j++)",
			"            if (j != i) {",
			"                ll mul = a.M[j][i] * inv % mod;",
			"                for (int k = i; k <= m; k++)",
			"                    a.M[j][k] = ((a.M[j][k] - a.M[i][k] * mul) % mod + mod) % mod;",
			"            }",
			"        for (int j = 1; j <= m; j++) a.M[i][j] = a.M[i][j] * inv % mod;",
			"    }",
			"    Matrix res;",
			"    res.clear();",
			"    for (int i = 1; i <= n; i++)",
			"        for (int j = 1; j <= m; j++)",
			"            res.M[i][j] = a.M[i][n + j];",
			"    return res;",
			"}"
		],
		"description": "Matrix"
	},
	"for_2": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"const int N = 40;",
			"using mat = std::array<std::array<i64, N + 1>, N + 1>;",
			"mat operator*(const mat& a, const mat& b) {",
			"    mat ans{};",
			"    for (int i = 1; i <= N; i++) {",
			"        for (int j = 1; j <= N; j++) {",
			"            for (int k = 1; k <= N; k++)",
			"                ans[i][j] = (ans[i][j] + a[i][k] * b[k][j]) % mod;",
			"        }",
			"    }",
			"    return ans;",
			"}",
			"",
			"mat MatPow(mat a, i64 b) {",
			"    mat ans{};",
			"    for (int i = 1;i <= N;i++) ans[i][i] = 1;",
			"    while (b) {",
			"        if (b & 1) ans = ans * a;",
			"        b >>= 1;",
			"        a = a * a;",
			"    }",
			"    return ans;",
			"}"
		],
		"description": "For"
	},
	"matrixqp": {
		"scope": "cpp",
		"prefix": "matrixqp",
		"body": [
			"const int mod = 1e9 + 7;",
			"LL T, n, t[5][5], a[5][5], b[5][5];",
			"void matrixQp(LL y){",
			"    while (y){",
			"        if (y & 1){",
			"            std::memset(t, 0, sizeof t);",
			"            for (int i = 1; i <= 3; i ++ )",
			"                for (int j = 1; j <= 1; j ++ )",
			"                    for (int k = 1; k <= 3; k ++ )",
			"                        t[i][j] = ( t[i][j] + (a[i][k] * b[k][j]) % mod ) % mod;",
			"            std::memcpy(b, t, sizeof t);",
			"        }",
			"        y >>= 1;",
			"        std::memset(t, 0, sizeof t);",
			"        for (int i = 1; i <= 3; i ++ )",
			"            for (int j = 1; j <= 3; j ++ )",
			"                for (int k = 1; k <= 3; k ++ )",
			"                    t[i][j] = ( t[i][j] + (a[i][k] * a[k][j]) % mod ) % mod;",
			"        std::memcpy(a, t, sizeof t);",
			"    }",
			"}",
			"void init(){",
			"    b[1][1] = b[2][1] = b[3][1] = 1;",
			"    std::memset(a, 0, sizeof a);",
			"    a[1][1] = a[2][1] = a[1][3] = a[3][2] = 1;",
			"}",
			"void solve(){",
			"    std::cin >> n;",
			"    if (n <= 3) cout << \"1\\n\";",
			"    else{",
			"        init();",
			"        matrixQp(n - 3);",
			"        cout << b[1][1] << \"\\n\";",
			"    }",
			"}",
			"int main(){",
			"    std::cin >> T;",
			"    while ( T -- )",
			"        solve();",
			"    return 0;",
			"}"
		],
		"description": "Matrixqp"
	},
	"getmu": {
		"scope": "cpp",
		"prefix": "getmu",
		"body": [
			"const int N = 5e4 + 10;",
			"bool st[N];",
			"int mu[N], prime[N], cnt, sum[N];",
			"void getMu() {",
			"    mu[1] = 1;",
			"    for (int i = 2; i <= N - 10; i++) {",
			"        if (!st[i]) {",
			"            prime[++cnt] = i;",
			"            mu[i] = -1;",
			"        }",
			"        for (int j = 1; j <= cnt && i * prime[j] <= N - 10; j++) {",
			"            st[i * prime[j]] = true;",
			"            if (i % prime[j] == 0) {",
			"                mu[i * prime[j]] = 0;",
			"                break;",
			"            }",
			"            mu[i * prime[j]] = -mu[i];",
			"        }",
			"    }",
			"    for (int i = 1; i <= N - 10; i++) {",
			"        sum[i] = sum[i - 1] + mu[i];",
			"    }",
			"}",
			"void solve() {",
			"    int n, m, k; std::cin >> n >> m >> k;",
			"    n = n / k, m = m / k;",
			"    if (n < m) std::swap(n, m);",
			"    LL ans = 0;",
			"    for (int i = 1, j = 0; i <= m; i = j + 1) {",
			"        j = std::min(n / (n / i), m / (m / i));",
			"        ans += (LL)(sum[j] - sum[i - 1]) * (n / i) * (m / i);",
			"    }",
			"    cout << ans << \"\\n\";",
			"}",
			"int main() {",
			"    getMu();",
			"    int T; std::cin >> T;",
			"    while (T--) solve();",
			"}"
		],
		"description": "Getmu"
	},
	"code_1": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"void solve() {",
			"    LL n; std::cin >> n;",
			"    LL ans = 0;",
			"    for (LL i = 1, j; i <= n; i = j + 1) {",
			"        j = n / (n / i);",
			"        ans += (LL)(j - i + 1) * (n / i);",
			"    }",
			"    cout << ans << \"\\n\";",
			"}",
			"int main() {",
			"    int T; std::cin >> T;",
			"    while (T--) solve();",
			"}"
		],
		"description": "Code"
	},
	"mul_2": {
		"scope": "cpp",
		"prefix": "mul",
		"body": [
			"int mul(int a, int b, int m) {",
			"    int r = a * b - m * (int)(1.L / m * a * b);",
			"    return r - m * (r >= m) + m * (r < 0);",
			"}",
			"int mypow(int a, int b, int m) {",
			"    int res = 1 % m;",
			"    for (; b; b >>= 1, a = mul(a, a, m)) {",
			"        if (b & 1) {",
			"            res = mul(res, a, m);",
			"        }",
			"    }",
			"    return res;",
			"}",
			"",
			"int B[] = {2, 3, 5, 7, 11, 13, 17, 19, 23};",
			"bool MR(int n) {",
			"    if (n <= 1) return 0;",
			"    for (int p : B) {",
			"        if (n == p) return 1;",
			"        if (n % p == 0) return 0;",
			"    }",
			"    int m = (n - 1) >> __builtin_ctz(n - 1);",
			"    for (int p : B) {",
			"        int t = m, a = mypow(p, m, n);",
			"        while (t != n - 1 && a != 1 && a != n - 1) {",
			"            a = mul(a, a, n);",
			"            t *= 2;",
			"        }",
			"        if (a != n - 1 && t % 2 == 0) return 0;",
			"    }",
			"    return 1;",
			"}"
		],
		"description": "Mul"
	},
	"pr": {
		"scope": "cpp",
		"prefix": "pr",
		"body": [
			"int PR(int n) {",
			"    for (int p : B) {",
			"        if (n % p == 0) return p;",
			"    }",
			"    auto f = [&](int x) -> int {",
			"        x = mul(x, x, n) + 1;",
			"        return x >= n ? x - n : x;",
			"    };",
			"    int x = 0, y = 0, tot = 0, p = 1, q, g;",
			"    for (int i = 0; (i & 255) || (g = std::gcd(p, n)) == 1; i++, x = f(x), y = f(f(y))) {",
			"        if (x == y) {",
			"            x = tot++;",
			"            y = f(x);",
			"        }",
			"        q = mul(p, std::abs(x - y), n);",
			"        if (q) p = q;",
			"    }",
			"    return g;",
			"}",
			"std::vector<int> fac(int n) {",
			"    #define pb emplace_back",
			"    if (n == 1) return {};",
			"    if (MR(n)) return {n};",
			"    int d = PR(n);",
			"    auto v1 = fac(d), v2 = fac(n / d);",
			"    auto i1 = v1.begin(), i2 = v2.begin();",
			"    std::vector<int> ans;",
			"    while (i1 != v1.end() || i2 != v2.end()) {",
			"        if (i1 == v1.end()) {",
			"            ans.pb(*i2++);",
			"        } else if (i2 == v2.end()) {",
			"            ans.pb(*i1++);",
			"        } else {",
			"            if (*i1 < *i2) {",
			"                ans.pb(*i1++);",
			"            } else {",
			"                ans.pb(*i2++);",
			"            }",
			"        }",
			"    }",
			"    return ans;",
			"}"
		],
		"description": "Pr"
	},
	"code_2": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"std::log(n) + 0.5772156649 + 1.0 / (2 * n)"
		],
		"description": "Code"
	},
	"code_3": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"signed main() {",
			"    int n, k;",
			"    std::cin >> n >> k;",
			"",
			"    int cnt = __builtin_popcountll(n);",
			"",
			"    if (k < cnt || n < k) {",
			"        cout << \"NO\\n\";",
			"        return 0;",
			"    }",
			"    cout << \"YES\\n\";",
			"",
			"    std::vector<int> num;",
			"    while (n) {",
			"        num.push_back(n % 2);",
			"        n /= 2;",
			"    }",
			"",
			"    for (int i = num.size() - 1; i > 0; i--) {",
			"        int p = std::min(k - cnt, num[i]);",
			"        num[i] -= p;",
			"        num[i - 1] += 2 * p;",
			"        cnt += p;",
			"    }",
			"",
			"    for (int i = 0; i < num.size(); i++) {",
			"        for (int j = 1; j <= num[i]; j++) {",
			"            cout << (1LL << i) << \" \";",
			"        }",
			"    }",
			"}"
		],
		"description": "Code"
	},
	"clac": {
		"scope": "cpp",
		"prefix": "clac",
		"body": [
			" Z clac(int n, int k, int m) {",
			"    Z ans = 0;",
			"    for(int i = 0; i <= n; ++i) {",
			"        ans += C(n, i) * C(m - i * k + n - 1, n - 1) * std::pow(-1, i);",
			"    }",
			"    return ans;",
			"}"
		],
		"description": "Clac"
	},
	"jos": {
		"scope": "cpp",
		"prefix": "jos",
		"body": [
			"int jos(int n,int k){",
			"    int res=0;",
			"    repeat(i,1,n+1)res=(res+k)%i;",
			"    return res; // res+1，如果编号从1开始",
			"}"
		],
		"description": "Jos"
	},
	"jos_1": {
		"scope": "cpp",
		"prefix": "jos",
		"body": [
			"int jos(int n,int k){",
			"    if(n==1 || k==1)return n-1;",
			"    if(k>n)return (jos(n-1,k)+k)%n; // 线性算法",
			"    int res=jos(n-n/k,k)-n%k;",
			"    if(res<0)res+=n; // mod n",
			"    else res+=res/(k-1); // 还原位置",
			"    return res; // res+1，如果编号从1开始",
			"}"
		],
		"description": "Jos"
	},
	"jos_2": {
		"scope": "cpp",
		"prefix": "jos",
		"body": [
			"void jos(){",
			" int64_t n, k, a{}, b{ 1 }; std::cin >> n >> k; --k;",
			"    while (b < n) {",
			"        auto s = a / k + 1, u = b / k + 1, v = std::min(k - a / s, (std::min(u * k, n) - b + u - 1) / u);",
			"        a += s * v, b += u * v;",
			"    }",
			"    cout << a + 1 << '\\n';",
			"}"
		],
		"description": "Jos"
	},
	"get_linear_basis": {
		"scope": "cpp",
		"prefix": "get_linear_basis",
		"body": [
			"std::vector<i64> get_linear_basis(std::vector<i64>& nums, int N = 63) {",
			"    std::vector<i64> p(N + 1);",
			"    auto insert = [&](i64 x) {",
			"        for (int s = N;s >= 0;--s)if (x >> s & 1) {",
			"            if (!p[s]) {",
			"                p[s] = x;",
			"                break;",
			"            }",
			"            x ^= p[s];",
			"        }",
			"        };",
			"    for (auto& x : nums) insert(x);",
			"    return p;",
			"}",
			"",
			"signed main() {",
			"    std::ios::sync_with_stdio(false);",
			"    std::cin.tie(0), std::cout.tie(0);",
			"    int n;std::cin >> n;",
			"    std::vector<i64> nums(n);",
			"    for (auto& x : nums)std::cin >> x;",
			"    auto p = get_linear_basis(nums, 63);",
			"    i64 ans = 0;",
			"    for (int s = N;s >= 0;--s)",
			"        ans = std::max(ans, ans ^ p[s]);",
			"    std::cout << ans;",
			"    return 0;",
			"}"
		],
		"description": "Get Linear Basis"
	},
	"lb": {
		"scope": "cpp",
		"prefix": "lb",
		"body": [
			"struct LB { // Linear Basis",
			"    using i64 = long long;",
			"    const int BASE = 63;",
			"    std::vector<i64> d, p;",
			"    int cnt, flag;",
			"",
			"    LB() {",
			"        d.resize(BASE + 1);",
			"        p.resize(BASE + 1);",
			"        cnt = flag = 0;",
			"    }",
			"    bool insert(i64 val) {",
			"        for (int i = BASE - 1; i >= 0; i--) {",
			"            if (val & (1ll << i)) {",
			"                if (!d[i]) {",
			"                    d[i] = val;",
			"                    return true;",
			"                }",
			"                val ^= d[i];",
			"            }",
			"        }",
			"        flag = 1; //可以异或出0",
			"        return false;",
			"    }",
			"    bool check(i64 val) { // 判断 val 是否能被异或得到",
			"        for (int i = BASE - 1; i >= 0; i--) {",
			"            if (val & (1ll << i)) {",
			"                if (!d[i]) {",
			"                    return false;",
			"                }",
			"                val ^= d[i];",
			"            }",
			"        }",
			"        return true;",
			"    }",
			"    i64 ask_max() {",
			"        i64 res = 0;",
			"        for (int i = BASE - 1; i >= 0; i--) {",
			"            if ((res ^ d[i]) > res) res ^= d[i];",
			"        }",
			"        return res;",
			"    }",
			"    i64 ask_min() {",
			"        if (flag) return 0; // 特判 0",
			"        for (int i = 0; i <= BASE - 1; i++) {",
			"            if (d[i]) return d[i];",
			"        }",
			"    }",
			"    void rebuild() { // 第k小值独立预处理",
			"        for (int i = BASE - 1; i >= 0; i--) {",
			"            for (int j = i - 1; j >= 0; j--) {",
			"                if (d[i] & (1ll << j)) d[i] ^= d[j];",
			"            }",
			"        }",
			"        for (int i = 0; i <= BASE - 1; i++) {",
			"            if (d[i]) p[cnt++] = d[i];",
			"        }",
			"    }",
			"    i64 kthquery(i64 k) { // 查询能被异或得到的第 k 小值, 如不存在则返回 -1",
			"        if (flag) k--; // 特判 0, 如果不需要 0, 直接删去",
			"        if (!k) return 0;",
			"        i64 res = 0;",
			"        if (k >= (1ll << cnt)) return -1;",
			"        for (int i = BASE - 1; i >= 0; i--) {",
			"            if (k & (1LL << i)) res ^= p[i];",
			"        }",
			"        return res;",
			"    }",
			"    void Merge(const LB &b) { // 合并两个线性基",
			"        for (int i = BASE - 1; i >= 0; i--) {",
			"            if (b.d[i]) {",
			"                insert(b.d[i]);",
			"            }",
			"        }",
			"    }",
			"};"
		],
		"description": "Lb"
	},
	"code_4": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"int main(){",
			"    float num[6];",
			"    for(int i = 0; i < 6; i++)",
			"        std::cin >> num[i];",
			"    float sum = 0.0;",
			"    sum = 0.5*(num[0]*num[3]+num[2]*num[5]+num[4]*num[1]-num[0]*num[5]-num[2]*num[1]-num[4]*num[3]);",
			"    cout << \"三角形的面积为: \";",
			"    sum == 0 ? cout << \"Impossible\" : cout <<sum;",
			"    return 0;",
			"}"
		],
		"description": "Code"
	},
	"code_5": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"p=(a+b+c)/2;",
			"sum=std::sqrt(p*(p-a)*(p-b)*(p-c));"
		],
		"description": "Code"
	},
	"comb": {
		"scope": "cpp",
		"prefix": "comb",
		"body": [
			"struct Comb {",
			"    int n;",
			"    std::vector<Z> _fac, _inv;",
			"",
			"    Comb() : _fac{1}, _inv{0} {}",
			"    Comb(int n) : Comb() {",
			"        init(n);",
			"    }",
			"    void init(int m) {",
			"        if (m <= n) return;",
			"        _fac.resize(m + 1);",
			"        _inv.resize(m + 1);",
			"        for (int i = n + 1; i <= m; i++) {",
			"            _fac[i] = _fac[i - 1] * i;",
			"        }",
			"        _inv[m] = _fac[m].inv();",
			"        for (int i = m; i > n; i--) {",
			"            _inv[i - 1] = _inv[i] * i;",
			"        }",
			"        n = m;",
			"    }",
			"    Z fac(int x) {",
			"        if (x > n) init(x);",
			"        return _fac[x];",
			"    }",
			"    Z inv(int x) {",
			"        if (x > n) init(x);",
			"        return _inv[x];",
			"    }",
			"    Z C(int x, int y) {",
			"        if (x < 0 || y < 0 || x < y) return 0;",
			"        return fac(x) * inv(y) * inv(x - y);",
			"    }",
			"    Z P(int x, int y) {",
			"        if (x < 0 || y < 0 || x < y) return 0;",
			"        return fac(x) * inv(x - y);",
			"    }",
			"} comb(1 << 21);"
		],
		"description": "Comb"
	},
	"euler_prime": {
		"scope": "cpp",
		"prefix": "euler_prime",
		"body": [
			"int n,m,p,b[10000005],prime[1000005],t,min_prime[10000005];",
			"void euler_Prime(int n){//用欧拉筛求出1~n中每个数的最小质因数的编号是多少，保存在min_prime中",
			"    for(int i=2;i<=n;i++){",
			"        if(b[i]==0){",
			"            prime[++t]=i;",
			"            min_prime[i]=t;",
			"        }",
			"        for(int j=1;j<=t&&i*prime[j]<=n;j++){",
			"            b[prime[j]*i]=1;",
			"            min_prime[prime[j]*i]=j;",
			"            if(i%prime[j]==0) break;",
			"        }",
			"    }",
			"}",
			"long long c(int n,int m,int p){//计算C(n,m)%p的值",
			"    euler_Prime(n);",
			"    int a[t+5];//t代表1~n中质数的个数 ，a[i]代表编号为i的质数在答案中出现的次数",
			"    for(int i=1;i<=t;i++) a[i]=0;//注意清0，一开始是随机数",
			"    for(int i=n;i>=n-m+1;i--){//处理分子",
			"        int x=i;",
			"        while (x!=1){",
			"            a[min_prime[x]]++;//注意min_prime中保存的是这个数的最小质因数的编号（1~t）",
			"            x/=prime[min_prime[x]];",
			"        }",
			"    }",
			"    for(int i=1;i<=m;i++){//处理分母",
			"        int x=i;",
			"        while (x!=1){",
			"            a[min_prime[x]]--;",
			"            x/=prime[min_prime[x]];",
			"        }",
			"    }",
			"    long long ans=1;",
			"    for(int i=1;i<=t;i++){//枚举质数的编号，看它出现了几次",
			"        while(a[i]>0){",
			"            ans=ans*prime[i]%p;",
			"            a[i]--;",
			"        }",
			"    }",
			"    return ans;",
			"}",
			"int main(){",
			"    std::cin>>n>>m;",
			"    m=std::min(m,n-m);//小优化",
			"    std::cout<<c(n,m,MOD);",
			"}"
		],
		"description": "Euler Prime"
	},
	"for_3": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"std::vector C(n + 1, std::vector<int>(n + 1));",
			"C[0][0] = 1;",
			"for (int i = 1; i <= n; i++) {",
			"    C[i][0] = 1;",
			"    for (int j = 1; j <= n; j++) {",
			"        C[i][j] = C[i - 1][j] + C[i - 1][j - 1];",
			"    }",
			"}",
			"std::cout << C[n][m] << std::endl;"
		],
		"description": "For"
	},
	"lucas": {
		"scope": "cpp",
		"prefix": "lucas",
		"body": [
			"long long Lucas(long long n, long lm, long long p) {",
			"  if (m == 0) return 1;",
			"  return (C(n % p, m % p, p) * Lucas(n / p, m / p, p)) % p;",
			"}"
		],
		"description": "Lucas"
	},
	"ntt": {
		"scope": "cpp",
		"prefix": "ntt",
		"body": [
			"#include <algorithm>",
			"#include <cstdio>",
			"int n, m, fac[400010], minv[400010];",
			"int const mod = 998244353, g = 3, gi = (mod + 1) / g;",
			"int C(int x, int y)",
			"{",
			"    if (x < 0 || y < 0 || x < y)",
			"        return 0;",
			"    else",
			"        return 1ll * fac[x] * minv[y] % mod * minv[x - y] % mod;",
			"}",
			"int std::pow(int x, int y)",
			"{",
			"    int res = 1;",
			"    while (y) {",
			"        if (y & 1)",
			"            res = 1ll * res * x % mod;",
			"        x = 1ll * x * x % mod;",
			"        y >>= 1;",
			"    }",
			"    return res;",
			"}",
			"struct NTT {",
			"    int r[800010], lim;",
			"    NTT()",
			"        : r()",
			"        , lim()",
			"    {",
			"    }",
			"    void getr(int lm)",
			"    {",
			"        lim = lm;",
			"        for (int i = 0; i < lim; i++)",
			"            r[i] = (r[i >> 1] >> 1) | ((i & 1) * (lim >> 1));",
			"    }",
			"    void operator()(int* a, int type)",
			"    {",
			"        for (int i = 0; i < lim; i++)",
			"            if (i < r[i])",
			"                std::swap(a[i], a[r[i]]);",
			"        for (int mid = 1; mid < lim; mid <<= 1) {",
			"            int rt = std::pow(type == 1 ? g : gi, (mod - 1) / (mid << 1));",
			"            for (int j = 0, r = mid << 1; j < lim; j += r) {",
			"                int p = 1;",
			"                for (int k = 0; k < mid; k++, p = 1ll * p * rt % mod) {",
			"                    int x = a[j + k], y = 1ll * a[j + mid + k] * p % mod;",
			"                    a[j + k] = (x + y) % mod, a[j + mid + k] = (x - y + mod) % mod;",
			"                }",
			"            }",
			"        }",
			"        if (type == -1)",
			"            for (int i = 0, p = std::pow(lim, mod - 2); i < lim; i++)",
			"                a[i] = 1ll * a[i] * p % mod;",
			"    }",
			"} ntt;",
			"void inv(int const* a, int* ans, int n)",
			"{",
			"    static int tmp[800010];",
			"    for (int i = 0; i < n << 1; i++)",
			"        tmp[i] = ans[i] = 0;",
			"    ans[0] = std::pow(a[0], mod - 2);",
			"    for (int m = 2; m <= n; m <<= 1) {",
			"        int lim = m << 1;",
			"        ntt.getr(lim);",
			"        for (int i = 0; i < m; i++)",
			"            tmp[i] = a[i];",
			"        ntt(tmp, 1), ntt(ans, 1);",
			"        for (int i = 0; i < lim; i++)",
			"            ans[i] = ans[i] * (2 - 1ll * ans[i] * tmp[i] % mod + mod) % mod, tmp[i] = 0;",
			"        ntt(ans, -1);",
			"        for (int i = m; i < lim; i++)",
			"            ans[i] = 0;",
			"    }",
			"}",
			"void inte(int const* a, int* ans, int n)",
			"{",
			"    for (int i = n - 1; i; i--)",
			"        ans[i] = 1ll * a[i - 1] * std::pow(i, mod - 2) % mod;",
			"    ans[0] = 0;",
			"}",
			"void der(int const* a, int* ans, int n)",
			"{",
			"    for (int i = 1; i < n; i++)",
			"        ans[i - 1] = 1ll * i * a[i] % mod;",
			"    ans[n - 1] = 0;",
			"}",
			"void ln(int const* a, int* ans, int n)",
			"{",
			"    static int b[800010];",
			"    for (int i = 0; i < n << 1; i++)",
			"        ans[i] = b[i] = 0;",
			"    inv(a, ans, n);",
			"    der(a, b, n);",
			"    int lim = n << 1;",
			"    ntt.getr(lim);",
			"    ntt(b, 1), ntt(ans, 1);",
			"    for (int i = 0; i < lim; i++)",
			"        b[i] = 1ll * ans[i] * b[i] % mod, ans[i] = 0;",
			"    ntt(b, -1);",
			"    for (int i = n; i < lim; i++)",
			"        b[i] = 0;",
			"    inte(b, ans, n);",
			"}",
			"void std::exp(int const* a, int* ans, int n)",
			"{",
			"    static int f[800010];",
			"    for (int i = 0; i < n << 1; i++)",
			"        ans[i] = f[i] = 0;",
			"    ans[0] = 1;",
			"    for (int m = 2; m <= n; m <<= 1) {",
			"        int lim = m << 1;",
			"        ln(ans, f, m);",
			"        f[0] = (a[0] + 1 - f[0] + mod) % mod;",
			"        for (int i = 1; i < m; i++)",
			"            f[i] = (a[i] - f[i] + mod) % mod;",
			"        ntt.getr(lim);",
			"        ntt(f, 1), ntt(ans, 1);",
			"        for (int i = 0; i < lim; i++)",
			"            ans[i] = 1ll * ans[i] * f[i] % mod, f[i] = 0;",
			"        ntt(ans, -1);",
			"        for (int i = m; i < lim; i++)",
			"            ans[i] = 0;",
			"    }",
			"}",
			"void solve1() { printf(\"%d\\n\", pow(m, n)); }",
			"void solve2()",
			"{",
			"    if (m < n)",
			"        puts(\"0\");",
			"    else",
			"        printf(\"%lld\\n\", 1ll * fac[m] * minv[m - n] % mod);",
			"}",
			"void solve3()",
			"{",
			"    if (n < m)",
			"        return puts(\"0\"), void();",
			"    int ans = 0;",
			"    for (int i = 0; i <= m; i++)",
			"        ans = (ans + 1ll * std::pow(mod - 1, i) * C(m, i) % mod * std::pow(m - i, n)) % mod;",
			"    printf(\"%d\\n\", ans);",
			"}",
			"int s[800010];",
			"void solve4()",
			"{",
			"    static int tmp[800010];",
			"    for (int i = 0; i <= n; i++)",
			"        tmp[i] = (i & 1 ? mod - 1ll : 1ll) * minv[i] % mod, s[i] = 1ll * std::pow(i, n) * minv[i] % mod;",
			"    int lim = 1;",
			"    for (lim = 1; lim <= n + n; lim <<= 1)",
			"        ;",
			"    ntt.getr(lim);",
			"    ntt(tmp, 1), ntt(s, 1);",
			"    for (int i = 0; i < lim; i++)",
			"        s[i] = 1ll * s[i] * tmp[i] % mod;",
			"    ntt(s, -1);",
			"    for (int i = n + 1; i < lim; i++)",
			"        s[i] = 0;",
			"    int ans = 0;",
			"    for (int i = 0; i <= m; i++)",
			"        ans = (ans + s[i]) % mod;",
			"    printf(\"%d\\n\", ans);",
			"}",
			"void solve5() { printf(\"%d\\n\", int(m >= n)); }",
			"void solve6() { printf(\"%d\\n\", s[m]); }",
			"void solve7() { printf(\"%d\\n\", C(n + m - 1, m - 1)); }",
			"void solve8() { printf(\"%d\\n\", C(m, n)); }",
			"void solve9() { printf(\"%d\\n\", C(n - 1, m - 1)); }",
			"int ans[800010];",
			"void solve10()",
			"{",
			"    static int tmp[800010];",
			"    for (int i = 1; i <= m; i++)",
			"        for (int j = 1; j * i <= n; j++)",
			"            ans[i * j] = (ans[i * j] - 1ll * minv[j] * fac[j - 1] % mod + mod) % mod;",
			"    int lim = 1;",
			"    for (; lim <= n; lim <<= 1)",
			"        ;",
			"",
			"    std::exp(ans, tmp, lim);",
			"    for (int i = 0; i < lim; i++)",
			"        ans[i] = 0;",
			"    inv(tmp, ans, lim);",
			"    printf(\"%d\\n\", ans[n]);",
			"}",
			"void solve11() { printf(\"%d\\n\", int(m >= n)); }",
			"void solve12()",
			"{",
			"    printf(\"%d\\n\", n - m >= 0 ? ans[n - m] : 0);",
			"}",
			"int main()",
			"{",
			"    scanf(\"%d%d\", &n, &m);",
			"    fac[0] = 1;",
			"    for (int i = 1; i <= n + m; i++)",
			"        fac[i] = 1ll * fac[i - 1] * i % mod;",
			"    minv[n + m] = std::pow(fac[n + m], mod - 2);",
			"    for (int i = n + m; i; i--)",
			"        minv[i - 1] = 1ll * minv[i] * i % mod;",
			"    solve1();",
			"    solve2();",
			"    solve3();",
			"    solve4();",
			"    solve5();",
			"    solve6();",
			"    solve7();",
			"    solve8();",
			"    solve9();",
			"    solve10();",
			"    solve11();",
			"    solve12();",
			"    return 0;",
			"}"
		],
		"description": "Ntt"
	},
	"code_6": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"int main(){",
			"    std::ios::std::sync_with_stdio(false);std::cin.std::tie(0);",
			"    LL n, m;",
			"    std::cin >> n >> m;",
			"    std::vector <LL> p(m);",
			"    for (int i = 0; i < m; i ++ )",
			"        std::cin >> p[i];",
			"    LL ans = 0;",
			"    for (int i = 1; i < (1 << m); i ++ ){",
			"        LL t = 1, cnt = 0;",
			"        for (int j = 0; j < m; j ++ ){",
			"            if (i >> j & 1){",
			"                cnt ++ ;",
			"                t *= p[j];",
			"                if (t > n){",
			"                    t = -1;",
			"                    break;",
			"                }",
			"            }",
			"        }",
			"        if (t != -1){",
			"            if (cnt & 1) ans += n / t;",
			"            else ans -= n / t;",
			"        }",
			"    }",
			"    cout << ans << \"\\n\";",
			"    return 0;",
			"}"
		],
		"description": "Code"
	},
	"code_7": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"int main(){",
			"    std::ios::std::sync_with_stdio(false);std::cin.std::tie(0);",
			"    LL n, m;",
			"    std::cin >> n >> m;",
			"    std::vector <LL> p(m);",
			"    for (int i = 0; i < m; i ++ )",
			"        std::cin >> p[i];",
			"    LL ans = 0;",
			"    function<void(LL, LL, LL)> dfs = [&](LL x, LL s, LL odd){",
			"        if (x == m){",
			"            if (s == 1) return;",
			"            ans += odd * (n / s);",
			"            return;",
			"        }",
			"        dfs(x + 1, s, odd);",
			"        if (s <= n / p[x]) dfs(x + 1, s * p[x], -odd);",
			"    };",
			"    dfs(0, 1, -1);",
			"    cout << ans << \"\\n\";",
			"    return 0;",
			"}"
		],
		"description": "Code"
	},
	"jie_cheng": {
		"scope": "cpp",
		"prefix": "jie_cheng",
		"body": [
			"int f[20];",
			"void jie_cheng(int n) { // 打出1-n的阶乘表",
			"    f[0] = f[1] = 1; // 0的阶乘为1",
			"    for (int i = 2; i <= n; i++) f[i] = f[i - 1] * i;",
			"}",
			"std::string str;",
			"int kangtuo() {",
			"    int ans = 1; // 注意，因为 12345 是算作0开始计算的，最后结果要把12345看作是第一个",
			"    int len = str.length();",
			"    for (int i = 0; i < len; i++) {",
			"        int tmp = 0; // 用来计数的",
			"        // 计算str[i]是第几大的数，或者说计算有几个比他小的数",
			"        for (int j = i + 1; j < len; j++)",
			"            if (str[i] > str[j]) tmp++;",
			"        ans += tmp * f[len - i - 1];",
			"    }",
			"    return ans;",
			"}",
			"int main() {",
			"    jie_cheng(10);",
			"    string str = \"52413\";",
			"    std::cout << kangtuo() << std::endl;",
			"}"
		],
		"description": "Jie Cheng"
	},
	"fwt": {
		"scope": "cpp",
		"prefix": "fwt",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define LL long long",
			"const int mod = 998244353, N = 1e6 + 10;",
			"LL fact[N];",
			"struct fwt{",
			"    LL n;",
			"    std::vector <LL> a;",
			"    fwt(LL n) : n(n), a(n + 1) {}",
			"    LL sum(LL x){",
			"        LL res = 0;",
			"        for (; x; x -= x & -x)",
			"            res += a[x];",
			"        return res;",
			"    }",
			"    void add(LL x, LL k){",
			"        for (; x <= n; x += x & -x)",
			"            a[x] += k;",
			"    }",
			"    LL query(LL x, LL y){",
			"        return sum(y) - sum(x - 1);",
			"    }",
			"};",
			"int main(){",
			"    std::ios::std::sync_with_stdio(false);std::cin.std::tie(0);",
			"    LL n;",
			"    std::cin >> n;",
			"    fwt a(n);",
			"    fact[0] = 1;",
			"    for (int i = 1; i <= n; i ++ ){",
			"        fact[i] = fact[i - 1] * i % mod;",
			"        a.add(i, 1);",
			"    }",
			"    LL ans = 0;",
			"    for (int i = 1; i <= n; i ++ ){",
			"        LL x;",
			"        std::cin >> x;",
			"        ans = (ans + a.query(1, x - 1) * fact[n - i] % mod ) % mod;",
			"        a.add(x, -1);",
			"    }",
			"    cout << (ans + 1) % mod << \"\\n\";",
			"    return 0;",
			"}"
		],
		"description": "Fwt"
	},
	"kangtuo": {
		"scope": "cpp",
		"prefix": "kangtuo",
		"body": [
			"std::string str;",
			"int kangtuo(){",
			"    int ans = 1;  //注意，因为 12345 是算作0开始计算的，最后结果要把12345看作是第一个",
			"    int len = str.length();",
			"    for(int i = 0; i < len; i++){",
			"        int tmp = 0;//用来计数的",
			"        for(int j = i + 1; j < len; j++){",
			"            if(str[i] > str[j]) tmp++;",
			"            //计算str[i]是第几大的数，或者说计算有几个比他小的数",
			"        }",
			"        ans += tmp * f[len - i - 1];",
			"    }",
			"    return ans;",
			"}",
			"int main(){",
			"    jie_cheng(10);",
			"    string str = \"52413\";",
			"    std::cout<<kangtuo()<<std::endl;",
			"}"
		],
		"description": "Kangtuo"
	}
}
