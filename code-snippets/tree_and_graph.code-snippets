{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"get_diam": {
		"scope": "cpp",
		"prefix": "get_diam",
		"body": [
			"using a3 = std::array<i64, 3>;",
			"",
			"std::vector<pii> adj[MAXN];",
			"",
			"i64 cur;",
			"int pos;",
			"void dfs(int x, int p, i64 d) {",
			"    if (d > cur) {",
			"        cur = d;",
			"        pos = x;",
			"    }",
			"    for (auto [nxt, dis] : adj[x])if (nxt != p) {",
			"        dfs(nxt, x, d + dis);",
			"    }",
			"}",
			"",
			"a3 get_diam() {",
			"    cur = 0, pos = 1;",
			"    dfs(pos, 0, cur);",
			"    int u = pos;",
			"    cur = 0;",
			"    dfs(pos, 0, cur);",
			"    int v = pos;",
			"    return { u,v,cur };",
			"}"
		],
		"description": "get_diam"
	},
	"lca": {
		"scope": "cpp",
		"prefix": "lca",
		"body": [
			"int depth[MAXN], lg[MAXN], p[MAXN][30];",
			"int lca(int x, int y) {",
			"    if (depth[x] < depth[y])swap(x, y);",
			"    while (depth[x] > depth[y])",
			"        x = p[x][lg[depth[x] - depth[y]] - 1];",
			"    if (x == y)return x;",
			"    for (int k = lg[depth[x]] - 1;k >= 0;--k)",
			"        if (p[x][k] != p[y][k])",
			"            x = p[x][k], y = p[y][k];",
			"    return p[x][0];",
			"}",
			"",
			"void dfs(int x, int par) {",
			"    p[x][0] = par;",
			"    depth[x] = depth[par] + 1;",
			"    for (int i = 1;i <= lg[depth[x]];++i)",
			"        p[x][i] = p[p[x][i - 1]][i - 1];",
			"",
			"    for (int nxt : adj[x])if (nxt != par)dfs(nxt, x);",
			"}",
			"",
			"void init() {",
			"    for (int i = 1;i <= n;++i)",
			"        lg[i] = lg[i >> 1] + 1;",
			"}",
			"",
			"int get_dis(int u, int v) {",
			"    int c = lca(u, v);",
			"    return depth[u] + depth[v] - depth[c] * 2;",
			"}"
		],
		"description": "lca"
	},
	"hpd_tree": {
		"scope": "cpp",
		"prefix": "hpd_tree",
		"body": [
			"struct HPD_tree",
			"{",
			"    int tree_size;",
			"    bool is_hpd_init = false;",
			"    std::vector<std::vector<std::pair<int, i64>>> adj;",
			"    std::vector<int> Fa, size, hson, top, rank, dfn, depth;",
			"    HPD_tree(int n = 0) {",
			"        tree_size = n;",
			"        adj.resize(tree_size + 1);",
			"    }",
			"    void add_edge(int u, int v, i64 w = 1) {",
			"        adj[u].push_back({ v,w });",
			"        adj[v].push_back({ u,w });",
			"    }",
			"    void HPD_init() {",
			"        is_hpd_init = true;",
			"        Fa.assign(tree_size + 1, 0);",
			"        size.assign(tree_size + 1, 0);",
			"        hson.assign(tree_size + 1, 0);",
			"        top.assign(tree_size + 1, 0);",
			"        rank.assign(tree_size + 1, 0);",
			"        dfn.assign(tree_size + 1, 0);",
			"        depth.assign(tree_size + 1, 0);",
			"        std::function<void(int, int, int)> dfs1 = [&](int u, int p, int d)->void {",
			"            hson[u] = 0;",
			"            size[hson[u]] = 0;",
			"            size[u] = 1;",
			"            depth[u] = d;",
			"            for (auto [v, w] : adj[u])if (v != p) {",
			"                dfs1(v, u, d + 1);",
			"                size[u] += size[v];",
			"                Fa[v] = u;",
			"                if (size[v] > size[hson[u]]) {",
			"                    hson[u] = v;",
			"                }",
			"            }",
			"            };",
			"        dfs1(1, 0, 0);",
			"        int tot = 0;",
			"        std::function<void(int, int, int)> dfs2 = [&](int u, int p, int t)->void {",
			"            top[u] = t;",
			"            dfn[u] = ++tot;",
			"            rank[tot] = u;",
			"            if (hson[u]) {",
			"                dfs2(hson[u], u, t);",
			"                for (auto [v, w] : adj[u])if (v != p && v != hson[u]) {",
			"                    dfs2(v, u, v);",
			"                }",
			"            }",
			"            };",
			"        dfs2(1, 0, 1);",
			"    }",
			"    int lca(int u, int v) {",
			"        if (!is_hpd_init)HPD_init();",
			"        while (top[u] != top[v]) {",
			"            if (depth[top[u]] > depth[top[v]])",
			"                u = Fa[top[u]];",
			"            else",
			"                v = Fa[top[v]];",
			"        }",
			"        return depth[u] > depth[v] ? v : u;",
			"    }",
			"    i64 dist(int u, int v) {",
			"        int w = lca(u, v);",
			"        return depth[u] - depth[w] + depth[v] - depth[w] + 1;",
			"    }",
			"    a3 get_diam() {",
			"        i64 cur; int pos;",
			"        std::function<void(int, int, i64)> dfs = [&](int u, int p, i64 d) {",
			"            if (d > cur) {",
			"                cur = d;",
			"                pos = u;",
			"            }",
			"            for (auto [v, dis] : adj[u])if (v != p) {",
			"                dfs(v, u, d + dis);",
			"            }",
			"            };",
			"        cur = 0, pos = 1;",
			"        dfs(pos, 0, cur);",
			"        int u = pos;",
			"        cur = 0;",
			"        dfs(pos, 0, cur);",
			"        int v = pos;",
			"        return { u,v,cur };",
			"    }",
			"};"
		],
		"description": "hpd_tree"
	},
	"scc": {
		"scope": "cpp",
		"prefix": "scc",
		"body": [
			"struct SCC {",
			"    int n;",
			"    std::vector<std::vector<int>> adj;",
			"    std::vector<int> stk;",
			"    std::vector<int> dfn, low, bel;",
			"    int cur, cnt;",
			"    ",
			"    SCC() {}",
			"    SCC(int n) {",
			"        init(n);",
			"    }",
			"    ",
			"    void init(int n) {",
			"        this->n = n;",
			"        adj.assign(n, {});",
			"        dfn.assign(n, -1);",
			"        low.resize(n);",
			"        bel.assign(n, -1);",
			"        stk.clear();",
			"        cur = cnt = 0;",
			"    }",
			"    ",
			"    void addEdge(int u, int v) {",
			"        adj[u].push_back(v);",
			"    }",
			"    ",
			"    void dfs(int x) {",
			"        dfn[x] = low[x] = cur++;",
			"        stk.push_back(x);",
			"        ",
			"        for (auto y : adj[x]) {",
			"            if (dfn[y] == -1) {",
			"                dfs(y);",
			"                low[x] = std::min(low[x], low[y]);",
			"            } else if (bel[y] == -1) {",
			"                low[x] = std::min(low[x], dfn[y]);",
			"            }",
			"        }",
			"        ",
			"        if (dfn[x] == low[x]) {",
			"            int y;",
			"            do {",
			"                y = stk.back();",
			"                bel[y] = cnt;",
			"                stk.pop_back();",
			"            } while (y != x);",
			"            cnt++;",
			"        }",
			"    }",
			"    ",
			"    std::vector<int> work() {",
			"        for (int i = 0; i < n; i++) {",
			"            if (dfn[i] == -1) {",
			"                dfs(i);",
			"            }",
			"        }",
			"        return bel;",
			"    }",
			"};",
			""
		],
		"description": "scc"
	},
	"ebcc": {
		"scope": "cpp",
		"prefix": "ebcc",
		"body": [
			"std::set<std::pair<int, int>> E;",
			"",
			"struct EBCC {",
			"    int n;",
			"    std::vector<std::vector<int>> adj;",
			"    std::vector<int> stk;",
			"    std::vector<int> dfn, low, bel;",
			"    int cur, cnt;",
			"    ",
			"    EBCC() {}",
			"    EBCC(int n) {",
			"        init(n);",
			"    }",
			"    ",
			"    void init(int n) {",
			"        this->n = n;",
			"        adj.assign(n, {});",
			"        dfn.assign(n, -1);",
			"        low.resize(n);",
			"        bel.assign(n, -1);",
			"        stk.clear();",
			"        cur = cnt = 0;",
			"    }",
			"    ",
			"    void addEdge(int u, int v) {",
			"        adj[u].push_back(v);",
			"        adj[v].push_back(u);",
			"    }",
			"    ",
			"    void dfs(int x, int p) {",
			"        dfn[x] = low[x] = cur++;",
			"        stk.push_back(x);",
			"        ",
			"        for (auto y : adj[x]) {",
			"            if (y == p) {",
			"                continue;",
			"            }",
			"            if (dfn[y] == -1) {",
			"                E.emplace(x, y);",
			"                dfs(y, x);",
			"                low[x] = std::min(low[x], low[y]);",
			"            } else if (bel[y] == -1 && dfn[y] < dfn[x]) {",
			"                E.emplace(x, y);",
			"                low[x] = std::min(low[x], dfn[y]);",
			"            }",
			"        }",
			"        ",
			"        if (dfn[x] == low[x]) {",
			"            int y;",
			"            do {",
			"                y = stk.back();",
			"                bel[y] = cnt;",
			"                stk.pop_back();",
			"            } while (y != x);",
			"            cnt++;",
			"        }",
			"    }",
			"    ",
			"    std::vector<int> work() {",
			"        dfs(0, -1);",
			"        return bel;",
			"    }",
			"    ",
			"    struct Graph {",
			"        int n;",
			"        std::vector<std::pair<int, int>> edges;",
			"        std::vector<int> siz;",
			"        std::vector<int> cnte;",
			"    };",
			"    Graph compress() {",
			"        Graph g;",
			"        g.n = cnt;",
			"        g.siz.resize(cnt);",
			"        g.cnte.resize(cnt);",
			"        for (int i = 0; i < n; i++) {",
			"            g.siz[bel[i]]++;",
			"            for (auto j : adj[i]) {",
			"                if (bel[i] < bel[j]) {",
			"                    g.edges.emplace_back(bel[i], bel[j]);",
			"                } else if (i < j) {",
			"                    g.cnte[bel[i]]++;",
			"                }",
			"            }",
			"        }",
			"        return g;",
			"    }",
			"};"
		],
		"description": "ebcc"
	},
	"maxflow": {
		"scope": "cpp",
		"prefix": "maxflow",
		"body": [
			"constexpr int inf = 1E9;",
			"template<class T>",
			"struct MaxFlow {",
			"    struct _Edge {",
			"        int to;",
			"        T cap;",
			"        _Edge(int to, T cap) : to(to), cap(cap) {}",
			"    };",
			"    ",
			"    int n;",
			"    std::vector<_Edge> e;",
			"    std::vector<std::vector<int>> g;",
			"    std::vector<int> cur, h;",
			"    ",
			"    MaxFlow() {}",
			"    MaxFlow(int n) {",
			"        init(n);",
			"    }",
			"    ",
			"    void init(int n) {",
			"        this->n = n;",
			"        e.clear();",
			"        g.assign(n, {});",
			"        cur.resize(n);",
			"        h.resize(n);",
			"    }",
			"    ",
			"    bool bfs(int s, int t) {",
			"        h.assign(n, -1);",
			"        std::queue<int> que;",
			"        h[s] = 0;",
			"        que.push(s);",
			"        while (!que.empty()) {",
			"            const int u = que.front();",
			"            que.pop();",
			"            for (int i : g[u]) {",
			"                auto [v, c] = e[i];",
			"                if (c > 0 && h[v] == -1) {",
			"                    h[v] = h[u] + 1;",
			"                    if (v == t) {",
			"                        return true;",
			"                    }",
			"                    que.push(v);",
			"                }",
			"            }",
			"        }",
			"        return false;",
			"    }",
			"    ",
			"    T dfs(int u, int t, T f) {",
			"        if (u == t) {",
			"            return f;",
			"        }",
			"        auto r = f;",
			"        for (int &i = cur[u]; i < int(g[u].size()); ++i) {",
			"            const int j = g[u][i];",
			"            auto [v, c] = e[j];",
			"            if (c > 0 && h[v] == h[u] + 1) {",
			"                auto a = dfs(v, t, std::min(r, c));",
			"                e[j].cap -= a;",
			"                e[j ^ 1].cap += a;",
			"                r -= a;",
			"                if (r == 0) {",
			"                    return f;",
			"                }",
			"            }",
			"        }",
			"        return f - r;",
			"    }",
			"    void addEdge(int u, int v, T c) {",
			"        g[u].push_back(e.size());",
			"        e.emplace_back(v, c);",
			"        g[v].push_back(e.size());",
			"        e.emplace_back(u, 0);",
			"    }",
			"    T flow(int s, int t) {",
			"        T ans = 0;",
			"        while (bfs(s, t)) {",
			"            cur.assign(n, 0);",
			"            ans += dfs(s, t, std::numeric_limits<T>::max());",
			"        }",
			"        return ans;",
			"    }",
			"    ",
			"    std::vector<bool> minCut() {",
			"        std::vector<bool> c(n);",
			"        for (int i = 0; i < n; i++) {",
			"            c[i] = (h[i] != -1);",
			"        }",
			"        return c;",
			"    }",
			"    ",
			"    struct Edge {",
			"        int from;",
			"        int to;",
			"        T cap;",
			"        T flow;",
			"    };",
			"    std::vector<Edge> edges() {",
			"        std::vector<Edge> a;",
			"        for (int i = 0; i < e.size(); i += 2) {",
			"            Edge x;",
			"            x.from = e[i + 1].to;",
			"            x.to = e[i].to;",
			"            x.cap = e[i].cap + e[i + 1].cap;",
			"            x.flow = e[i + 1].cap;",
			"            a.push_back(x);",
			"        }",
			"        return a;",
			"    }",
			"};"
		],
		"description": "maxflow"
	},
	"bf": {
		"scope": "cpp",
		"prefix": "bf",
		"body": [
			"const int N = 550, M = 1e5 + 7;",
			"int n, m, k;",
			"struct node { int x, y, w; } ver[M];",
			"int d[N], backup[N];",
			"",
			"void bf() {",
			"    std::memset(d, 0x3f, sizeof d); d[1] = 0;",
			"    for (int i = 1; i <= k; ++ i) {",
			"        std::memcpy(backup, d, sizeof d);",
			"        for (int j = 1; j <= m; ++ j) {",
			"            int x = ver[j].x, y = ver[j].y, w = ver[j].w;",
			"            d[y] = std::min(d[y], backup[x] + w);",
			"        }",
			"    }",
			"}",
			"int main() {",
			"    std::cin >> n >> m >> k;",
			"    for (int i = 1; i <= m; ++ i) {",
			"        int x, y, w; std::cin >> x >> y >> w;",
			"        ver[i] = {x, y, w};",
			"    }",
			"    bf();",
			"    for (int i = 1; i <= n; ++ i) {",
			"        if (d[i] > INF / 2) cout << \"N\" << endl;",
			"        else std::cout << d[n] << std::endl;",
			"    }",
			"}"
		],
		"description": "Bf"
	},
	"add": {
		"scope": "cpp",
		"prefix": "add",
		"body": [
			"const int N = 1e5 + 7, M = 1e6 + 7;",
			"int n, m;",
			"int ver[M], ne[M], h[N], edge[M], tot;",
			"int d[N], v[N];",
			"",
			"void add(int x, int y, int w) {",
			"    ver[++ tot] = y, ne[tot] = h[x], h[x] = tot;",
			"    edge[tot] = w;",
			"}",
			"void spfa() {",
			"    ms(d, 0x3f); d[1] = 0;",
			"    std::queue<int> q; q.push(1);",
			"    v[1] = 1;",
			"    while(!q.empty()) {",
			"        int x = q.front(); q.pop(); v[x] = 0;",
			"        for (int i = h[x]; i; i = ne[i]) {",
			"            int y = ver[i];",
			"            if(d[y] > d[x] + edge[i]) {",
			"                d[y] = d[x] + edge[i];",
			"                if(v[y] == 0) q.push(y), v[y] = 1;",
			"            }",
			"        }",
			"    }",
			"}",
			"int main() {",
			"    std::cin >> n >> m;",
			"    for (int i = 1; i <= m; ++ i) {",
			"        int x, y, w; std::cin >> x >> y >> w;",
			"        add(x, y, w);",
			"    }",
			"    spfa();",
			"    for (int i = 1; i <= n; ++ i) {",
			"        if (d[i] == INF) cout << \"N\" << endl;",
			"        else std::cout << d[n] << std::endl;",
			"    }",
			"}"
		],
		"description": "Add"
	},
	"floyd": {
		"scope": "cpp",
		"prefix": "floyd",
		"body": [
			"void floyd() {",
			"    for (int k = 1; k <= n; k ++)",
			"        for (int i = 1; i <= n; i ++)",
			"            for (int j = 1; j <= n; j ++)",
			"                d[i][j] = std::min(d[i][j], d[i][k] + d[k][j]);",
			"}"
		],
		"description": "Floyd"
	},
	"for": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"for (int i = 1; i <= n + 1; i++) {",
			"    for (int j = 1, w; j <= n; j++) {",
			"        std::cin >> w;",
			"        int pre = Hash(i - 1, j), now = Hash(i, j);",
			"        if (i == 1) {",
			"            add(s, now, w);",
			"        } else if (i == n + 1) {",
			"            add(pre, t, w);",
			"        } else {",
			"            add(pre, now, w);",
			"        }",
			"        // flow.add(Hash(i, j), Hash(i, j + 1), w);",
			"    }",
			"}",
			"for (int i = 1; i <= n; i++) {",
			"    for (int j = 1, w; j <= n + 1; j++) {",
			"        std::cin >> w;",
			"        int now = Hash(i, j), net = Hash(i, j - 1);",
			"        if (j == 1) {",
			"            add(now, t, w);",
			"        } else if (j == n + 1) {",
			"            add(s, net, w);",
			"        } else {",
			"            add(now, net, w);",
			"        }",
			"        // flow.add(Hash(i, j), Hash(i + 1, j), w);",
			"    }",
			"}",
			"for (int i = 1; i <= n + 1; i++) {",
			"    for (int j = 1, w; j <= n; j++) {",
			"        std::cin >> w;",
			"        int now = Hash(i, j), net = Hash(i - 1, j);",
			"        if (i == 1) {",
			"            add(now, s, w);",
			"        } else if (i == n + 1) {",
			"            add(t, net, w);",
			"        } else {",
			"            add(now, net, w);",
			"        }",
			"        // flow.add(Hash(i, j), Hash(i, j - 1), w);",
			"    }",
			"}",
			"for (int i = 1; i <= n; i++) {",
			"    for (int j = 1, w; j <= n + 1; j++) {",
			"        std::cin >> w;",
			"        int pre = Hash(i, j - 1), now = Hash(i, j);",
			"        if (j == 1) {",
			"            add(t, now, w);",
			"        } else if (j == n + 1) {",
			"            add(pre, s, w);",
			"        } else {",
			"            add(pre, now, w);",
			"        }",
			"        // flow.add(Hash(i, j), Hash(i - 1, j), w);",
			"    }",
			"}"
		],
		"description": "For"
	},
	"prim": {
		"scope": "cpp",
		"prefix": "prim",
		"body": [
			"const int N = 550, INF = 0x3f3f3f3f;",
			"int n, m, g[N][N];",
			"int d[N], v[N];",
			"int prim() {",
			"    ms(d, 0x3f); //这里的d表示到“最小生成树集合”的距离",
			"    int ans = 0;",
			"    for (int i = 0; i < n; ++ i) { //遍历 n 轮",
			"        int t = -1;",
			"        for (int j = 1; j <= n; ++ j)",
			"            if (v[j] == 0 && (t == -1 || d[j] < d[t])) //如果这个点不在集合内且当前距离集合最近",
			"                t = j;",
			"        v[t] = 1; //将t加入“最小生成树集合”",
			"        if (i && d[t] == INF) return INF; //如果发现不连通，直接返回",
			"        if (i) ans += d[t];",
			"        for (int j = 1; j <= n; ++ j) d[j] = std::min(d[j], g[t][j]); //用t更新其他点到集合的距离",
			"    }",
			"    return ans;",
			"}",
			"int main() {",
			"    ms(g, 0x3f); std::cin >> n >> m;",
			"    while (m -- ) {",
			"        int x, y, w; std::cin >> x >> y >> w;",
			"        g[x][y] = g[y][x] = std::min(g[x][y], w);",
			"    }",
			"    int t = prim();",
			"    if (t == INF) cout << \"impossible\" << endl;",
			"    else std::cout << t << std::endl;",
			"} //22.03.19已测试"
		],
		"description": "Prim"
	},
	"dsu": {
		"scope": "cpp",
		"prefix": "dsu",
		"body": [
			"struct DSU {",
			"    std::vector<int> fa;",
			"    DSU(int n) : fa(n + 1) {",
			"        std::iota(fa.begin(), fa.end(), 0);",
			"    }",
			"    int get(int x) {",
			"        while (x != fa[x]) {",
			"            x = fa[x] = fa[fa[x]];",
			"        }",
			"        return x;",
			"    }",
			"    bool merge(int x, int y) { // 设x是y的祖先",
			"        x = get(x), y = get(y);",
			"        if (x == y) return false;",
			"        fa[y] = x;",
			"        return true;",
			"    }",
			"    bool same(int x, int y) {",
			"        return get(x) == get(y);",
			"    }",
			"};",
			"struct Tree {",
			"    using TII = std::tuple<int, int, int>;",
			"    int n;",
			"    std::priority_queue<TII, std::vector<TII>, greater<TII>> ver;",
			"",
			"    Tree(int n) {",
			"        this->n = n;",
			"    }",
			"    void add(int x, int y, int w) {",
			"        ver.emplace(w, x, y); // 注意顺序",
			"    }",
			"    int kruskal() {",
			"        DSU dsu(n);",
			"        int ans = 0, cnt = 0;",
			"        while (ver.size()) {",
			"            auto [w, x, y] = ver.top();",
			"            ver.pop();",
			"            if (dsu.same(x, y)) continue;",
			"            dsu.merge(x, y);",
			"            ans += w;",
			"            cnt++;",
			"        }",
			"        assert(cnt < n - 1); // 输入有误，建树失败",
			"        return ans;",
			"    }",
			"};"
		],
		"description": "Dsu"
	},
	"scc_1": {
		"scope": "cpp",
		"prefix": "scc",
		"body": [
			"struct SCC {",
			"    int n, now, cnt;",
			"    std::vector<std::vector<int>> ver;",
			"    std::vector<int> dfn, low, col, S;",
			"",
			"    SCC(int n) : n(n), ver(n + 1), low(n + 1) {",
			"        dfn.resize(n + 1, -1);",
			"        col.resize(n + 1, -1);",
			"        now = cnt = 0;",
			"    }",
			"    void add(int x, int y) {",
			"        ver[x].push_back(y);",
			"    }",
			"    void tarjan(int x) {",
			"        dfn[x] = low[x] = now++;",
			"        S.push_back(x);",
			"        for (auto y : ver[x]) {",
			"            if (dfn[y] == -1) {",
			"                tarjan(y);",
			"                low[x] = std::min(low[x], low[y]);",
			"            } else if (col[y] == -1) {",
			"                low[x] = std::min(low[x], dfn[y]);",
			"            }",
			"        }",
			"        if (dfn[x] == low[x]) {",
			"            int pre;",
			"            cnt++;",
			"            do {",
			"                pre = S.back();",
			"                col[pre] = cnt;",
			"                S.pop_back();",
			"            } while (pre != x);",
			"        }",
			"    }",
			"    auto work() { // [cnt 新图的顶点数量]",
			"        for (int i = 1; i <= n; i++) { // 避免图不连通",
			"            if (dfn[i] == -1) {",
			"                tarjan(i);",
			"            }",
			"        }",
			"",
			"        std::vector<int> siz(cnt + 1); // siz 每个 scc 中点的数量",
			"        std::vector<std::vector<int>> adj(cnt + 1);",
			"        for (int i = 1; i <= n; i++) {",
			"            siz[col[i]]++;",
			"            for (auto j : ver[i]) {",
			"                int x = col[i], y = col[j];",
			"                if (x != y) {",
			"                    adj[x].push_back(y);",
			"                }",
			"            }",
			"        }",
			"        return {cnt, adj, col, siz};",
			"    }",
			"};"
		],
		"description": "Scc"
	},
	"edcc": {
		"scope": "cpp",
		"prefix": "edcc",
		"body": [
			"struct EDCC {",
			"    int n, m, now, cnt;",
			"    std::vector<std::vector<std::array<int, 2>>> ver;",
			"    std::vector<int> dfn, low, col, S;",
			"    std::set<std::array<int, 2>> bridge, direct; // 如果不需要，删除这一部分可以得到一些时间上的优化",
			"",
			"    EDCC(int n) : n(n), low(n + 1), ver(n + 1), dfn(n + 1), col(n + 1) {",
			"        m = now = cnt = 0;",
			"    }",
			"    void add(int x, int y) { // 和 scc 相比多了一条连边",
			"        ver[x].push_back({y, m});",
			"        ver[y].push_back({x, m++});",
			"    }",
			"    void tarjan(int x, int fa) {",
			"        dfn[x] = low[x] = ++now;",
			"        S.push_back(x);",
			"        for (auto &[y, id] : ver[x]) {",
			"            if (!dfn[y]) {",
			"                direct.insert({x, y});",
			"                tarjan(y, id);",
			"                low[x] = std::min(low[x], low[y]);",
			"                if (dfn[x] < low[y]) {",
			"                    bridge.insert({x, y});",
			"                }",
			"            } else if (id != fa && dfn[y] < dfn[x]) {",
			"                direct.insert({x, y});",
			"                low[x] = std::min(low[x], dfn[y]);",
			"            }",
			"        }",
			"        if (dfn[x] == low[x]) {",
			"            int pre;",
			"            cnt++;",
			"            do {",
			"                pre = S.back();",
			"                col[pre] = cnt;",
			"                S.pop_back();",
			"            } while (pre != x);",
			"        }",
			"    }",
			"    auto work() {",
			"        for (int i = 1; i <= n; i++) { // 避免图不连通",
			"            if (!dfn[i]) {",
			"                tarjan(i, 0);",
			"            }",
			"        }",
			"        /**",
			"         * @param cnt 新图的顶点数量, adj 新图, col 旧图节点对应的新图节点",
			"         * @param siz 旧图每一个边双中点的数量",
			"         * @param bridge 全部割边, direct 非割边定向",
			"         */",
			"        std::vector<int> siz(cnt + 1);",
			"        std::vector<std::vector<int>> adj(cnt + 1);",
			"        for (int i = 1; i <= n; i++) {",
			"            siz[col[i]]++;",
			"            for (auto &[j, id] : ver[i]) {",
			"                int x = col[i], y = col[j];",
			"                if (x != y) {",
			"                    adj[x].push_back(y);",
			"                }",
			"            }",
			"        }",
			"        return std::tuple{cnt, adj, col, siz};",
			"    }",
			"};"
		],
		"description": "Edcc"
	},
	"v_dcc": {
		"scope": "cpp",
		"prefix": "v_dcc",
		"body": [
			"struct V_DCC {",
			"    int n;",
			"    std::vector<std::vector<int>> ver, col;",
			"    std::vector<int> dfn, low, S;",
			"    int now, cnt;",
			"    std::vector<bool> point; // 记录是否为割点",
			"",
			"    V_DCC(int n) : n(n) {",
			"        ver.resize(n + 1);",
			"        dfn.resize(n + 1);",
			"        low.resize(n + 1);",
			"        col.resize(2 * n + 1);",
			"        point.resize(n + 1);",
			"        S.clear();",
			"        cnt = now = 0;",
			"    }",
			"    void add(int x, int y) {",
			"        if (x == y) return; // 手动去除重边",
			"        ver[x].push_back(y);",
			"        ver[y].push_back(x);",
			"    }",
			"    void tarjan(int x, int root) {",
			"        low[x] = dfn[x] = ++now;",
			"        S.push_back(x);",
			"        if (x == root && !ver[x].size()) { // 特判孤立点",
			"            ++cnt;",
			"            col[cnt].push_back(x);",
			"            return;",
			"        }",
			"",
			"        int flag = 0;",
			"        for (auto y : ver[x]) {",
			"            if (!dfn[y]) {",
			"                tarjan(y, root);",
			"                low[x] = std::min(low[x], low[y]);",
			"                if (dfn[x] <= low[y]) {",
			"                    flag++;",
			"                    if (x != root || flag > 1) {",
			"                        point[x] = true; // 标记为割点",
			"                    }",
			"                    int pre = 0;",
			"                    cnt++;",
			"                    do {",
			"                        pre = S.back();",
			"                        col[cnt].push_back(pre);",
			"                        S.pop_back();",
			"                    } while (pre != y);",
			"                    col[cnt].push_back(x);",
			"                }",
			"            } else {",
			"                low[x] = std::min(low[x], dfn[y]);",
			"            }",
			"        }",
			"    }",
			"    std::pair<int, std::vector<std::vector<int>>> rebuild() { // [新图的顶点数量, 新图]",
			"        work();",
			"        std::vector<std::vector<int>> adj(cnt + 1);",
			"        for (int i = 1; i <= cnt; i++) {",
			"            if (!col[i].size()) { // 注意，孤立点也是 V-DCC",
			"                continue;",
			"            }",
			"            for (auto j : col[i]) {",
			"                if (point[j]) { // 如果 j 是割点",
			"                    adj[i].push_back(point[j]);",
			"                    adj[point[j]].push_back(i);",
			"                }",
			"            }",
			"        }",
			"        return {cnt, adj};",
			"    }",
			"    void work() {",
			"        for (int i = 1; i <= n; ++i) { // 避免图不连通",
			"            if (!dfn[i]) {",
			"                tarjan(i, i);",
			"            }",
			"        }",
			"    }",
			"};"
		],
		"description": "V Dcc"
	},
	"graph": {
		"scope": "cpp",
		"prefix": "graph",
		"body": [
			"namespace Graph {",
			"    const int N = 1e5 + 7;",
			"    const int M = 1e6 + 7;",
			"    int tot, h[N], ver[M], ne[M];",
			"    int deg[N], vis[M];",
			"",
			"    void clear(int n) {",
			"        tot = 0; //多组样例清空",
			"        for (int i = 1; i <= n; ++i) {",
			"            h[i] = 0;",
			"            deg[i] = vis[i] = 0;",
			"        }",
			"    }",
			"    void add(int x, int y) {",
			"        ver[++tot] = y, ne[tot] = h[x], h[x] = tot;",
			"        ++deg[y];",
			"    }",
			"    void dfs(int x) {",
			"        a.push_back(x); // DFS序",
			"        siz[x] = vis[x] = 1;",
			"        for (int i = h[x]; i; i = ne[i]) {",
			"            int y = ver[i];",
			"            if (vis[y]) continue;",
			"            dis[y] = dis[x] + 1;",
			"            dfs(y);",
			"            siz[x] += siz[y];",
			"        }",
			"        a.push_back(x);",
			"    }",
			"    void bfs(int s) {",
			"        std::queue<int> q;",
			"        q.push(s);",
			"        dis[s] = 1;",
			"        while (!q.empty()) {",
			"            int x = q.front();",
			"            q.pop();",
			"            for (int i = h[x]; i; i = ne[i]) {",
			"                int y = ver[i];",
			"                if (dis[y]) continue;",
			"                d[y] = d[x] + 1;",
			"                q.push(y);",
			"            }",
			"        }",
			"    }",
			"    bool topsort() {",
			"        std::queue<int> q;",
			"        std::vector<int> ans;",
			"        for (int i = 1; i <= n; ++i)",
			"            if (deg[i] == 0) q.push(i);",
			"        while (!q.empty()) {",
			"            int x = q.front();",
			"            q.pop();",
			"            ans.push_back(x);",
			"            for (int i = h[x]; i; i = ne[i]) {",
			"                int y = ver[i];",
			"                --deg[y];",
			"                if (deg[y] == 0) q.push(y);",
			"            }",
			"        }",
			"        return ans.size() == n; //判断是否存在拓扑排序",
			"    }",
			"} // namespace Graph"
		],
		"description": "Graph"
	},
	"graph_1": {
		"scope": "cpp",
		"prefix": "graph",
		"body": [
			"struct Graph {",
			"    int n;",
			"    std::vector<std::vector<int>> e;",
			"    Graph(int n) : n(n), e(n) {}",
			"    void add(int u, int v) {",
			"        e[u].push_back(v);",
			"        e[v].push_back(u);",
			"    }",
			"    std::pair<int, std::vector<int>> work() {",
			"        std::vector<int> match(n, -1), vis(n), link(n), f(n), dep(n);",
			"        auto std::find = [&](int u) {",
			"            while (f[u] != u) u = f[u] = f[f[u]];",
			"            return u;",
			"        };",
			"        auto lca = [&](int u, int v) {",
			"            u = std::find(u), v = std::find(v);",
			"            while (u != v) {",
			"                if (dep[u] < dep[v]) std::swap(u, v);",
			"                u = std::find(link[match[u]]);",
			"            }",
			"            return u;",
			"        };",
			"        std::queue<int> q;",
			"        auto blossom = [&](int u, int v, int p) {",
			"            while (std::find(u) != p) {",
			"                link[u] = v;",
			"                v = match[u];",
			"                if (vis[v] == 0) {",
			"                    vis[v] = 1;",
			"                    q.push(v);",
			"                }",
			"                f[u] = f[v] = p;",
			"                u = link[v];",
			"            }",
			"        };",
			"        auto augment = [&](int u) {",
			"            while (!q.empty()) q.pop();",
			"            std::iota(f.begin(), f.end(), 0);",
			"            std::fill(vis.begin(), vis.end(), -1);",
			"            q.push(u);",
			"            vis[u] = 1;",
			"            dep[u] = 0;",
			"            while (!q.empty()) {",
			"                int u = q.front();",
			"                q.pop();",
			"                for (auto v : e[u]) {",
			"                    if (vis[v] == -1) {",
			"                        vis[v] = 0;",
			"                        link[v] = u;",
			"                        dep[v] = dep[u] + 1;",
			"                        if (match[v] == -1) {",
			"                            for (int x = v, y = u, temp; y != -1;",
			"                                 x = temp, y = x == -1 ? -1 : link[x]) {",
			"                                temp = match[y];",
			"                                match[x] = y;",
			"                                match[y] = x;",
			"                            }",
			"                            return;",
			"                        }",
			"                        vis[match[v]] = 1;",
			"                        dep[match[v]] = dep[u] + 2;",
			"                        q.push(match[v]);",
			"                    } else if (vis[v] == 1 && std::find(v) != std::find(u)) {",
			"                        int p = lca(u, v);",
			"                        blossom(u, v, p);",
			"                        blossom(v, u, p);",
			"                    }",
			"                }",
			"            }",
			"        };",
			"        auto greedy = [&]() {",
			"            for (int u = 0; u < n; ++u) {",
			"                if (match[u] != -1) continue;",
			"                for (auto v : e[u]) {",
			"                    if (match[v] == -1) {",
			"                        match[u] = v;",
			"                        match[v] = u;",
			"                        break;",
			"                    }",
			"                }",
			"            }",
			"        };",
			"        greedy();",
			"        for (int u = 0; u < n; u++) {",
			"            if (match[u] == -1) {",
			"                augment(u);",
			"            }",
			"        }",
			"        int ans = 0;",
			"        for (int u = 0; u < n; u++) {",
			"            if (match[u] != -1) {",
			"                ans++;",
			"            }",
			"        }",
			"        return {ans / 2, match};",
			"    }",
			"};",
			"",
			"signed main() {",
			"    int n, m;",
			"    std::cin >> n >> m;",
			"",
			"    Graph graph(n);",
			"    for (int i = 1; i <= m; i++) {",
			"        int x, y;",
			"        std::cin >> x >> y;",
			"        graph.add(x - 1, y - 1);",
			"    }",
			"    auto [ans, match] = graph.work();",
			"    std::cout << ans << std::endl;",
			"    for (auto it : match) {",
			"        cout << it + 1 << \" \";",
			"    }",
			"}"
		],
		"description": "Graph"
	},
	"q": {
		"scope": "cpp",
		"prefix": "q",
		"body": [
			"namespace Graph {",
			"    const int N = 403 * 2; //两倍点数",
			"    typedef int T; //权值大小",
			"    const T inf = numeric_limits<int>::std::max() >> 1;",
			"    struct Q { int u, v; T w; } e[N][N];",
			"    T lab[N];",
			"    int n, m = 0, id, h, t, lk[N], sl[N], st[N], f[N], b[N][N], s[N], ed[N], q[N];",
			"    std::vector<int> p[N];",
			"#define dvd(x) (lab[x.u] + lab[x.v] - e[x.u][x.v].w * 2)",
			"#define FOR(i, b) for (int i = 1; i <= (int)(b); i++)",
			"#define ALL(x) (x).begin(), (x).end()",
			"#define ms(x, i) std::memset(x + 1, i, m * sizeof x[0])",
			"    void upd(int u, int v) {",
			"        if (!sl[v] || dvd(e[u][v]) < dvd(e[sl[v]][v])) {",
			"            sl[v] = u;",
			"        }",
			"    }",
			"    void ss(int v) {",
			"        sl[v] = 0;",
			"        FOR(u, n) {",
			"            if (e[u][v].w > 0 && st[u] != v && !s[st[u]]) {",
			"                upd(u, v);",
			"            }",
			"        }",
			"    }",
			"    void ins(int u) {",
			"        if (u <= n) { q[++t] = u; }",
			"        else {",
			"            for (int v : p[u]) ins(v);",
			"        }",
			"    }",
			"    void mdf(int u, int w) {",
			"        st[u] = w;",
			"        if (u > n) {",
			"            for (int v : p[u]) mdf(v, w);",
			"        }",
			"    }",
			"    int gr(int u, int v) {",
			"        v = std::find(ALL(p[u]), v) - p[u].begin();",
			"        if (v & 1) {",
			"            std::reverse(1 + ALL(p[u]));",
			"            return (int)p[u].size() - v;",
			"        }",
			"        return v;",
			"    }",
			"    void stm(int u, int v) {",
			"        lk[u] = e[u][v].v;",
			"        if (u <= n) return;",
			"        Q w = e[u][v];",
			"        int x = b[u][w.u], y = gr(u, x);",
			"        for (int i = 0; i < y; i++) {",
			"            stm(p[u][i], p[u][i ^ 1]);",
			"        }",
			"        stm(x, v);",
			"        rotate(p[u].begin(), y + ALL(p[u]));",
			"    }",
			"    void aug(int u, int v) {",
			"        int w = st[lk[u]];",
			"        stm(u, v);",
			"        if (!w) return;",
			"        stm(w, st[f[w]]), aug(st[f[w]], w);",
			"    }",
			"    int lca(int u, int v) {",
			"        for (++id; u | v; std::swap(u, v)) {",
			"            if (!u) continue;",
			"            if (ed[u] == id) return u;",
			"            ed[u] = id;",
			"            if (u = st[lk[u]]) u = st[f[u]];",
			"        }",
			"        return 0;",
			"    }",
			"    void add(int u, int a, int v) {",
			"        int x = n + 1, i, j;",
			"        while (x <= m && st[x]) ++x;",
			"        if (x > m) ++m;",
			"        lab[x] = s[x] = st[x] = 0;",
			"        lk[x] = lk[a];",
			"        p[x].clear();",
			"        p[x].push_back(a);",
			"        for (i = u; i != a; i = st[f[j]]) {",
			"            p[x].push_back(i);",
			"            p[x].push_back(j = st[lk[i]]);",
			"            ins(j);",
			"        }",
			"        std::reverse(1 + ALL(p[x]));",
			"        for (i = v; i != a; i = st[f[j]]) { // 复制，只需改循环",
			"            p[x].push_back(i);",
			"            p[x].push_back(j = st[lk[i]]);",
			"            ins(j);",
			"        }",
			"        mdf(x, x);",
			"        FOR(i, m) {",
			"            e[x][i].w = e[i][x].w = 0;",
			"        }",
			"        std::memset(b[x] + 1, 0, n * sizeof b[0][0]);",
			"        for (int u : p[x]) {",
			"            FOR(v, m) {",
			"                if (!e[x][v].w || dvd(e[u][v]) < dvd(e[x][v])) {",
			"                    e[x][v] = e[u][v], e[v][x] = e[v][u];",
			"                }",
			"            }",
			"            FOR(v, n) {",
			"                if (b[u][v]) { b[x][v] = u; }",
			"            }",
			"        }",
			"        ss(x);",
			"    }",
			"    void ex(int u) {",
			"        for (int x : p[u]) mdf(x, x);",
			"        int a = b[u][e[u][f[u]].u], r = gr(u, a);",
			"        for (int i = 0; i < r; i += 2) {",
			"            int x = p[u][i], y = p[u][i + 1];",
			"            f[x] = e[y][x].u;",
			"            s[x] = 1;",
			"            s[y] = sl[x] = 0;",
			"            ss(y), ins(y);",
			"        }",
			"        s[a] = 1, f[a] = f[u];",
			"        for (int i = r + 1; i < p[u].size(); i++) {",
			"            s[p[u][i]] = -1;",
			"            ss(p[u][i]);",
			"        }",
			"        st[u] = 0;",
			"    }",
			"    bool on(const Q &e) {",
			"        int u = st[e.u], v = st[e.v];",
			"        if (s[v] == -1) {",
			"            f[v] = e.u, s[v] = 1;",
			"            int a = st[lk[v]];",
			"            sl[v] = sl[a] = s[a] = 0;",
			"            ins(a);",
			"        } else if (!s[v]) {",
			"            int a = lca(u, v);",
			"            if (!a) {",
			"                return aug(u, v), aug(v, u), 1;",
			"            } else {",
			"                add(u, a, v);",
			"            }",
			"        }",
			"        return 0;",
			"    }",
			"    bool bfs() {",
			"        ms(s, -1), ms(sl, 0);",
			"        h = 1, t = 0;",
			"        FOR(i, m) {",
			"            if (st[i] == i && !lk[i]) {",
			"                f[i] = s[i] = 0;",
			"                ins(i);",
			"            }",
			"        }",
			"        if (h > t) return 0;",
			"        while (1) {",
			"            while (h <= t) {",
			"                int u = q[h++];",
			"                if (s[st[u]] == 1) continue;",
			"                FOR(v, n) {",
			"                    if (e[u][v].w > 0 && st[u] != st[v]) {",
			"                        if (dvd(e[u][v])) upd(u, st[v]);",
			"                        else if (on(e[u][v])) return 1;",
			"                    }",
			"                }",
			"            }",
			"            T x = inf;",
			"            for (int i = n + 1; i <= m; i++) {",
			"                if (st[i] == i && s[i] == 1) {",
			"                    x = std::min(x, lab[i] >> 1);",
			"                }",
			"            }",
			"            FOR(i, m) {",
			"                if (st[i] == i && sl[i] && s[i] != 1) {",
			"                    x = std::min(x, dvd(e[sl[i]][i]) >> s[i] + 1);",
			"                }",
			"            }",
			"            FOR(i, n) {",
			"                if (~s[st[i]]) {",
			"                    if ((lab[i] += (s[st[i]] * 2 - 1) * x) <= 0) return 0;",
			"                }",
			"            }",
			"            for (int i = n + 1; i <= m; i++) {",
			"                if (st[i] == i && ~s[st[i]]) {",
			"                    lab[i] += (2 - s[st[i]] * 4) * x;",
			"                }",
			"            }",
			"            h = 1, t = 0;",
			"            FOR(i, m) {",
			"                if (st[i] == i && sl[i] && st[sl[i]] != i && !dvd(e[sl[i]][i]) && on(e[sl[i]][i])) {",
			"                    return 1;",
			"                }",
			"            }",
			"            for (int i = n + 1; i <= m; i++) {",
			"                if (st[i] == i && s[i] == 1 && !lab[i]) ex(i);",
			"            }",
			"        }",
			"        return 0;",
			"    }",
			"    template<typename TT> i64 work(int N, const std::vector<std::tuple<int, int, TT>> &edges) {",
			"        ms(ed, 0), ms(lk, 0);",
			"        n = m = N; id = 0;",
			"        std::iota(st + 1, st + n + 1, 1);",
			"        T wm = 0; i64 r = 0;",
			"        FOR(i, n) FOR(j, n) {",
			"            e[i][j] = {i, j, 0};",
			"        }",
			"        for (auto [u, v, w] : edges) {",
			"            wm = std::max(wm, e[v][u].w = e[u][v].w = std::max(e[u][v].w, (T)w));",
			"        }",
			"        FOR(i, n) { p[i].clear(); }",
			"        FOR(i, n) FOR(j, n) {",
			"            b[i][j] = i * (i == j);",
			"        }",
			"        fill_n(lab + 1, n, wm);",
			"        while (bfs()) {};",
			"        FOR(i, n) if (lk[i]) {",
			"            r += e[i][lk[i]].w;",
			"        }",
			"        return r / 2;",
			"    }",
			"    auto match() {",
			"        std::vector<std::array<int, 2>> ans;",
			"        FOR(i, n) if (lk[i]) {",
			"            ans.push_back({i, lk[i]});",
			"        }",
			"        return ans;",
			"    }",
			"} // namespace Graph",
			"using Graph::work, Graph::match;",
			"",
			"signed main() {",
			"    int n, m;",
			"    std::cin >> n >> m;",
			"    std::vector<std::tuple<int, int, i64>> ver(m);",
			"    for (auto &[u, v, w] : ver) {",
			"        std::cin >> u >> v >> w;",
			"    }",
			"    cout << work(n, ver) << \"\\n\";",
			"    auto ans = match();",
			"}"
		],
		"description": "Q"
	},
	"code": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"signed main() {",
			"    int n1, n2, m;",
			"    std::cin >> n1 >> n2 >> m;",
			"",
			"    std::vector<std::vector<int>> ver(n1 + 1);",
			"    for (int i = 1; i <= m; ++i) {",
			"        int x, y;",
			"        std::cin >> x >> y;",
			"        ver[x].push_back(y); //只需要建立单向边",
			"    }",
			"",
			"    int ans = 0;",
			"    std::vector<int> match(n2 + 1);",
			"    for (int i = 1; i <= n1; ++i) {",
			"        std::vector<int> vis(n2 + 1);",
			"        auto dfs = [&](auto self, int x) -> bool {",
			"            for (auto y : ver[x]) {",
			"                if (vis[y]) continue;",
			"                vis[y] = 1;",
			"                if (!match[y] || self(self, match[y])) {",
			"                    match[y] = x;",
			"                    return true;",
			"                }",
			"            }",
			"            return false;",
			"        };",
			"        if (dfs(dfs, i)) {",
			"            ans++;",
			"        }",
			"    }",
			"    std::cout << ans << std::endl;",
			"}"
		],
		"description": "Code"
	},
	"hopcroftkarp": {
		"scope": "cpp",
		"prefix": "hopcroftkarp",
		"body": [
			"struct HopcroftKarp {",
			"    int n, m;",
			"    std::vector<std::array<int, 2>> ver;",
			"    std::vector<int> l, r;",
			"",
			"    HopcroftKarp(int n, int m) : n(n), m(m) { // 左右半部",
			"        l.assign(n, -1);",
			"        r.assign(m, -1);",
			"    }",
			"    void add(int x, int y) {",
			"        x--, y--; // 这个板子是 0-idx 的",
			"        ver.push_back({x, y});",
			"    }",
			"    int work() {",
			"        std::vector<int> adj(ver.size());",
			"",
			"        mt19937 rgen(chrono::steady_clock::now().time_since_epoch().std::count());",
			"        shuffle(ver.begin(), ver.end(), rgen); // 随机化防卡",
			"",
			"        std::vector<int> deg(n + 1);",
			"        for (auto &[u, v] : ver) {",
			"            deg[u]++;",
			"        }",
			"        for (int i = 1; i <= n; i++) {",
			"            deg[i] += deg[i - 1];",
			"        }",
			"        for (auto &[u, v] : ver) {",
			"            adj[--deg[u]] = v;",
			"        }",
			"",
			"        int ans = 0;",
			"        std::vector<int> a, p, q(n);",
			"        while (true) {",
			"            a.assign(n, -1), p.assign(n, -1);",
			"",
			"            int t = 0;",
			"            for (int i = 0; i < n; i++) {",
			"                if (l[i] == -1) {",
			"                    q[t++] = a[i] = p[i] = i;",
			"                }",
			"            }",
			"",
			"            bool match = false;",
			"            for (int i = 0; i < t; i++) {",
			"                int x = q[i];",
			"                if (~l[a[x]]) continue;",
			"",
			"                for (int j = deg[x]; j < deg[x + 1]; j++) {",
			"                    int y = adj[j];",
			"                    if (r[y] == -1) {",
			"                        while (~y) {",
			"                            r[y] = x;",
			"                            std::swap(l[x], y);",
			"                            x = p[x];",
			"                        }",
			"                        match = true;",
			"                        ++ans;",
			"                        break;",
			"                    }",
			"                    if (p[r[y]] == -1) {",
			"                        q[t++] = y = r[y];",
			"                        p[y] = x;",
			"                        a[y] = a[x];",
			"                    }",
			"                }",
			"            }",
			"            if (!match) break;",
			"        }",
			"        return ans;",
			"    }",
			"    std::vector<std::array<int, 2>> answer() {",
			"        std::vector<std::array<int, 2>> ans;",
			"        for (int i = 0; i < n; i++) {",
			"            if (~l[i]) {",
			"                ans.push_back({i, l[i]});",
			"            }",
			"        }",
			"        return ans;",
			"    }",
			"};",
			"",
			"signed main() {",
			"    int n1, n2, m;",
			"    std::cin >> n1 >> n2 >> m;",
			"    HopcroftKarp flow(n1, n2);",
			"    while (m--) {",
			"        int x, y;",
			"        std::cin >> x >> y;",
			"        flow.add(x, y);",
			"    }",
			"",
			"    cout << flow.work() << \"\\n\";",
			"",
			"    auto match = flow.answer();",
			"    for (auto [u, v] : match) {",
			"        cout << u << \" \" << v << \"\\n\";",
			"    }",
			"}"
		],
		"description": "Hopcroftkarp"
	},
	"maxcostmatch": {
		"scope": "cpp",
		"prefix": "maxcostmatch",
		"body": [
			"struct MaxCostMatch {",
			"    std::vector<int> ansl, ansr, pre;",
			"    std::vector<int> lx, ly;",
			"    std::vector<std::vector<int>> ver;",
			"    int n;",
			"",
			"    MaxCostMatch(int n) : n(n) {",
			"        ver.resize(n + 1, std::vector<int>(n + 1));",
			"        ansl.resize(n + 1, -1);",
			"        ansr.resize(n + 1, -1);",
			"        lx.resize(n + 1);",
			"        ly.resize(n + 1, -1E18);",
			"        pre.resize(n + 1);",
			"    }",
			"    void add(int x, int y, int w) {",
			"        ver[x][y] = w;",
			"    }",
			"    void bfs(int x) {",
			"        std::vector<bool> visl(n + 1), visr(n + 1);",
			"        std::vector<int> slack(n + 1, 1E18);",
			"        std::queue<int> q;",
			"        function<bool(int)> check = [&](int x) {",
			"            visr[x] = 1;",
			"            if (~ansr[x]) {",
			"                q.push(ansr[x]);",
			"                visl[ansr[x]] = 1;",
			"                return false;",
			"            }",
			"            while (~x) {",
			"                ansr[x] = pre[x];",
			"                std::swap(x, ansl[pre[x]]);",
			"            }",
			"            return true;",
			"        };",
			"        q.push(x);",
			"        visl[x] = 1;",
			"        while (1) {",
			"            while (!q.empty()) {",
			"                int x = q.front();",
			"                q.pop();",
			"                for (int y = 1; y <= n; ++y) {",
			"                    if (visr[y]) continue;",
			"                    int del = lx[x] + ly[y] - ver[x][y];",
			"                    if (del < slack[y]) {",
			"                        pre[y] = x;",
			"                        slack[y] = del;",
			"                        if (!slack[y] && check(y)) return;",
			"                    }",
			"                }",
			"            }",
			"            int val = 1E18;",
			"            for (int i = 1; i <= n; ++i) {",
			"                if (!visr[i]) {",
			"                    val = std::min(val, slack[i]);",
			"                }",
			"            }",
			"            for (int i = 1; i <= n; ++i) {",
			"                if (visl[i]) lx[i] -= val;",
			"                if (visr[i]) {",
			"                    ly[i] += val;",
			"                } else {",
			"                    slack[i] -= val;",
			"                }",
			"            }",
			"            for (int i = 1; i <= n; ++i) {",
			"                if (!visr[i] && !slack[i] && check(i)) {",
			"                    return;",
			"                }",
			"            }",
			"        }",
			"    }",
			"    int work() {",
			"        for (int i = 1; i <= n; ++i) {",
			"            for (int j = 1; j <= n; ++j) {",
			"                ly[i] = std::max(ly[i], ver[j][i]);",
			"            }",
			"        }",
			"        for (int i = 1; i <= n; ++i) bfs(i);",
			"        int res = 0;",
			"        for (int i = 1; i <= n; ++i) {",
			"            res += ver[i][ansl[i]];",
			"        }",
			"        return res;",
			"    }",
			"    void getMatch(int x, int y) { // 获取方案 (0代表无匹配)",
			"        for (int i = 1; i <= x; ++i) {",
			"            cout << (ver[i][ansl[i]] ? ansl[i] : 0) << \" \";",
			"        }",
			"        std::cout << std::endl;",
			"        for (int i = 1; i <= y; ++i) {",
			"            cout << (ver[i][ansr[i]] ? ansr[i] : 0) << \" \";",
			"        }",
			"        std::cout << std::endl;",
			"    }",
			"};",
			"",
			"signed main() {",
			"    int n1, n2, m;",
			"    std::cin >> n1 >> n2 >> m;",
			"",
			"    MaxCostMatch match(std::max(n1, n2));",
			"    for (int i = 1; i <= m; i++) {",
			"        int x, y, w;",
			"        std::cin >> x >> y >> w;",
			"        match.add(x, y, w);",
			"    }",
			"    cout << match.work() << '\\n';",
			"    match.getMatch(n1, n2);",
			"}"
		],
		"description": "Maxcostmatch"
	},
	"konig": {
		"scope": "cpp",
		"prefix": "konig",
		"body": [
			"std::cout << n - flow.work(s, t) << std::endl;"
		],
		"description": "Konig"
	},
	"dag": {
		"scope": "cpp",
		"prefix": "dag",
		"body": [
			"struct DAG {",
			"    int n;",
			"    std::vector<std::vector<std::pair<int, int>>> ver;",
			"    std::vector<int> deg, dis;",
			"    DAG(int n) : n(n) {",
			"        ver.resize(n + 1);",
			"        deg.resize(n + 1);",
			"        dis.assign(n + 1, -1E18);",
			"    }",
			"    void add(int x, int y, int w) {",
			"        ver[x].push_back({y, w});",
			"        ++deg[y];",
			"    }",
			"    int topsort(int s, int t) {",
			"        std::queue<int> q;",
			"        for (int i = 1; i <= n; i++) {",
			"            if (deg[i] == 0) {",
			"                q.push(i);",
			"            }",
			"        }",
			"        dis[s] = 0;",
			"        while (!q.empty()) {",
			"            int x = q.front();",
			"            q.pop();",
			"            for (auto [y, w] : ver[x]) {",
			"                dis[y] = std::max(dis[y], dis[x] + w);",
			"                --deg[y];",
			"                if (deg[y] == 0) {",
			"                    q.push(y);",
			"                }",
			"            }",
			"        }",
			"        return dis[t];",
			"    }",
			"};",
			"",
			"signed main() {",
			"    int n, m;",
			"    std::cin >> n >> m;",
			"    DAG dag(n);",
			"    for (int i = 1; i <= m; i++) {",
			"        int x, y, w;",
			"        std::cin >> x >> y >> w;",
			"        dag.add(x, y, w);",
			"    }",
			"",
			"    int s, t;",
			"    std::cin >> s >> t;",
			"    cout << dag.topsort(s, t) << \"\\n\";",
			"}"
		],
		"description": "Dag"
	},
	"g": {
		"scope": "cpp",
		"prefix": "g",
		"body": [
			"std::map<std::pair<int, int>, int> id;",
			"namespace G {",
			"    std::vector<std::pair<int, int> > ver[N];",
			"    std::map<std::pair<int, int>, int> edge;",
			"    int v[N], d[N], pre[N], vis[N];",
			"    int ans = 0;",
			"",
			"    void add(int x, int y, int w) {",
			"        ver[x].push_back({y, w});",
			"        edge[{x, y}] = edge[{y, x}] = w;",
			"    }",
			"    void djikstra(int s) { // ！注意，该 djikstra 并非原版，多加了一个等于号",
			"        std::priority_queue<PII, std::vector<PII>, greater<PII> > q; q.push({0, s});",
			"        std::memset(d, 0x3f, sizeof d); d[s] = 0;",
			"        while (!q.empty()) {",
			"            int x = q.top().second; q.pop();",
			"            if (v[x]) continue; v[x] = 1;",
			"            for (auto [y, w] : ver[x]) {",
			"                if (d[y] >= d[x] + w) { // ！注意，SPT 这里修改为>=号",
			"                    d[y] = d[x] + w;",
			"                    pre[y] = x; // 记录前驱结点",
			"                    q.push({d[y], y});",
			"                }",
			"            }",
			"        }",
			"    }",
			"    void dfs(int x) {",
			"        vis[x] = 1;",
			"        for (auto [y, w] : ver[x]) {",
			"            if (vis[y]) continue;",
			"            if (pre[y] == x) {",
			"                cout << id[{x, y}] << \" \"; // 输出SPT所使用的边编号",
			"                ans += edge[{x, y}];",
			"                dfs(y);",
			"            }",
			"        }",
			"    }",
			"    void solve(int n) {",
			"        djikstra(1); // 以 1 为根",
			"        dfs(1); // 以 1 为根",
			"        std::cout << std::endl << ans; // 输出SPT的边权和",
			"    }",
			"}",
			"bool Solve() {",
			"    int n, m; std::cin >> n >> m;",
			"    for (int i = 1; i <= m; ++ i) {",
			"        int x, y, w; std::cin >> x >> y >> w;",
			"        G::add(x, y, w), G::add(y, x, w);",
			"        id[{x, y}] = id[{y, x}] = i;",
			"    }",
			"    G::solve(n);",
			"    return 0;",
			"}"
		],
		"description": "G"
	},
	"stoerwagner": {
		"scope": "cpp",
		"prefix": "stoerwagner",
		"body": [
			"signed main() {",
			"    int n, m;",
			"    std::cin >> n >> m;",
			"",
			"    DSU dsu(n); // 这里引入DSU判断图是否联通，如题目有保证，则不需要此步骤",
			"    std::vector<std::vector<int>> edge(n + 1, std::vector<int>(n + 1));",
			"    for (int i = 1; i <= m; i++) {",
			"        int x, y, w;",
			"        std::cin >> x >> y >> w;",
			"        dsu.merge(x, y);",
			"        edge[x][y] += w;",
			"        edge[y][x] += w;",
			"    }",
			"",
			"    if (dsu.Poi(1) != n || m < n - 1) { // 图不联通",
			"        std::cout << 0 << std::endl;",
			"        return 0;",
			"    }",
			"",
			"    int MinCut = INF, S = 1, T = 1; // 虚拟源汇点",
			"    std::vector<int> bin(n + 1);",
			"    auto contract = [&]() -> int { // 求解S到T的最小割，定义为 cut of phase",
			"        std::vector<int> dis(n + 1), vis(n + 1);",
			"        int Min = 0;",
			"        for (int i = 1; i <= n; i++) {",
			"            int k = -1, maxc = -1;",
			"            for (int j = 1; j <= n; j++) {",
			"                if (!bin[j] && !vis[j] && dis[j] > maxc) {",
			"                    k = j;",
			"                    maxc = dis[j];",
			"                }",
			"            }",
			"            if (k == -1) return Min;",
			"            S = T, T = k, Min = maxc;",
			"            vis[k] = 1;",
			"            for (int j = 1; j <= n; j++) {",
			"                if (!bin[j] && !vis[j]) {",
			"                    dis[j] += edge[k][j];",
			"                }",
			"            }",
			"        }",
			"        return Min;",
			"    };",
			"    for (int i = 1; i < n; i++) { // 这里取不到等号",
			"        int val = contract();",
			"        bin[T] = 1;",
			"        MinCut = std::min(MinCut, val);",
			"        if (!MinCut) {",
			"            std::cout << 0 << std::endl;",
			"            return 0;",
			"        }",
			"        for (int j = 1; j <= n; j++) {",
			"            if (!bin[j]) {",
			"                edge[S][j] += edge[j][T];",
			"                edge[j][S] += edge[j][T];",
			"            }",
			"        }",
			"    }",
			"    std::cout << MinCut << std::endl;",
			"}"
		],
		"description": "Stoerwagner"
	},
	"hierholzers": {
		"scope": "cpp",
		"prefix": "hierholzers",
		"body": [
			"signed main() {",
			"    int n, m;",
			"    std::cin >> n >> m;",
			"",
			"    DSU dsu(n + 1); // 如果保证连通，则不需要 DSU",
			"    std::vector<unordered_multiset<int>> ver(n + 1); // 如果对于字典序有要求，则不能使用 unordered",
			"    std::vector<int> degI(n + 1), degO(n + 1);",
			"    for (int i = 1; i <= m; i++) {",
			"        int x, y;",
			"        std::cin >> x >> y;",
			"        ver[x].insert(y);",
			"        degI[y]++;",
			"        degO[x]++;",
			"        dsu.merge(x, y); // 直接当无向图",
			"    }",
			"    int s = 1, t = 1, cnt = 0;",
			"    for (int i = 1; i <= n; i++) {",
			"        if (degI[i] == degO[i]) {",
			"            cnt++;",
			"        } else if (degI[i] + 1 == degO[i]) {",
			"            s = i;",
			"        } else if (degI[i] == degO[i] + 1) {",
			"            t = i;",
			"        }",
			"    }",
			"    if (dsu.size(1) != n || (cnt != n - 2 && cnt != n)) {",
			"        cout << \"No\\n\";",
			"    } else {",
			"        cout << \"Yes\\n\";",
			"    }",
			"}"
		],
		"description": "Hierholzers"
	},
	"hierholzers_1": {
		"scope": "cpp",
		"prefix": "hierholzers",
		"body": [
			"signed main() {",
			"    int n, m;",
			"    std::cin >> n >> m;",
			"",
			"    DSU dsu(n + 1); // 如果保证连通，则不需要 DSU",
			"    std::vector<unordered_multiset<int>> ver(n + 1); // 如果对于字典序有要求，则不能使用 unordered",
			"    std::vector<int> deg(n + 1);",
			"    for (int i = 1; i <= m; i++) {",
			"        int x, y;",
			"        std::cin >> x >> y;",
			"        ver[x].insert(y);",
			"        ver[y].insert(x);",
			"        deg[y]++;",
			"        deg[x]++;",
			"        dsu.merge(x, y); // 直接当无向图",
			"    }",
			"    int s = -1, t = -1, cnt = 0;",
			"    for (int i = 1; i <= n; i++) {",
			"        if (deg[i] % 2 == 0) {",
			"            cnt++;",
			"        } else if (s == -1) {",
			"            s = i;",
			"        } else {",
			"            t = i;",
			"        }",
			"    }",
			"    if (dsu.size(1) != n || (cnt != n - 2 && cnt != n)) {",
			"        cout << \"No\\n\";",
			"    } else {",
			"        cout << \"Yes\\n\";",
			"    }",
			"}"
		],
		"description": "Hierholzers"
	},
	"for_1": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"std::vector<int> ans;",
			"auto dfs = [&](auto self, int x) -> void {",
			"    while (ver[x].size()) {",
			"        int net = *ver[x].begin();",
			"        ver[x].erase(ver[x].begin());",
			"        self(self, net);",
			"    }",
			"    ans.push_back(x);",
			"};",
			"dfs(dfs, s);",
			"std::reverse(ans.begin(), ans.end());",
			"for (auto it : ans) {",
			"    cout << it << \" \";",
			"}"
		],
		"description": "For"
	},
	"hierholzers_2": {
		"scope": "cpp",
		"prefix": "hierholzers",
		"body": [
			"auto dfs = [&](auto self, int x) -> void {",
			"    while (ver[x].size()) {",
			"        int net = *ver[x].begin();",
			"        ver[x].erase(ver[x].std::find(net));",
			"        ver[net].erase(ver[net].std::find(x));",
			"        cout << x << \" \" << net << endl;",
			"        self(self, net);",
			"    }",
			"};",
			"dfs(dfs, s);"
		],
		"description": "Hierholzers"
	},
	"code_1": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"signed main() {",
			"    int n, m;",
			"    std::cin >> n >> m;",
			"",
			"    std::vector<std::array<int, 3>> e(m + 1);",
			"    for (int i = 1; i <= m; i++) {",
			"        int u, v, w;",
			"        std::cin >> u >> v >> w;",
			"        e[i] = {v, u, w};",
			"    }",
			"",
			"    std::vector<int> d(n + 1, 1E9);",
			"    d[1] = 0;",
			"    for (int i = 1; i < n; i++) {",
			"        for (int j = 1; j <= m; j++) {",
			"            auto [u, v, w] = e[j];",
			"            d[v] = std::min(d[v], d[u] + w);",
			"        }",
			"    }",
			"    for (int i = 1; i <= m; i++) {",
			"        auto [u, v, w] = e[i];",
			"        if (d[v] > d[u] + w) {",
			"            cout << \"NO\\n\";",
			"            return 0;",
			"        }",
			"    }",
			"    for (int i = 1; i <= n; i++) {",
			"        cout << d[i] << \" \\n\"[i == n];",
			"    }",
			"    return 0;",
			"}"
		],
		"description": "Code"
	},
	"twosat": {
		"scope": "cpp",
		"prefix": "twosat",
		"body": [
			"struct TwoSat {",
			"    int n;",
			"    std::vector<std::vector<int>> e;",
			"    std::vector<bool> ans;",
			"    TwoSat(int n) : n(n), e(2 * n), ans(n) {}",
			"    void add(int u, bool f, int v, bool g) {",
			"        e[2 * u + !f].push_back(2 * v + g);",
			"        e[2 * v + !g].push_back(2 * u + f);",
			"    }",
			"    bool work() {",
			"        std::vector<int> id(2 * n, -1), dfn(2 * n, -1), low(2 * n, -1);",
			"        std::vector<int> stk;",
			"        int now = 0, cnt = 0;",
			"        auto tarjan = [&](auto self, int u) -> void {",
			"            stk.push_back(u);",
			"            dfn[u] = low[u] = now++;",
			"            for (auto v : e[u]) {",
			"                if (dfn[v] == -1) {",
			"                    self(self, v);",
			"                    low[u] = std::min(low[u], low[v]);",
			"                } else if (id[v] == -1) {",
			"                    low[u] = std::min(low[u], dfn[v]);",
			"                }",
			"            }",
			"            if (dfn[u] == low[u]) {",
			"                int v;",
			"                do {",
			"                    v = stk.back();",
			"                    stk.pop_back();",
			"                    id[v] = cnt;",
			"                } while (v != u);",
			"                ++cnt;",
			"            }",
			"        };",
			"        for (int i = 0; i < 2 * n; ++i) {",
			"            if (dfn[i] == -1) {",
			"                tarjan(tarjan, i);",
			"            }",
			"        }",
			"        for (int i = 0; i < n; ++i) {",
			"            if (id[2 * i] == id[2 * i + 1]) return false;",
			"            ans[i] = id[2 * i] > id[2 * i + 1];",
			"        }",
			"        return true;",
			"    }",
			"    std::vector<bool> answer() {",
			"        return ans;",
			"    }",
			"};"
		],
		"description": "Twosat"
	},
	"check": {
		"scope": "cpp",
		"prefix": "check",
		"body": [
			"// 结构体中增加",
			"int check(int x, int y) {",
			"    std::vector<int> vis(2 * n);",
			"    auto dfs = [&](auto self, int x) -> void {",
			"        vis[x] = 1;",
			"        for (auto y : e[x]) {",
			"            if (vis[y]) continue;",
			"            self(self, y);",
			"        }",
			"    };",
			"    dfs(dfs, x);",
			"    return vis[y];",
			"}",
			"// 主函数中增加",
			"for (int i = 0; i < n; i++) {",
			"    if (sat.check(2 * i, 2 * i + 1)) {",
			"        cout << 1 << \" \";",
			"    } else if (sat.check(2 * i + 1, 2 * i)) {",
			"        cout << 0 << \" \";",
			"    } else {",
			"        cout << \"?\" << \" \";",
			"    }",
			"}"
		],
		"description": "Check"
	},
	"for_2": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"std::vector<int> val(n + 1, 1);",
			"int ans = 0;",
			"function<void(int, int)> dfs = [&](int x, int fa) {",
			"    for (auto y : ver[x]) {",
			"        if (y == fa) continue;",
			"        dfs(y, x);",
			"        val[x] += val[y];",
			"        ans += std::min(val[y], k - val[y]);",
			"    }",
			"};",
			"dfs(1, 0);",
			"std::cout << ans << std::endl;"
		],
		"description": "For"
	},
	"add_1": {
		"scope": "cpp",
		"prefix": "add",
		"body": [
			"LL n, point[N];",
			"LL ver[N], head[N], nex[N], tot; bool v[N];",
			"std::map<std::pair<LL, LL>, LL> edge;",
			"// void add(LL x, LL y) {}",
			"void dfs(LL x) {",
			"    for (LL i = head[x]; i; i = nex[i]) {",
			"        LL y = ver[i];",
			"        if (v[y]) continue;",
			"        v[y] = true; dfs(y); v[y] = false;",
			"    }",
			"    for (LL i = head[x]; i; i = nex[i]) {",
			"        LL y = ver[i];",
			"        if (v[y]) continue;",
			"        point[x] += std::max(point[y] + edge[{x, y}], 0LL);",
			"    }",
			"}",
			"void Solve() {",
			"    std::cin >> n;",
			"    FOR(i, 1, n) std::cin >> point[i];",
			"    FOR(i, 2, n) {",
			"        LL x, y, w; std::cin >> x >> y >> w;",
			"        edge[{x, y}] = edge[{y, x}] = w;",
			"        add(x, y), add(y, x);",
			"    }",
			"    v[1] = true; dfs(1); LL ans = -MAX18;",
			"    FOR(i, 1, n) ans = std::max(ans, point[i]);",
			"    std::cout << ans << std::endl;",
			"}"
		],
		"description": "Add"
	},
	"clear": {
		"scope": "cpp",
		"prefix": "clear",
		"body": [
			"const int N = 2e5 + 7, M = 1e6 + 7;",
			"int n, m, s, e; int d[N][2], v[N][2]; // 0 代表最短路， 1 代表次短路",
			"Z num[N][2];",
			"",
			"void Clear() {",
			"    for (int i = 1; i <= n; ++ i) h[i] = edge[i] = 0;",
			"    tot = 0;",
			"    for (int i = 1; i <= n; ++ i) num[i][0] = num[i][1] = v[i][0] = v[i][1] = 0;",
			"    for (int i = 1; i <= n; ++ i) d[i][0] = d[i][1] = INF;",
			"}",
			"",
			"int ver[M], ne[M], h[N], edge[M], tot;",
			"void add(int x, int y, int w) {",
			"    ver[++ tot] = y, ne[tot] = h[x], h[x] = tot;",
			"    edge[tot] = w;",
			"}",
			"",
			"void dji() {",
			"    std::priority_queue<PIII, std::vector<PIII>, greater<PIII> > q; q.push({0, s, 0});",
			"    num[s][0] = 1; d[s][0] = 0;",
			"    while (!q.empty()) {",
			"        auto [dis, x, type] = q.top(); q.pop();",
			"        if (v[x][type]) continue; v[x][type] = 1;",
			"        for (int i = h[x]; i; i = ne[i]) {",
			"            int y = ver[i], w = dis + edge[i];",
			"            if (d[y][0] > w) {",
			"                d[y][1] = d[y][0], num[y][1] = num[y][0];",
			"                    // 如果找到新的最短路，将原有的最短路数据转化为次短路",
			"                q.push({d[y][1], y, 1});",
			"                d[y][0] = w, num[y][0] = num[x][type];",
			"                q.push({d[y][0], y, 0});",
			"            }",
			"            else if (d[y][0] == w) num[y][0] += num[x][type];",
			"            else if (d[y][1] > w) {",
			"                d[y][1] = w, num[y][1] = num[x][type];",
			"                q.push({d[y][1], y, 1});",
			"            }",
			"            else if (d[y][1] == w) num[y][1] += num[x][type];",
			"        }",
			"    }",
			"}",
			"void Solve() {",
			"    std::cin >> n >> m >> s >> e;",
			"    Clear(); //多组样例务必完全清空",
			"    for (int i = 1; i <= m; ++ i) {",
			"        int x, y, w; std::cin >> x >> y; w = 1;",
			"        add(x, y, w), add(y, x, w);",
			"    }",
			"    dji();",
			"    Z ans = num[e][0];",
			"    if (d[e][1] == d[e][0] + 1) {",
			"        ans += num[e][1]; // 只有在次短路满足条件时才计算（距离恰好比最短路大1）",
			"    }",
			"    std::cout << ans.val() << std::endl;",
			"}"
		],
		"description": "Clear"
	},
	"add_2": {
		"scope": "cpp",
		"prefix": "add",
		"body": [
			"const int N = 1e5 + 7, M = 1e6 + 7;",
			"int n, m;",
			"int ver[M], ne[M], h[N], edge[M], tot;",
			"int d[N], v[N], num[N];",
			"",
			"void add(int x, int y, int w)  {",
			"    ver[++ tot] = y, ne[tot] = h[x], h[x] = tot;",
			"    edge[tot] = w;",
			"}",
			"bool spfa() {",
			"    std::queue<int> q;",
			"    for (int i = 1; i <= n; ++ i) q.push(i), v[i] = 1; //全部入队",
			"    while(!q.empty()) {",
			"        int x = q.front(); q.pop();",
			"        v[x] = 0;",
			"        for (int i = h[x]; i; i = ne[i]) {",
			"            int y = ver[i];",
			"            if(d[y] > d[x] + edge[i]) {",
			"                num[y] = num[x] + 1;",
			"                if (num[y] >= n) return true;",
			"                d[y] = d[x] + edge[i];",
			"                if(!v[y]) q.push(y), v[y] = 1;",
			"            }",
			"        }",
			"    }",
			"    return false;",
			"}",
			"int main() {",
			"    std::cin >> n >> m;",
			"    for (int i = 1; i <= m; ++ i) {",
			"        int x, y, w; std::cin >> x >> y >> w;",
			"        add(x, y, w);",
			"    }",
			"    if(spfa() == true) cout << \"Yes\" << endl;",
			"    else cout << \"No\" << endl;",
			"}"
		],
		"description": "Add"
	},
	"for_3": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"int n;",
			"std::cin >> n;",
			"std::vector<std::vector<int>> a(n + 1, std::vector<int>(n + 1));",
			"for (int i = 1; i <= n; ++i) {",
			"    for (int j = 1; j <= n; ++j) {",
			"        char x;",
			"        std::cin >> x;",
			"        if (x == '1') a[i][j] = 1;",
			"    }",
			"}",
			"",
			"std::vector<int> vis(n + 1);",
			"function<void(int, int)> dfs = [&](int x, int fa) {",
			"    vis[x] = 1;",
			"    for (int y = 1; y <= n; ++y) {",
			"        if (a[x][y] == 0) continue;",
			"        if (a[y][fa] == 1) {",
			"            cout << fa << \" \" << x << \" \" << y;",
			"            exit(0);",
			"        }",
			"        if (!vis[y]) dfs(y, x); // 这一步的if判断很关键",
			"    }",
			"};",
			"for (int i = 1; i <= n; ++i) {",
			"    if (!vis[i]) dfs(i, -1);",
			"}",
			"std::cout << -1;"
		],
		"description": "For"
	},
	"for_4": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"LL Min = 1e18, ans = 0;",
			"for (int k = 1; k <= n; k++) {",
			"    for (int i = 1; i <= n; i++) {",
			"        for (int j = 1; j <= n; j++) {",
			"            if (dis[i][j] > dis[i][k] + dis[k][j]) {",
			"                dis[i][j] = dis[i][k] + dis[k][j];",
			"                cnt[i][j] = cnt[i][k] * cnt[k][j] % mod;",
			"            } else if (dis[i][j] == dis[i][k] + dis[k][j]) {",
			"                cnt[i][j] = (cnt[i][j] + cnt[i][k] * cnt[k][j] % mod) % mod;",
			"            }",
			"        }",
			"    }",
			"    for (int i = 1; i < k; i++) {",
			"        if (a[k][i]) {",
			"            if (a[k][i] + dis[i][k] < Min) {",
			"                Min = a[k][i] + dis[i][k];",
			"                ans = cnt[i][k];",
			"            } else if (a[k][i] + dis[i][k] == Min) {",
			"                ans = (ans + cnt[i][k]) % mod;",
			"            }",
			"        }",
			"    }",
			"}"
		],
		"description": "For"
	},
	"flody": {
		"scope": "cpp",
		"prefix": "flody",
		"body": [
			"int flody(int n) {",
			"    for (int i = 1; i <= n; ++ i) {",
			"        for (int j = 1; j <= n; ++ j) {",
			"            val[i][j] = dis[i][j]; // 记录最初的边权值",
			"        }",
			"    }",
			"    int ans = 0x3f3f3f3f;",
			"    for (int k = 1; k <= n; ++ k) {",
			"        for (int i = 1; i < k; ++ i) { // 注意这里是没有等于号的",
			"            for (int j = 1; j < i; ++ j) {",
			"                ans = std::min(ans, dis[i][j] + val[i][k] + val[k][j]);",
			"            }",
			"        }",
			"    for (int i = 1; i <= n; ++ i) { // 往下是标准的flody",
			"        for (int j = 1; j <= n; ++ j) {",
			"                dis[i][j] = std::min(dis[i][j], dis[i][k] + dis[k][j]);",
			"            }",
			"        }",
			"    }",
			"    return ans;",
			"}"
		],
		"description": "Flody"
	},
	"for_5": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"auto bfs = [&] (int s) {",
			"    std::queue<int> q; q.push(s);",
			"    dis[s] = 0;",
			"    fa[s] = -1;",
			"    while (q.size()) {",
			"        auto x = q.front(); q.pop();",
			"        for (auto y : ver[x]) {",
			"            if (y == fa[x]) continue;",
			"            if (dis[y] == -1) {",
			"                dis[y] = dis[x] + 1;",
			"                fa[y] = x;",
			"                q.push(y);",
			"            }",
			"            else ans = std::min(ans, dis[x] + dis[y] + 1);",
			"        }",
			"    }",
			"};",
			"for (int i = 1; i <= n; ++ i) {",
			"    std::fill(dis + 1, dis + 1 + n, -1);",
			"    bfs(i);",
			"}",
			"std::cout << ans;"
		],
		"description": "For"
	},
	"for_6": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"int n, m;",
			"std::cin >> n >> m;",
			"std::vector<std::vector<int>> G(n);",
			"for (int i = 0; i < m; i++) {",
			"    int u, v;",
			"    std::cin >> u >> v;",
			"    u--, v--;",
			"    G[u].push_back(v);",
			"    G[v].push_back(u);",
			"}",
			"std::vector<std::vector<LL>> dp(1 << n, std::vector<LL>(n));",
			"for (int i = 0; i < n; i++) dp[1 << i][i] = 1;",
			"LL ans = 0;",
			"for (int st = 1; st < (1 << n); st++) {",
			"    for (int u = 0; u < n; u++) {",
			"        if (!dp[st][u]) continue;",
			"        int start = st & -st;",
			"        for (auto v : G[u]) {",
			"            if ((1 << v) < start) continue;",
			"            if ((1 << v) & st) {",
			"                if ((1 << v) == start) {",
			"                    ans += dp[st][u];",
			"                }",
			"            } else {",
			"                dp[st | (1 << v)][v] += dp[st][u];",
			"            }",
			"        }",
			"    }",
			"}",
			"cout << (ans - m) / 2 << \"\\n\";"
		],
		"description": "For"
	},
	"for_7": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"std::vector<int> dis(n + 1, -1), fa(n + 1);",
			"auto dfs = [&](auto self, int x) -> void {",
			"    for (auto y : ver[x]) {",
			"        if (y == fa[x]) continue; // 二元环需删去该行",
			"        if (dis[y] == -1) {",
			"            dis[y] = dis[x] + 1;",
			"            fa[y] = x;",
			"            self(self, y);",
			"        } else if (dis[y] < dis[x]) {",
			"            std::cout << dis[x] - dis[y] + 1 << std::endl;",
			"            int pre = x;",
			"            cout << pre << \" \";",
			"            while (pre != y) {",
			"                pre = fa[pre];",
			"                cout << pre << \" \";",
			"            }",
			"            std::cout << std::endl;",
			"            exit(0);",
			"        }",
			"    }",
			"};",
			"for (int i = 1; i <= n; i++) {",
			"    if (dis[i] == -1) {",
			"        dis[i] = 0;",
			"        dfs(dfs, 1);",
			"    }",
			"}"
		],
		"description": "For"
	},
	"for_8": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"int ans = 0;",
			"std::vector<int> vis(n + 1);",
			"auto dfs = [&](auto self, int x) -> void {",
			"    vis[x] = 1;",
			"    for (auto y : ver[x]) {",
			"        if (vis[y] == 0) {",
			"            self(self, y);",
			"        } else if (vis[y] == 1) {",
			"            ans++;",
			"        }",
			"    }",
			"    vis[x] = 2;",
			"};",
			"for (int i = 1; i <= n; i++) {",
			"    if (!vis[i]) {",
			"        dfs(dfs, i);",
			"    }",
			"}",
			"std::cout << ans << std::endl;"
		],
		"description": "For"
	},
	"for_9": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"std::vector<int> dis(n + 1), vis(n + 1), fa(n + 1);",
			"auto dfs = [&](auto self, int x) -> void {",
			"    vis[x] = 1;",
			"    for (auto y : ver[x]) {",
			"        if (vis[y] == 0) {",
			"            dis[y] = dis[x] + 1;",
			"            fa[y] = x;",
			"            self(self, y);",
			"        } else if (vis[y] == 1) {",
			"            std::cout << dis[x] - dis[y] + 1 << std::endl;",
			"            int pre = x;",
			"            cout << pre << \" \";",
			"            while (pre != y) {",
			"                pre = fa[pre];",
			"                cout << pre << \" \";",
			"            }",
			"            std::cout << std::endl;",
			"            exit(0);",
			"        }",
			"    }",
			"    vis[x] = 2;",
			"};",
			"for (int i = 1; i <= n; i++) {",
			"    if (!vis[i]) {",
			"        dfs(dfs, i);",
			"    }",
			"}"
		],
		"description": "For"
	},
	"code_2": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"signed main() {",
			"    int n, m;",
			"    std::cin >> n >> m;",
			"    std::vector<std::pair<int, int>> in(m);",
			"    for (int i = 0, x, y; i < m; i++) {",
			"        std::cin >> x >> y;",
			"        in[i] = minmax(x, y);",
			"    }",
			"    TwoSat sat(m);",
			"    for (int i = 0; i < m; i++) {",
			"        auto [s, e] = in[i];",
			"        for (int j = i + 1; j < m; j++) {",
			"            auto [S, E] = in[j];",
			"            if (s < S && S < e && e < E || S < s && s < E && E < e) {",
			"                sat.add(i, 0, j, 0);",
			"                sat.add(i, 1, j, 1);",
			"            }",
			"        }",
			"    }",
			"    if (!sat.work()) {",
			"        cout << \"Impossible\\n\";",
			"        return 0;",
			"    }",
			"    auto ans = sat.answer();",
			"    for (auto it : ans) {",
			"        cout << (it ? \"out\" : \"in\") << \" \";",
			"    }",
			"}"
		],
		"description": "Code"
	},
	"tree": {
		"scope": "cpp",
		"prefix": "tree",
		"body": [
			"struct Tree {",
			"    int n;",
			"    std::vector<std::vector<int>> ver;",
			"    Tree(int n) {",
			"        this->n = n;",
			"        ver.resize(n + 1);",
			"    }",
			"    void add(int x, int y) {",
			"        ver[x].push_back(y);",
			"        ver[y].push_back(x);",
			"    }",
			"    int getlen(int root) { // 获取x所在树的直径",
			"        std::map<int, int> dep; // map用于优化输入为森林时的深度计算，亦可用vector",
			"        function<void(int, int)> dfs = [&](int x, int fa) -> void {",
			"            for (auto y : ver[x]) {",
			"                if (y == fa) continue;",
			"                dep[y] = dep[x] + 1;",
			"                dfs(y, x);",
			"            }",
			"            if (dep[x] > dep[root]) {",
			"                root = x;",
			"            }",
			"        };",
			"        dfs(root, 0);",
			"        int st = root; // 记录直径端点",
			"",
			"        dep.clear();",
			"        dfs(root, 0);",
			"        int ed = root; // 记录直径另一端点",
			"",
			"        return dep[root];",
			"    }",
			"};"
		],
		"description": "Tree"
	},
	"tree_1": {
		"scope": "cpp",
		"prefix": "tree",
		"body": [
			"struct Tree {",
			"    int n;",
			"    std::vector<std::vector<std::pair<int, int>>> e;",
			"    std::vector<int> dep, parent, maxdep, d1, d2, s1, s2, up;",
			"    Tree(int n) {",
			"        this->n = n;",
			"        e.resize(n + 1);",
			"        dep.resize(n + 1);",
			"        parent.resize(n + 1);",
			"        maxdep.resize(n + 1);",
			"        d1.resize(n + 1);",
			"        d2.resize(n + 1);",
			"        s1.resize(n + 1);",
			"        s2.resize(n + 1);",
			"        up.resize(n + 1);",
			"    }",
			"    void add(int u, int v, int w) {",
			"        e[u].push_back({w, v});",
			"        e[v].push_back({w, u});",
			"    }",
			"    void dfs(int u, int fa) {",
			"        maxdep[u] = dep[u];",
			"        for (auto [w, v] : e[u]) {",
			"            if (v == fa) continue;",
			"            dep[v] = dep[u] + 1;",
			"            parent[v] = u;",
			"            dfs(v, u);",
			"            maxdep[u] = std::max(maxdep[u], maxdep[v]);",
			"        }",
			"    }",
			"",
			"    void dfs1(int u, int fa) {",
			"        for (auto [w, v] : e[u]) {",
			"            if (v == fa) continue;",
			"            dfs1(v, u);",
			"            int x = d1[v] + w;",
			"            if (x > d1[u]) {",
			"                d2[u] = d1[u], s2[u] = s1[u];",
			"                d1[u] = x, s1[u] = v;",
			"            } else if (x > d2[u]) {",
			"                d2[u] = x, s2[u] = v;",
			"            }",
			"        }",
			"    }",
			"    void dfs2(int u, int fa) {",
			"        for (auto [w, v] : e[u]) {",
			"            if (v == fa) continue;",
			"            if (s1[u] == v) {",
			"                up[v] = std::max(up[u], d2[u]) + w;",
			"            } else {",
			"                up[v] = std::max(up[u], d1[u]) + w;",
			"            }",
			"            dfs2(v, u);",
			"        }",
			"    }",
			"",
			"    int radius, center, diam;",
			"    void getCenter() {",
			"        center = 1; //中心",
			"        for (int i = 1; i <= n; i++) {",
			"            if (std::max(d1[i], up[i]) < std::max(d1[center], up[center])) {",
			"                center = i;",
			"            }",
			"        }",
			"        radius = std::max(d1[center], up[center]); //距离最远点的距离的最小值",
			"        diam = d1[center] + up[center] + 1; //直径",
			"    }",
			"",
			"    int rem; //删除重心后剩余连通块体积的最小值",
			"    int cog; //重心",
			"    std::vector<bool> vis;",
			"    void getCog() {",
			"        vis.resize(n);",
			"        rem = INT_MAX;",
			"        cog = 1;",
			"        dfsCog(1);",
			"    }",
			"    int dfsCog(int u) {",
			"        vis[u] = true;",
			"        int s = 1, res = 0;",
			"        for (auto [w, v] : e[u]) {",
			"            if (vis[v]) continue;",
			"            int t = dfsCog(v);",
			"            res = std::max(res, t);",
			"            s += t;",
			"        }",
			"        res = std::max(res, n - s);",
			"        if (res < rem) {",
			"            rem = res;",
			"            cog = u;",
			"        }",
			"        return s;",
			"    }",
			"};"
		],
		"description": "Tree"
	},
	"for_10": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"int root = 0, MaxTree = 1e18; //分别代表重心下标、最大子树大小",
			"std::vector<int> vis(n + 1), siz(n + 1);",
			"auto get = [&](auto self, int x, int fa, int n) -> void { // 获取树的重心",
			"    siz[x] = 1;",
			"    int val = 0;",
			"    for (auto [y, w] : ver[x]) {",
			"        if (y == fa || vis[y]) continue;",
			"        self(self, y, x, n);",
			"        siz[x] += siz[y];",
			"        val = std::max(val, siz[y]);",
			"    }",
			"    val = std::max(val, n - siz[x]);",
			"    if (val < MaxTree) {",
			"        MaxTree = val;",
			"        root = x;",
			"    }",
			"};",
			"",
			"auto clac = [&](int x) -> void { // 以 x 为新的根，维护询问",
			"    std::set<int> pre = {0}; // 记录到根节点 x 距离为 i 的路径是否存在",
			"    std::vector<int> dis(n + 1);",
			"    for (auto [y, w] : ver[x]) {",
			"        if (vis[y]) continue;",
			"        std::vector<int> child; // 记录 x 的子树节点的深度信息",
			"        auto dfs = [&](auto self, int x, int fa) -> void {",
			"            child.push_back(dis[x]);",
			"            for (auto [y, w] : ver[x]) {",
			"                if (y == fa || vis[y]) continue;",
			"                dis[y] = dis[x] + w;",
			"                self(self, y, x);",
			"            }",
			"        };",
			"        dis[y] = w;",
			"        dfs(dfs, y, x);",
			"",
			"        for (auto it : child) {",
			"            for (int i = 1; i <= m; i++) { // 根据询问更新值",
			"                if (q[i] < it || !pre.std::count(q[i] - it)) continue;",
			"                ans[i] = 1;",
			"            }",
			"        }",
			"        pre.insert(child.begin(), child.end());",
			"    }",
			"};",
			"",
			"auto dfz = [&](auto self, int x, int fa) -> void { // 点分治",
			"    vis[x] = 1; // 标记已经被更新过的旧重心，确保只对子树分治",
			"    clac(x);",
			"    for (auto [y, w] : ver[x]) {",
			"        if (y == fa || vis[y]) continue;",
			"        MaxTree = 1e18;",
			"        get(get, y, x, siz[y]);",
			"        self(self, root, x);",
			"    }",
			"};",
			"",
			"get(get, 1, 0, n);",
			"dfz(dfz, root, 0);"
		],
		"description": "For"
	},
	"hld": {
		"scope": "cpp",
		"prefix": "hld",
		"body": [
			"struct HLD {",
			"    int n, idx;",
			"    std::vector<std::vector<int>> ver;",
			"    std::vector<int> siz, dep;",
			"    std::vector<int> top, son, parent;",
			"",
			"    HLD(int n) {",
			"        this->n = n;",
			"        ver.resize(n + 1);",
			"        siz.resize(n + 1);",
			"        dep.resize(n + 1);",
			"",
			"        top.resize(n + 1);",
			"        son.resize(n + 1);",
			"        parent.resize(n + 1);",
			"    }",
			"    void add(int x, int y) { // 建立双向边",
			"        ver[x].push_back(y);",
			"        ver[y].push_back(x);",
			"    }",
			"    void dfs1(int x) {",
			"        siz[x] = 1;",
			"        dep[x] = dep[parent[x]] + 1;",
			"        for (auto y : ver[x]) {",
			"            if (y == parent[x]) continue;",
			"            parent[y] = x;",
			"            dfs1(y);",
			"            siz[x] += siz[y];",
			"            if (siz[y] > siz[son[x]]) {",
			"                son[x] = y;",
			"            }",
			"        }",
			"    }",
			"    void dfs2(int x, int up) {",
			"        top[x] = up;",
			"        if (son[x]) dfs2(son[x], up);",
			"        for (auto y : ver[x]) {",
			"            if (y == parent[x] || y == son[x]) continue;",
			"            dfs2(y, y);",
			"        }",
			"    }",
			"    int lca(int x, int y) {",
			"        while (top[x] != top[y]) {",
			"            if (dep[top[x]] > dep[top[y]]) {",
			"                x = parent[top[x]];",
			"            } else {",
			"                y = parent[top[y]];",
			"            }",
			"        }",
			"        return dep[x] < dep[y] ? x : y;",
			"    }",
			"    int clac(int x, int y) { // 查询两点间距离",
			"        return dep[x] + dep[y] - 2 * dep[lca(x, y)];",
			"    }",
			"    void work(int root = 1) { // 在此初始化",
			"        dfs1(root);",
			"        dfs2(root, root);",
			"    }",
			"};"
		],
		"description": "Hld"
	},
	"tree_2": {
		"scope": "cpp",
		"prefix": "tree",
		"body": [
			"struct Tree {",
			"    int n;",
			"    std::vector<std::vector<int>> ver, val;",
			"    std::vector<int> lg, dep;",
			"    Tree(int n) {",
			"        this->n = n;",
			"        ver.resize(n + 1);",
			"        val.resize(n + 1, std::vector<int>(30));",
			"        lg.resize(n + 1);",
			"        dep.resize(n + 1);",
			"        for (int i = 1; i <= n; i++) { //预处理 std::log",
			"            lg[i] = lg[i - 1] + (1 << lg[i - 1] == i);",
			"        }",
			"    }",
			"    void add(int x, int y) { // 建立双向边",
			"        ver[x].push_back(y);",
			"        ver[y].push_back(x);",
			"    }",
			"    void dfs(int x, int fa) {",
			"        val[x][0] = fa; // 储存 x 的父节点",
			"        dep[x] = dep[fa] + 1;",
			"        for (int i = 1; i <= lg[dep[x]]; i++) {",
			"            val[x][i] = val[val[x][i - 1]][i - 1];",
			"        }",
			"        for (auto y : ver[x]) {",
			"            if (y == fa) continue;",
			"            dfs(y, x);",
			"        }",
			"    }",
			"    int lca(int x, int y) {",
			"        if (dep[x] < dep[y]) std::swap(x, y);",
			"        while (dep[x] > dep[y]) {",
			"            x = val[x][lg[dep[x] - dep[y]] - 1];",
			"        }",
			"        if (x == y) return x;",
			"        for (int k = lg[dep[x]] - 1; k >= 0; k--) {",
			"            if (val[x][k] == val[y][k]) continue;",
			"            x = val[x][k];",
			"            y = val[y][k];",
			"        }",
			"        return val[x][0];",
			"    }",
			"    int clac(int x, int y) { // 倍增查询两点间距离",
			"        return dep[x] + dep[y] - 2 * dep[lca(x, y)];",
			"    }",
			"    void work(int root = 1) { // 在此初始化",
			"        dfs(root, 0);",
			"    }",
			"};"
		],
		"description": "Tree"
	},
	"tree_3": {
		"scope": "cpp",
		"prefix": "tree",
		"body": [
			"struct Tree {",
			"    int n;",
			"    std::vector<std::vector<int>> val, Max;",
			"    std::vector<std::vector<std::pair<int, int>>> ver;",
			"    std::vector<int> lg, dep;",
			"    Tree(int n) {",
			"        this->n = n;",
			"        ver.resize(n + 1);",
			"        val.resize(n + 1, std::vector<int>(30));",
			"        Max.resize(n + 1, std::vector<int>(30));",
			"        lg.resize(n + 1);",
			"        dep.resize(n + 1);",
			"        for (int i = 1; i <= n; i++) { //预处理 std::log",
			"            lg[i] = lg[i - 1] + (1 << lg[i - 1] == i);",
			"        }",
			"    }",
			"    void add(int x, int y, int w) { // 建立双向边",
			"        ver[x].push_back({y, w});",
			"        ver[y].push_back({x, w});",
			"    }",
			"    void dfs(int x, int fa) {",
			"        val[x][0] = fa;",
			"        dep[x] = dep[fa] + 1;",
			"        for (int i = 1; i <= lg[dep[x]]; i++) {",
			"            val[x][i] = val[val[x][i - 1]][i - 1];",
			"            Max[x][i] = std::max(Max[x][i - 1], Max[val[x][i - 1]][i - 1]);",
			"        }",
			"        for (auto [y, w] : ver[x]) {",
			"            if (y == fa) continue;",
			"            Max[y][0] = w;",
			"            dfs(y, x);",
			"        }",
			"    }",
			"    int lca(int x, int y) {",
			"        if (dep[x] < dep[y]) std::swap(x, y);",
			"        while (dep[x] > dep[y]) {",
			"            x = val[x][lg[dep[x] - dep[y]] - 1];",
			"        }",
			"        if (x == y) return x;",
			"        for (int k = lg[dep[x]] - 1; k >= 0; k--) {",
			"            if (val[x][k] == val[y][k]) continue;",
			"            x = val[x][k];",
			"            y = val[y][k];",
			"        }",
			"        return val[x][0];",
			"    }",
			"    int clac(int x, int y) { // 倍增查询两点间距离",
			"        return dep[x] + dep[y] - 2 * dep[lca(x, y)];",
			"    }",
			"    int query(int x, int y) { // 倍增查询两点路径上的最大边权（带权图）",
			"        auto get = [&](int x, int y) -> int {",
			"            int ans = 0;",
			"            if (x == y) return ans;",
			"            for (int i = lg[dep[x]]; i >= 0; i--) {",
			"                if (dep[val[x][i]] > dep[y]) {",
			"                    ans = std::max(ans, Max[x][i]);",
			"                    x = val[x][i];",
			"                }",
			"            }",
			"            ans = std::max(ans, Max[x][0]);",
			"            return ans;",
			"        };",
			"        int fa = lca(x, y);",
			"        return std::max(get(x, fa), get(y, fa));",
			"    }",
			"    void work(int root = 1) { // 在此初始化",
			"        dfs(root, 0);",
			"    }",
			"};"
		],
		"description": "Tree"
	},
	"intersection": {
		"scope": "cpp",
		"prefix": "intersection",
		"body": [
			"int intersection(int x, int y, int X, int Y) {",
			"    std::vector<int> t = {lca(x, X), lca(x, Y), lca(y, X), lca(y, Y)};",
			"    std::sort(t.begin(), t.end());",
			"    int r = lca(x, y), R = lca(X, Y);",
			"    if (dep[t[0]] < std::min(dep[r], dep[R]) || dep[t[2]] < std::max(dep[r], dep[R])) {",
			"        return 0;",
			"    }",
			"    return 1 + clac(t[2], t[3]);",
			"}"
		],
		"description": "Intersection"
	},
	"hld_1": {
		"scope": "cpp",
		"prefix": "hld",
		"body": [
			"struct HLD {",
			"    std::vector<std::vector<int>> e;",
			"    std::vector<int> siz, son, cnt;",
			"    std::vector<LL> ans;",
			"    LL sum, Max;",
			"    int hson;",
			"    HLD(int n) {",
			"        e.resize(n + 1);",
			"        siz.resize(n + 1);",
			"        son.resize(n + 1);",
			"        ans.resize(n + 1);",
			"        cnt.resize(n + 1);",
			"        hson = 0;",
			"        sum = 0;",
			"        Max = 0;",
			"    }",
			"    void add(int u, int v) {",
			"        e[u].push_back(v);",
			"        e[v].push_back(u);",
			"    }",
			"    void dfs1(int u, int fa) {",
			"        siz[u] = 1;",
			"        for (auto v : e[u]) {",
			"            if (v == fa) continue;",
			"            dfs1(v, u);",
			"            siz[u] += siz[v];",
			"            if (siz[v] > siz[son[u]]) son[u] = v;",
			"        }",
			"    }",
			"    void calc(int u, int fa, int val) {",
			"        cnt[color[u]] += val;",
			"        if (cnt[color[u]] > Max) {",
			"            Max = cnt[color[u]];",
			"            sum = color[u];",
			"        } else if (cnt[color[u]] == Max) {",
			"            sum += color[u];",
			"        }",
			"        for (auto v : e[u]) {",
			"            if (v == fa || v == hson) continue;",
			"            calc(v, u, val);",
			"        }",
			"    }",
			"    void dfs2(int u, int fa, int opt) {",
			"        for (auto v : e[u]) {",
			"            if (v == fa || v == son[u]) continue;",
			"            dfs2(v, u, 0);",
			"        }",
			"        if (son[u]) {",
			"            dfs2(son[u], u, 1);",
			"            hson = son[u]; //记录重链编号，计算的时候跳过",
			"        }",
			"        calc(u, fa, 1);",
			"        hson = 0; //消除的时候所有儿子都清除",
			"        ans[u] = sum;",
			"        if (!opt) {",
			"            calc(u, fa, -1);",
			"            sum = 0;",
			"            Max = 0;",
			"        }",
			"    }",
			"};"
		],
		"description": "Hld"
	},
	"pruefer_code": {
		"scope": "cpp",
		"prefix": "pruefer_code",
		"body": [
			"// 代码摘自原文，结点是从 0 标号的",
			"std::vector<std::vector<int>> adj;",
			"",
			"std::vector<int> pruefer_code() {",
			"  int n = adj.size();",
			"  std::set<int> leafs;",
			"  std::vector<int> degree(n);",
			"  std::vector<bool> killed(n, false);",
			"  for (int i = 0; i < n; i++) {",
			"    degree[i] = adj[i].size();",
			"    if (degree[i] == 1) leafs.insert(i);",
			"  }",
			"",
			"  std::vector<int> code(n - 2);",
			"  for (int i = 0; i < n - 2; i++) {",
			"    int leaf = *leafs.begin();",
			"    leafs.erase(leafs.begin());",
			"    killed[leaf] = true;",
			"    int v;",
			"    for (int u : adj[leaf])",
			"      if (!killed[u]) v = u;",
			"    code[i] = v;",
			"    if (--degree[v] == 1) leafs.insert(v);",
			"  }",
			"  return code;",
			"}"
		],
		"description": "Pruefer Code"
	},
	"hpd_tree_1": {
		"scope": "cpp",
		"prefix": "hpd_tree",
		"body": [
			"struct HPD_tree",
			"{",
			"    int tree_size;",
			"    bool is_hpd_init = false;",
			"    std::vector<std::vector<std::pair<int, i64>>> adj;",
			"    std::vector<int> Fa, size, hson, top, rank, dfn, depth;",
			"    HPD_tree(int n = 0) {",
			"        tree_size = n;",
			"        adj.resize(tree_size + 1);",
			"    }",
			"    void add_edge(int u, int v, i64 w = 1) {",
			"        adj[u].push_back({ v,w });",
			"        adj[v].push_back({ u,w });",
			"    }",
			"    void HPD_init() {",
			"        is_hpd_init = true;",
			"        Fa.assign(tree_size + 1, 0);",
			"        size.assign(tree_size + 1, 0);",
			"        hson.assign(tree_size + 1, 0);",
			"        top.assign(tree_size + 1, 0);",
			"        rank.assign(tree_size + 1, 0);",
			"        dfn.assign(tree_size + 1, 0);",
			"        depth.assign(tree_size + 1, 0);",
			"        std::function<void(int, int, int)> dfs1 = [&](int u, int p, int d)->void {",
			"            hson[u] = 0;",
			"            size[hson[u]] = 0;",
			"            size[u] = 1;",
			"            depth[u] = d;",
			"            for (auto [v, w] : adj[u])if (v != p) {",
			"                dfs1(v, u, d + 1);",
			"                size[u] += size[v];",
			"                Fa[v] = u;",
			"                if (size[v] > size[hson[u]]) {",
			"                    hson[u] = v;",
			"                }",
			"            }",
			"            };",
			"        dfs1(1, 0, 0);",
			"        int tot = 0;",
			"        std::function<void(int, int, int)> dfs2 = [&](int u, int p, int t)->void {",
			"            top[u] = t;",
			"            dfn[u] = ++tot;",
			"            rank[tot] = u;",
			"            if (hson[u]) {",
			"                dfs2(hson[u], u, t);",
			"                for (auto [v, w] : adj[u])if (v != p && v != hson[u]) {",
			"                    dfs2(v, u, v);",
			"                }",
			"            }",
			"            };",
			"        dfs2(1, 0, 1);",
			"    }",
			"    int lca(int u, int v) {",
			"        if (!is_hpd_init)HPD_init();",
			"        while (top[u] != top[v]) {",
			"            if (depth[top[u]] > depth[top[v]])",
			"                u = Fa[top[u]];",
			"            else",
			"                v = Fa[top[v]];",
			"        }",
			"        return depth[u] > depth[v] ? v : u;",
			"    }",
			"    i64 dist(int u, int v) {",
			"        int w = lca(u, v);",
			"        return depth[u] - depth[w] + depth[v] - depth[w] + 1;",
			"    }",
			"    a3 get_diam() {",
			"        i64 cur; int pos;",
			"        std::function<void(int, int, i64)> dfs = [&](int u, int p, i64 d) {",
			"            if (d > cur) {",
			"                cur = d;",
			"                pos = u;",
			"            }",
			"            for (auto [v, dis] : adj[u])if (v != p) {",
			"                dfs(v, u, d + dis);",
			"            }",
			"            };",
			"        cur = 0, pos = 1;",
			"        dfs(pos, 0, cur);",
			"        int u = pos;",
			"        cur = 0;",
			"        dfs(pos, 0, cur);",
			"        int v = pos;",
			"        return { u,v,cur };",
			"    }",
			"};"
		],
		"description": "Hpd Tree"
	},
	"segt": {
		"scope": "cpp",
		"prefix": "segt",
		"body": [
			"struct Segt {",
			"    struct node {",
			"        int l, r, w, lazy;",
			"    };",
			"    std::vector<int> w;",
			"    std::vector<node> t;",
			"",
			"    Segt() {}",
			"    #define GL (k << 1)",
			"    #define GR (k << 1 | 1)",
			"",
			"    void init(std::vector<int> in) {",
			"        int n = in.size() - 1;",
			"        w.resize(n + 1);",
			"        for (int i = 1; i <= n; i++) {",
			"            w[i] = in[i];",
			"        }",
			"        t.resize(n * 4 + 1);",
			"        auto build = [&](auto self, int l, int r, int k = 1) {",
			"            if (l == r) {",
			"                t[k] = {l, r, w[l], 0}; // 如果有赋值为 0 的操作，则懒标记必须要 -1",
			"                return;",
			"            }",
			"            t[k] = {l, r};",
			"            int mid = (l + r) / 2;",
			"            self(self, l, mid, GL);",
			"            self(self, mid + 1, r, GR);",
			"            pushup(k);",
			"        };",
			"        build(build, 1, n);",
			"    }",
			"    void pushdown(node &p, int lazy) { /* 【在此更新下递函数】 */",
			"        p.w += (p.r - p.l + 1) * lazy;",
			"        p.lazy += lazy;",
			"    }",
			"    void pushdown(int k) { // 不需要动",
			"        if (t[k].lazy == 0) return;",
			"        pushdown(t[GL], t[k].lazy);",
			"        pushdown(t[GR], t[k].lazy);",
			"        t[k].lazy = 0;",
			"    }",
			"    void pushup(int k) { // 不需要动",
			"        auto pushup = [&](node &p, node &l, node &r) { /* 【在此更新上传函数】 */",
			"            p.w = l.w + r.w;",
			"        };",
			"        pushup(t[k], t[GL], t[GR]);",
			"    }",
			"    void modify(int l, int r, int val, int k = 1) {",
			"        if (l <= t[k].l && t[k].r <= r) {",
			"            pushdown(t[k], val);",
			"            return;",
			"        }",
			"        pushdown(k);",
			"        int mid = (t[k].l + t[k].r) / 2;",
			"        if (l <= mid) modify(l, r, val, GL);",
			"        if (mid < r) modify(l, r, val, GR);",
			"        pushup(k);",
			"    }",
			"    int ask(int l, int r, int k = 1) {",
			"        if (l <= t[k].l && t[k].r <= r) {",
			"            return t[k].w;",
			"        }",
			"        pushdown(k);",
			"        int mid = (t[k].l + t[k].r) / 2;",
			"        int ans = 0;",
			"        if (l <= mid) ans += ask(l, r, GL);",
			"        if (mid < r) ans += ask(l, r, GR);",
			"        return ans;",
			"    }",
			"};",
			"",
			"struct HLD {",
			"    int n, idx;",
			"    std::vector<std::vector<int>> ver;",
			"    std::vector<int> siz, dep;",
			"    std::vector<int> top, son, parent;",
			"    std::vector<int> in, id, val;",
			"    Segt segt;",
			"",
			"    HLD(int n) {",
			"        this->n = n;",
			"        ver.resize(n + 1);",
			"        siz.resize(n + 1);",
			"        dep.resize(n + 1);",
			"",
			"        top.resize(n + 1);",
			"        son.resize(n + 1);",
			"        parent.resize(n + 1);",
			"",
			"        idx = 0;",
			"        in.resize(n + 1);",
			"        id.resize(n + 1);",
			"        val.resize(n + 1);",
			"    }",
			"    void add(int x, int y) { // 建立双向边",
			"        ver[x].push_back(y);",
			"        ver[y].push_back(x);",
			"    }",
			"    void dfs1(int x) {",
			"        siz[x] = 1;",
			"        dep[x] = dep[parent[x]] + 1;",
			"        for (auto y : ver[x]) {",
			"            if (y == parent[x]) continue;",
			"            parent[y] = x;",
			"            dfs1(y);",
			"            siz[x] += siz[y];",
			"            if (siz[y] > siz[son[x]]) {",
			"                son[x] = y;",
			"            }",
			"        }",
			"    }",
			"    void dfs2(int x, int up) {",
			"        id[x] = ++idx;",
			"        val[idx] = in[x]; // 建立编号",
			"        top[x] = up;",
			"        if (son[x]) dfs2(son[x], up);",
			"        for (auto y : ver[x]) {",
			"            if (y == parent[x] || y == son[x]) continue;",
			"            dfs2(y, y);",
			"        }",
			"    }",
			"    void modify(int l, int r, int val) { // 链上修改",
			"        while (top[l] != top[r]) {",
			"            if (dep[top[l]] < dep[top[r]]) {",
			"                std::swap(l, r);",
			"            }",
			"            segt.modify(id[top[l]], id[l], val);",
			"            l = parent[top[l]];",
			"        }",
			"        if (dep[l] > dep[r]) {",
			"            std::swap(l, r);",
			"        }",
			"        segt.modify(id[l], id[r], val);",
			"    }",
			"    void modify(int root, int val) { // 子树修改",
			"        segt.modify(id[root], id[root] + siz[root] - 1, val);",
			"    }",
			"    int ask(int l, int r) { // 链上查询",
			"        int ans = 0;",
			"        while (top[l] != top[r]) {",
			"            if (dep[top[l]] < dep[top[r]]) {",
			"                std::swap(l, r);",
			"            }",
			"            ans += segt.ask(id[top[l]], id[l]);",
			"            l = parent[top[l]];",
			"        }",
			"        if (dep[l] > dep[r]) {",
			"            std::swap(l, r);",
			"        }",
			"        return ans + segt.ask(id[l], id[r]);",
			"    }",
			"    int ask(int root) { // 子树查询",
			"        return segt.ask(id[root], id[root] + siz[root] - 1);",
			"    }",
			"    void work(auto in, int root = 1) { // 在此初始化",
			"        assert(in.size() == n + 1);",
			"        this->in = in;",
			"        dfs1(root);",
			"        dfs2(root, root);",
			"        segt.init(val); // 建立线段树",
			"    }",
			"    void work(int root = 1) { // 在此初始化",
			"        dfs1(root);",
			"        dfs2(root, root);",
			"        segt.init(val); // 建立线段树",
			"    }",
			"};"
		],
		"description": "Segt"
	},
	"flow_": {
		"scope": "cpp",
		"prefix": "flow_",
		"body": [
			"template<typename T> struct Flow_ {",
			"    const int n;",
			"    const T inf = numeric_limits<T>::std::max();",
			"    struct Edge {",
			"        int to;",
			"        T w;",
			"        Edge(int to, T w) : to(to), w(w) {}",
			"    };",
			"    std::vector<Edge> ver;",
			"    std::vector<std::vector<int>> h;",
			"    std::vector<int> cur, d;",
			"",
			"    Flow_(int n) : n(n + 1), h(n + 1) {}",
			"    void add(int u, int v, T c) {",
			"        h[u].push_back(ver.size());",
			"        ver.emplace_back(v, c);",
			"        h[v].push_back(ver.size());",
			"        ver.emplace_back(u, 0);",
			"    }",
			"    bool bfs(int s, int t) {",
			"        d.assign(n, -1);",
			"        d[s] = 0;",
			"        std::queue<int> q;",
			"        q.push(s);",
			"        while (!q.empty()) {",
			"            auto x = q.front();",
			"            q.pop();",
			"            for (auto it : h[x]) {",
			"                auto [y, w] = ver[it];",
			"                if (w && d[y] == -1) {",
			"                    d[y] = d[x] + 1;",
			"                    if (y == t) return true;",
			"                    q.push(y);",
			"                }",
			"            }",
			"        }",
			"        return false;",
			"    }",
			"    T dfs(int u, int t, T f) {",
			"        if (u == t) return f;",
			"        auto r = f;",
			"        for (int &i = cur[u]; i < h[u].size(); i++) {",
			"            auto j = h[u][i];",
			"            auto &[v, c] = ver[j];",
			"            auto &[u, rc] = ver[j ^ 1];",
			"            if (c && d[v] == d[u] + 1) {",
			"                auto a = dfs(v, t, std::min(r, c));",
			"                c -= a;",
			"                rc += a;",
			"                r -= a;",
			"                if (!r) return f;",
			"            }",
			"        }",
			"        return f - r;",
			"    }",
			"    T work(int s, int t) {",
			"        T ans = 0;",
			"        while (bfs(s, t)) {",
			"            cur.assign(n, 0);",
			"            ans += dfs(s, t, inf);",
			"        }",
			"        return ans;",
			"    }",
			"};",
			"using Flow = Flow_<int>;"
		],
		"description": "Flow "
	},
	"pushrelabel": {
		"scope": "cpp",
		"prefix": "pushrelabel",
		"body": [
			"template<typename T> struct PushRelabel {",
			"    const int inf = 0x3f3f3f3f;",
			"    const T INF = 0x3f3f3f3f3f3f3f3f;",
			"    struct Edge {",
			"        int to, cap, flow, anti;",
			"        Edge(int v = 0, int w = 0, int id = 0) : to(v), cap(w), flow(0), anti(id) {}",
			"    };",
			"    std::vector<std::vector<Edge>> e;",
			"    std::vector<std::vector<int>> gap;",
			"    std::vector<T> ex; // 超额流",
			"    std::vector<bool> ingap;",
			"    std::vector<int> h;",
			"    int n, gobalcnt, maxH = 0;",
			"    T maxflow = 0;",
			"",
			"    PushRelabel(int n) : n(n), e(n + 1), ex(n + 1), gap(n + 1) {}",
			"    void addedge(int u, int v, int w) {",
			"        e[u].push_back({v, w, (int)e[v].size()});",
			"        e[v].push_back({u, 0, (int)e[u].size() - 1});",
			"    }",
			"    void PushEdge(int u, Edge &edge) {",
			"        int v = edge.to, d = std::min(ex[u], 1LL * edge.cap - edge.flow);",
			"        ex[u] -= d;",
			"        ex[v] += d;",
			"        edge.flow += d;",
			"        e[v][edge.anti].flow -= d;",
			"        if (h[v] != inf && d > 0 && ex[v] == d && !ingap[v]) {",
			"            ++gobalcnt;",
			"            gap[h[v]].push_back(v);",
			"            ingap[v] = 1;",
			"        }",
			"    }",
			"    void PushPoint(int u) {",
			"        for (auto k = e[u].begin(); k != e[u].end(); k++) {",
			"            if (h[k->to] + 1 == h[u] && k->cap > k->flow) {",
			"                PushEdge(u, *k);",
			"                if (!ex[u]) break;",
			"            }",
			"        }",
			"        if (!ex[u]) return;",
			"        if (gap[h[u]].empty()) {",
			"            for (int i = h[u] + 1; i <= std::min(maxH, n); i++) {",
			"                for (auto v : gap[i]) {",
			"                    ingap[v] = 0;",
			"                }",
			"                gap[i].clear();",
			"            }",
			"        }",
			"        h[u] = inf;",
			"        for (auto [to, cap, flow, anti] : e[u]) {",
			"            if (cap > flow) {",
			"                h[u] = std::min(h[u], h[to] + 1);",
			"            }",
			"        }",
			"        if (h[u] >= n) return;",
			"        maxH = std::max(maxH, h[u]);",
			"        if (!ingap[u]) {",
			"            gap[h[u]].push_back(u);",
			"            ingap[u] = 1;",
			"        }",
			"    }",
			"    void init(int t, bool f = 1) {",
			"        ingap.assign(n + 1, 0);",
			"        for (int i = 1; i <= maxH; i++) {",
			"            gap[i].clear();",
			"        }",
			"        gobalcnt = 0, maxH = 0;",
			"        std::queue<int> q;",
			"        h.assign(n + 1, inf);",
			"        h[t] = 0, q.push(t);",
			"        while (q.size()) {",
			"            int u = q.front();",
			"            q.pop(), maxH = h[u];",
			"            for (auto &[v, cap, flow, anti] : e[u]) {",
			"                if (h[v] == inf && e[v][anti].cap > e[v][anti].flow) {",
			"                    h[v] = h[u] + 1;",
			"                    q.push(v);",
			"                    if (f) {",
			"                        gap[h[v]].push_back(v);",
			"                        ingap[v] = 1;",
			"                    }",
			"                }",
			"            }",
			"        }",
			"    }",
			"    T work(int s, int t) {",
			"        init(t, 0);",
			"        if (h[s] == inf) return maxflow;",
			"        h[s] = n;",
			"        ex[s] = INF;",
			"        ex[t] = -INF;",
			"        for (auto k = e[s].begin(); k != e[s].end(); k++) {",
			"            PushEdge(s, *k);",
			"        }",
			"        while (maxH > 0) {",
			"            if (gap[maxH].empty()) {",
			"                maxH--;",
			"                continue;",
			"            }",
			"            int u = gap[maxH].back();",
			"            gap[maxH].pop_back();",
			"            ingap[u] = 0;",
			"            PushPoint(u);",
			"            if (gobalcnt >= 10 * n) {",
			"                init(t);",
			"            }",
			"        }",
			"        ex[s] -= INF;",
			"        ex[t] += INF;",
			"        return maxflow = ex[t];",
			"    }",
			"};"
		],
		"description": "Pushrelabel"
	},
	"code_3": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"signed main() {",
			"    int n, m;",
			"    std::cin >> n >> m;",
			"",
			"    int S = n + m + 1, T = n + m + 2;",
			"    Flow flow(T);",
			"    for (int i = 1; i <= n; i++) {",
			"        int w;",
			"        std::cin >> w;",
			"        flow.add(S, i, w);",
			"    }",
			"",
			"    int sum = 0;",
			"    for (int i = 1; i <= m; i++) {",
			"        int x, y, w;",
			"        std::cin >> x >> y >> w;",
			"        flow.add(x, n + i, 1E18);",
			"        flow.add(y, n + i, 1E18);",
			"        flow.add(n + i, T, w);",
			"        sum += w;",
			"    }",
			"    std::cout << sum - flow.work(S, T) << std::endl;",
			"}"
		],
		"description": "Code"
	},
	"reset": {
		"scope": "cpp",
		"prefix": "reset",
		"body": [
			"void reset() { // struct需要额外封装退流",
			"    for (int i = 0; i < ver.size(); i += 2) {",
			"        ver[i].w += ver[i ^ 1].w;",
			"        ver[i ^ 1].w = 0;",
			"    }",
			"}",
			"",
			"signed main() { // Gomory-Hu Tree",
			"    int n, m;",
			"    std::cin >> n >> m;",
			"",
			"    Flow<int> flow(n);",
			"    for (int i = 1; i <= m; i++) {",
			"        int u, v, w;",
			"        std::cin >> u >> v >> w;",
			"        flow.add(u, v, w);",
			"        flow.add(v, u, w);",
			"    }",
			"",
			"    std::vector<int> vis(n + 1), fa(n + 1);",
			"    std::vector ans(n + 1, std::vector<int>(n + 1, 1E9)); // N^2 枚举出全部答案",
			"    std::vector<std::vector<std::pair<int, int>>> adj(n + 1);",
			"    for (int i = 1; i <= n; i++) { // 分治 n 轮",
			"        int s = 0; // 本质是在树上随机选点、跑最小割后连边",
			"        for (; s <= n; s++) {",
			"            if (fa[s] != s) break;",
			"        }",
			"        int t = fa[s];",
			"",
			"        int ans = flow.work(s, t); // 残留网络将点集分为两组，分治",
			"        adj[s].push_back({t, ans});",
			"        adj[t].push_back({s, ans});",
			"",
			"        vis.assign(n + 1, 0);",
			"        auto dfs = [&](auto dfs, int u) -> void {",
			"            vis[u] = 1;",
			"            for (auto it : flow.h[u]) {",
			"                auto [v, c] = flow.ver[it];",
			"                if (c && !vis[v]) {",
			"                    dfs(dfs, v);",
			"                }",
			"            }",
			"        };",
			"        dfs(dfs, s);",
			"        for (int j = 0; j <= n; j++) {",
			"            if (vis[j] && fa[j] == t) {",
			"                fa[j] = s;",
			"            }",
			"        }",
			"    }",
			"",
			"    for (int i = 0; i <= n; i++) {",
			"        auto dfs = [&](auto dfs, int u, int fa, int c) -> void {",
			"            ans[i][u] = c;",
			"            for (auto [v, w] : adj[u]) {",
			"                if (v == fa) continue;",
			"                dfs(dfs, v, u, std::min(c, w));",
			"            }",
			"        };",
			"        dfs(dfs, i, -1, 1E9);",
			"    }",
			"",
			"    int q;",
			"    std::cin >> q;",
			"    while (q--) {",
			"        int u, v;",
			"        std::cin >> u >> v;",
			"        cout << ans[u][v] << \"\\n\"; // 预处理答数组",
			"    }",
			"}"
		],
		"description": "Reset"
	},
	"mincostflow": {
		"scope": "cpp",
		"prefix": "mincostflow",
		"body": [
			"struct MinCostFlow {",
			"    using LL = long long;",
			"    using PII = std::pair<LL, int>;",
			"    const LL INF = numeric_limits<LL>::std::max();",
			"    struct Edge {",
			"        int v, c, f;",
			"        Edge(int v, int c, int f) : v(v), c(c), f(f) {}",
			"    };",
			"    const int n;",
			"    std::vector<Edge> e;",
			"    std::vector<std::vector<int>> g;",
			"    std::vector<LL> h, dis;",
			"    std::vector<int> pre;",
			"",
			"    MinCostFlow(int n) : n(n), g(n) {}",
			"    void add(int u, int v, int c, int f) { // c 流量, f 费用",
			"        // if (f < 0) {",
			"        //     g[u].push_back(e.size());",
			"        //     e.emplace_back(v, 0, f);",
			"        //     g[v].push_back(e.size());",
			"        //     e.emplace_back(u, c, -f);",
			"        // } else {",
			"            g[u].push_back(e.size());",
			"            e.emplace_back(v, c, f);",
			"            g[v].push_back(e.size());",
			"            e.emplace_back(u, 0, -f);",
			"        // }",
			"    }",
			"    bool dijkstra(int s, int t) {",
			"        dis.assign(n, INF);",
			"        pre.assign(n, -1);",
			"        std::priority_queue<PII, std::vector<PII>, greater<PII>> que;",
			"        dis[s] = 0;",
			"        que.emplace(0, s);",
			"        while (!que.empty()) {",
			"            auto [d, u] = que.top();",
			"            que.pop();",
			"            if (dis[u] < d) continue;",
			"            for (int i : g[u]) {",
			"                auto [v, c, f] = e[i];",
			"                if (c > 0 && dis[v] > d + h[u] - h[v] + f) {",
			"                    dis[v] = d + h[u] - h[v] + f;",
			"                    pre[v] = i;",
			"                    que.emplace(dis[v], v);",
			"                }",
			"            }",
			"        }",
			"        return dis[t] != INF;",
			"    }",
			"    std::pair<int, LL> flow(int s, int t) {",
			"        int flow = 0;",
			"        LL cost = 0;",
			"        h.assign(n, 0);",
			"        while (dijkstra(s, t)) {",
			"            for (int i = 0; i < n; ++i) h[i] += dis[i];",
			"            int aug = numeric_limits<int>::std::max();",
			"            for (int i = t; i != s; i = e[pre[i] ^ 1].v) aug = std::min(aug, e[pre[i]].c);",
			"            for (int i = t; i != s; i = e[pre[i] ^ 1].v) {",
			"                e[pre[i]].c -= aug;",
			"                e[pre[i] ^ 1].c += aug;",
			"            }",
			"            flow += aug;",
			"            cost += LL(aug) * h[t];",
			"        }",
			"        return {flow, cost};",
			"    }",
			"};"
		],
		"description": "Mincostflow"
	}
}
