{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Poly": {
		"scope": "cpp",
		"prefix": "Poly",
		"body": [
			"",
			"template<class T>",
			"constexpr T power(T a, i64 b) {",
			"    T res = 1;",
			"    for (; b; b /= 2, a *= a) {",
			"        if (b % 2) {",
			"            res *= a;",
			"        }",
			"    }",
			"    return res;",
			"}",
			"",
			"template<int P>",
			"struct MInt {",
			"    int x;",
			"    constexpr MInt() : x{} {}",
			"    constexpr MInt(i64 x) : x{norm(x % getMod())} {}",
			"    ",
			"    static int Mod;",
			"    constexpr static int getMod() {",
			"        if (P > 0) {",
			"            return P;",
			"        } else {",
			"            return Mod;",
			"        }",
			"    }",
			"    constexpr static void setMod(int Mod_) {",
			"        Mod = Mod_;",
			"    }",
			"    constexpr int norm(int x) const {",
			"        if (x < 0) {",
			"            x += getMod();",
			"        }",
			"        if (x >= getMod()) {",
			"            x -= getMod();",
			"        }",
			"        return x;",
			"    }",
			"    constexpr int val() const {",
			"        return x;",
			"    }",
			"    explicit constexpr operator int() const {",
			"        return x;",
			"    }",
			"    constexpr MInt operator-() const {",
			"        MInt res;",
			"        res.x = norm(getMod() - x);",
			"        return res;",
			"    }",
			"    constexpr MInt inv() const {",
			"        assert(x != 0);",
			"        return power(*this, getMod() - 2);",
			"    }",
			"    constexpr MInt &operator*=(MInt rhs) & {",
			"        x = 1LL * x * rhs.x % getMod();",
			"        return *this;",
			"    }",
			"    constexpr MInt &operator+=(MInt rhs) & {",
			"        x = norm(x + rhs.x);",
			"        return *this;",
			"    }",
			"    constexpr MInt &operator-=(MInt rhs) & {",
			"        x = norm(x - rhs.x);",
			"        return *this;",
			"    }",
			"    constexpr MInt &operator/=(MInt rhs) & {",
			"        return *this *= rhs.inv();",
			"    }",
			"    friend constexpr MInt operator*(MInt lhs, MInt rhs) {",
			"        MInt res = lhs;",
			"        res *= rhs;",
			"        return res;",
			"    }",
			"    friend constexpr MInt operator+(MInt lhs, MInt rhs) {",
			"        MInt res = lhs;",
			"        res += rhs;",
			"        return res;",
			"    }",
			"    friend constexpr MInt operator-(MInt lhs, MInt rhs) {",
			"        MInt res = lhs;",
			"        res -= rhs;",
			"        return res;",
			"    }",
			"    friend constexpr MInt operator/(MInt lhs, MInt rhs) {",
			"        MInt res = lhs;",
			"        res /= rhs;",
			"        return res;",
			"    }",
			"    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {",
			"        i64 v;",
			"        is >> v;",
			"        a = MInt(v);",
			"        return is;",
			"    }",
			"    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {",
			"        return os << a.val();",
			"    }",
			"    friend constexpr bool operator==(MInt lhs, MInt rhs) {",
			"        return lhs.val() == rhs.val();",
			"    }",
			"    friend constexpr bool operator!=(MInt lhs, MInt rhs) {",
			"        return lhs.val() != rhs.val();",
			"    }",
			"};",
			"",
			"template<>",
			"int MInt<0>::Mod = 1;",
			"",
			"template<int V, int P>",
			"constexpr MInt<P> CInv = MInt<P>(V).inv();",
			"",
			"constexpr int P = 998244353;",
			"using Z = MInt<P>;",
			"",
			"std::vector<int> rev;",
			"template<int P>",
			"std::vector<MInt<P>> roots{0, 1};",
			"",
			"template<int P>",
			"constexpr MInt<P> findPrimitiveRoot() {",
			"    MInt<P> i = 2;",
			"    int k = __builtin_ctz(P - 1);",
			"    while (true) {",
			"        if (power(i, (P - 1) / 2) != 1) {",
			"            break;",
			"        }",
			"        i += 1;",
			"    }",
			"    return power(i, (P - 1) >> k);",
			"}",
			"",
			"template<int P>",
			"constexpr MInt<P> primitiveRoot = findPrimitiveRoot<P>();",
			"",
			"template<>",
			"constexpr MInt<998244353> primitiveRoot<998244353> {31};",
			"",
			"template<int P>",
			"constexpr void dft(std::vector<MInt<P>> &a) {",
			"    int n = a.size();",
			"    ",
			"    if (int(rev.size()) != n) {",
			"        int k = __builtin_ctz(n) - 1;",
			"        rev.resize(n);",
			"        for (int i = 0; i < n; i++) {",
			"            rev[i] = rev[i >> 1] >> 1 | (i & 1) << k;",
			"        }",
			"    }",
			"    ",
			"    for (int i = 0; i < n; i++) {",
			"        if (rev[i] < i) {",
			"            std::swap(a[i], a[rev[i]]);",
			"        }",
			"    }",
			"    if (roots<P>.size() < n) {",
			"        int k = __builtin_ctz(roots<P>.size());",
			"        roots<P>.resize(n);",
			"        while ((1 << k) < n) {",
			"            auto e = power(primitiveRoot<P>, 1 << (__builtin_ctz(P - 1) - k - 1));",
			"            for (int i = 1 << (k - 1); i < (1 << k); i++) {",
			"                roots<P>[2 * i] = roots<P>[i];",
			"                roots<P>[2 * i + 1] = roots<P>[i] * e;",
			"            }",
			"            k++;",
			"        }",
			"    }",
			"    for (int k = 1; k < n; k *= 2) {",
			"        for (int i = 0; i < n; i += 2 * k) {",
			"            for (int j = 0; j < k; j++) {",
			"                MInt<P> u = a[i + j];",
			"                MInt<P> v = a[i + j + k] * roots<P>[k + j];",
			"                a[i + j] = u + v;",
			"                a[i + j + k] = u - v;",
			"            }",
			"        }",
			"    }",
			"}",
			"",
			"template<int P>",
			"constexpr void idft(std::vector<MInt<P>> &a) {",
			"    int n = a.size();",
			"    std::reverse(a.begin() + 1, a.end());",
			"    dft(a);",
			"    MInt<P> inv = (1 - P) / n;",
			"    for (int i = 0; i < n; i++) {",
			"        a[i] *= inv;",
			"    }",
			"}",
			"",
			"template<int P = 998244353>",
			"struct Poly : public std::vector<MInt<P>> {",
			"    using Value = MInt<P>;",
			"    ",
			"    Poly() : std::vector<Value>() {}",
			"    explicit constexpr Poly(int n) : std::vector<Value>(n) {}",
			"    ",
			"    explicit constexpr Poly(const std::vector<Value> &a) : std::vector<Value>(a) {}",
			"    constexpr Poly(const std::initializer_list<Value> &a) : std::vector<Value>(a) {}",
			"    ",
			"    template<class InputIt, class = std::_RequireInputIter<InputIt>>",
			"    explicit constexpr Poly(InputIt first, InputIt last) : std::vector<Value>(first, last) {}",
			"    ",
			"    template<class F>",
			"    explicit constexpr Poly(int n, F f) : std::vector<Value>(n) {",
			"        for (int i = 0; i < n; i++) {",
			"            (*this)[i] = f(i);",
			"        }",
			"    }",
			"    ",
			"    constexpr Poly shift(int k) const {",
			"        if (k >= 0) {",
			"            auto b = *this;",
			"            b.insert(b.begin(), k, 0);",
			"            return b;",
			"        } else if (this->size() <= -k) {",
			"            return Poly();",
			"        } else {",
			"            return Poly(this->begin() + (-k), this->end());",
			"        }",
			"    }",
			"    constexpr Poly trunc(int k) const {",
			"        Poly f = *this;",
			"        f.resize(k);",
			"        return f;",
			"    }",
			"    constexpr friend Poly operator+(const Poly &a, const Poly &b) {",
			"        Poly res(std::max(a.size(), b.size()));",
			"        for (int i = 0; i < a.size(); i++) {",
			"            res[i] += a[i];",
			"        }",
			"        for (int i = 0; i < b.size(); i++) {",
			"            res[i] += b[i];",
			"        }",
			"        return res;",
			"    }",
			"    constexpr friend Poly operator-(const Poly &a, const Poly &b) {",
			"        Poly res(std::max(a.size(), b.size()));",
			"        for (int i = 0; i < a.size(); i++) {",
			"            res[i] += a[i];",
			"        }",
			"        for (int i = 0; i < b.size(); i++) {",
			"            res[i] -= b[i];",
			"        }",
			"        return res;",
			"    }",
			"    constexpr friend Poly operator-(const Poly &a) {",
			"        std::vector<Value> res(a.size());",
			"        for (int i = 0; i < int(res.size()); i++) {",
			"            res[i] = -a[i];",
			"        }",
			"        return Poly(res);",
			"    }",
			"    constexpr friend Poly operator*(Poly a, Poly b) {",
			"        if (a.size() == 0 || b.size() == 0) {",
			"            return Poly();",
			"        }",
			"        if (a.size() < b.size()) {",
			"            std::swap(a, b);",
			"        }",
			"        int n = 1, tot = a.size() + b.size() - 1;",
			"        while (n < tot) {",
			"            n *= 2;",
			"        }",
			"        if (((P - 1) & (n - 1)) != 0 || b.size() < 128) {",
			"            Poly c(a.size() + b.size() - 1);",
			"            for (int i = 0; i < a.size(); i++) {",
			"                for (int j = 0; j < b.size(); j++) {",
			"                    c[i + j] += a[i] * b[j];",
			"                }",
			"            }",
			"            return c;",
			"        }",
			"        a.resize(n);",
			"        b.resize(n);",
			"        dft(a);",
			"        dft(b);",
			"        for (int i = 0; i < n; ++i) {",
			"            a[i] *= b[i];",
			"        }",
			"        idft(a);",
			"        a.resize(tot);",
			"        return a;",
			"    }",
			"    constexpr friend Poly operator*(Value a, Poly b) {",
			"        for (int i = 0; i < int(b.size()); i++) {",
			"            b[i] *= a;",
			"        }",
			"        return b;",
			"    }",
			"    constexpr friend Poly operator*(Poly a, Value b) {",
			"        for (int i = 0; i < int(a.size()); i++) {",
			"            a[i] *= b;",
			"        }",
			"        return a;",
			"    }",
			"    constexpr friend Poly operator/(Poly a, Value b) {",
			"        for (int i = 0; i < int(a.size()); i++) {",
			"            a[i] /= b;",
			"        }",
			"        return a;",
			"    }",
			"    constexpr Poly &operator+=(Poly b) {",
			"        return (*this) = (*this) + b;",
			"    }",
			"    constexpr Poly &operator-=(Poly b) {",
			"        return (*this) = (*this) - b;",
			"    }",
			"    constexpr Poly &operator*=(Poly b) {",
			"        return (*this) = (*this) * b;",
			"    }",
			"    constexpr Poly &operator*=(Value b) {",
			"        return (*this) = (*this) * b;",
			"    }",
			"    constexpr Poly &operator/=(Value b) {",
			"        return (*this) = (*this) / b;",
			"    }",
			"    constexpr Poly deriv() const {",
			"        if (this->empty()) {",
			"            return Poly();",
			"        }",
			"        Poly res(this->size() - 1);",
			"        for (int i = 0; i < this->size() - 1; ++i) {",
			"            res[i] = (i + 1) * (*this)[i + 1];",
			"        }",
			"        return res;",
			"    }",
			"    constexpr Poly integr() const {",
			"        Poly res(this->size() + 1);",
			"        for (int i = 0; i < this->size(); ++i) {",
			"            res[i + 1] = (*this)[i] / (i + 1);",
			"        }",
			"        return res;",
			"    }",
			"    constexpr Poly inv(int m) const {",
			"        Poly x{(*this)[0].inv()};",
			"        int k = 1;",
			"        while (k < m) {",
			"            k *= 2;",
			"            x = (x * (Poly{2} - trunc(k) * x)).trunc(k);",
			"        }",
			"        return x.trunc(m);",
			"    }",
			"    constexpr Poly log(int m) const {",
			"        return (deriv() * inv(m)).integr().trunc(m);",
			"    }",
			"    constexpr Poly exp(int m) const {",
			"        Poly x{1};",
			"        int k = 1;",
			"        while (k < m) {",
			"            k *= 2;",
			"            x = (x * (Poly{1} - x.log(k) + trunc(k))).trunc(k);",
			"        }",
			"        return x.trunc(m);",
			"    }",
			"    constexpr Poly pow(int k, int m) const {",
			"        int i = 0;",
			"        while (i < this->size() && (*this)[i] == 0) {",
			"            i++;",
			"        }",
			"        if (i == this->size() || 1LL * i * k >= m) {",
			"            return Poly(m);",
			"        }",
			"        Value v = (*this)[i];",
			"        auto f = shift(-i) * v.inv();",
			"        return (f.log(m - i * k) * k).exp(m - i * k).shift(i * k) * power(v, k);",
			"    }",
			"    constexpr Poly sqrt(int m) const {",
			"        Poly x{1};",
			"        int k = 1;",
			"        while (k < m) {",
			"            k *= 2;",
			"            x = (x + (trunc(k) * x.inv(k)).trunc(k)) * CInv<2, P>;",
			"        }",
			"        return x.trunc(m);",
			"    }",
			"    constexpr Poly mulT(Poly b) const {",
			"        if (b.size() == 0) {",
			"            return Poly();",
			"        }",
			"        int n = b.size();",
			"        std::reverse(b.begin(), b.end());",
			"        return ((*this) * b).shift(-(n - 1));",
			"    }",
			"    constexpr std::vector<Value> eval(std::vector<Value> x) const {",
			"        if (this->size() == 0) {",
			"            return std::vector<Value>(x.size(), 0);",
			"        }",
			"        const int n = std::max(x.size(), this->size());",
			"        std::vector<Poly> q(4 * n);",
			"        std::vector<Value> ans(x.size());",
			"        x.resize(n);",
			"        std::function<void(int, int, int)> build = [&](int p, int l, int r) {",
			"            if (r - l == 1) {",
			"                q[p] = Poly{1, -x[l]};",
			"            } else {",
			"                int m = (l + r) / 2;",
			"                build(2 * p, l, m);",
			"                build(2 * p + 1, m, r);",
			"                q[p] = q[2 * p] * q[2 * p + 1];",
			"            }",
			"        };",
			"        build(1, 0, n);",
			"        std::function<void(int, int, int, const Poly &)> work = [&](int p, int l, int r, const Poly &num) {",
			"            if (r - l == 1) {",
			"                if (l < int(ans.size())) {",
			"                    ans[l] = num[0];",
			"                }",
			"            } else {",
			"                int m = (l + r) / 2;",
			"                work(2 * p, l, m, num.mulT(q[2 * p + 1]).trunc(m - l));",
			"                work(2 * p + 1, m, r, num.mulT(q[2 * p]).trunc(r - m));",
			"            }",
			"        };",
			"        work(1, 0, n, mulT(q[1].inv(n)));",
			"        return ans;",
			"    }",
			"};",
			"",
			"template<int P = 998244353>",
			"Poly<P> berlekampMassey(const Poly<P> &s) {",
			"    Poly<P> c;",
			"    Poly<P> oldC;",
			"    int f = -1;",
			"    for (int i = 0; i < s.size(); i++) {",
			"        auto delta = s[i];",
			"        for (int j = 1; j <= c.size(); j++) {",
			"            delta -= c[j - 1] * s[i - j];",
			"        }",
			"        if (delta == 0) {",
			"            continue;",
			"        }",
			"        if (f == -1) {",
			"            c.resize(i + 1);",
			"            f = i;",
			"        } else {",
			"            auto d = oldC;",
			"            d *= -1;",
			"            d.insert(d.begin(), 1);",
			"            MInt<P> df1 = 0;",
			"            for (int j = 1; j <= d.size(); j++) {",
			"                df1 += d[j - 1] * s[f + 1 - j];",
			"            }",
			"            assert(df1 != 0);",
			"            auto coef = delta / df1;",
			"            d *= coef;",
			"            Poly<P> zeros(i - f - 1);",
			"            zeros.insert(zeros.end(), d.begin(), d.end());",
			"            d = zeros;",
			"            auto temp = c;",
			"            c += d;",
			"            if (i - temp.size() > f - oldC.size()) {",
			"                oldC = temp;",
			"                f = i;",
			"            }",
			"        }",
			"    }",
			"    c *= -1;",
			"    c.insert(c.begin(), 1);",
			"    return c;",
			"}",
			"",
			"",
			"template<int P = 998244353>",
			"MInt<P> linearRecurrence(Poly<P> p, Poly<P> q, i64 n) {",
			"    int m = q.size() - 1;",
			"    while (n > 0) {",
			"        auto newq = q;",
			"        for (int i = 1; i <= m; i += 2) {",
			"            newq[i] *= -1;",
			"        }",
			"        auto newp = p * newq;",
			"        newq = q * newq;",
			"        for (int i = 0; i < m; i++) {",
			"            p[i] = newp[i * 2 + n % 2];",
			"        }",
			"        for (int i = 0; i <= m; i++) {",
			"            q[i] = newq[i * 2];",
			"        }",
			"        n /= 2;",
			"    }",
			"    return p[0] / q[0];",
			"}",
			""
		],
		"description": "Poly"
	},
	"line": {
		"scope": "cpp",
		"prefix": "line",
		"body": [
			"struct Line {",
			"  i64 a, b, r;",
			"  bool operator<(Line l) { return std::pair(a, b) > std::pair(l.a, l.b); }",
			"  bool operator<(i64 x) { return r < x; }",
			"};",
			"struct Lines : std::vector<Line> {",
			"  static constexpr i64 inf = numeric_limits<i64>::std::max();",
			"  Lines(i64 a, i64 b) : std::vector<Line>{{a, b, inf}} {}",
			"  Lines(std::vector<Line>& lines) {",
			"    if (not ranges::is_sorted(lines, less())) ranges::std::sort(lines, less());",
			"    for (auto [a, b, _] : lines) {",
			"      for (; not empty(); pop_back()) {",
			"        if (back().a == a) continue;",
			"        i64 da = back().a - a, db = b - back().b;",
			"        back().r = db / da - (db < 0 and db % da);",
			"        if (size() == 1 or back().r > end()[-2].r) break;",
			"      }",
			"      emplace_back(a, b, inf);",
			"    }",
			"  }",
			"  Lines operator+(Lines& lines) {",
			"    std::vector<Line> res(size() + lines.size());",
			"    ranges::merge(*this, lines, res.begin(), less());",
			"    return Lines(res);",
			"  }",
			"  i64 std::min(i64 x) {",
			"    auto [a, b, _] = *std::lower_bound(begin(), end(), x, less());",
			"    return a * x + b;",
			"  }",
			"};"
		],
		"description": "Line"
	},
	"poly": {
		"scope": "cpp",
		"prefix": "poly",
		"body": [
			"template<int P = 998244353> struct Poly : public std::vector<MInt<P>> {",
			"    using Value = MInt<P>;",
			"",
			"    Poly() : std::vector<Value>() {}",
			"    explicit constexpr Poly(int n) : std::vector<Value>(n) {}",
			"",
			"    explicit constexpr Poly(const std::vector<Value> &a) : std::vector<Value>(a) {}",
			"    constexpr Poly(const initializer_list<Value> &a) : std::vector<Value>(a) {}",
			"",
			"    template<typename InputIt, typename = _RequireInputIter<InputIt>>",
			"    explicit constexpr Poly(InputIt first, InputIt last) : std::vector<Value>(first, last) {}",
			"",
			"    template<typename F> F>plicit constexpr Poly(int n, F f) : std::vector<Value>(n) {",
			"        for (int i = 0; i < n; i++) {",
			"            (*this)[i] = f(i);",
			"        }",
			"    }",
			"",
			"    constexpr Poly shift(int k) const {",
			"        if (k >= 0) {",
			"            auto b = *this;",
			"            b.insert(b.begin(), k, 0);",
			"            return b;",
			"        } else if (this->size() <= -k) {",
			"            return Poly();",
			"        } else {",
			"            return Poly(this->begin() + (-k), this->end());",
			"        }",
			"    }",
			"    constexpr Poly std::trunc(int k) const {",
			"        Poly f = *this;",
			"        f.resize(k);",
			"        return f;",
			"    }",
			"    constexpr friend Poly operator+(const Poly &a, const Poly &b) {",
			"        Poly res(std::max(a.size(), b.size()));",
			"        for (int i = 0; i < a.size(); i++) {",
			"            res[i] += a[i];",
			"        }",
			"        for (int i = 0; i < b.size(); i++) {",
			"            res[i] += b[i];",
			"        }",
			"        return res;",
			"    }",
			"    constexpr friend Poly operator-(const Poly &a, const Poly &b) {",
			"        Poly res(std::max(a.size(), b.size()));",
			"        for (int i = 0; i < a.size(); i++) {",
			"            res[i] += a[i];",
			"        }",
			"        for (int i = 0; i < b.size(); i++) {",
			"            res[i] -= b[i];",
			"        }",
			"        return res;",
			"    }",
			"    constexpr friend Poly operator-(const Poly &a) {",
			"        std::vector<Value> res(a.size());",
			"        for (int i = 0; i < int(res.size()); i++) {",
			"            res[i] = -a[i];",
			"        }",
			"        return Poly(res);",
			"    }",
			"    constexpr friend Poly operator*(Poly a, Poly b) {",
			"        if (a.size() == 0 || b.size() == 0) {",
			"            return Poly();",
			"        }",
			"        if (a.size() < b.size()) {",
			"            std::swap(a, b);",
			"        }",
			"        int n = 1, tot = a.size() + b.size() - 1;",
			"        while (n < tot) {",
			"            n *= 2;",
			"        }",
			"        if (((P - 1) & (n - 1)) != 0 || b.size() < 128) {",
			"            Poly c(a.size() + b.size() - 1);",
			"            for (int i = 0; i < a.size(); i++) {",
			"                for (int j = 0; j < b.size(); j++) {",
			"                    c[i + j] += a[i] * b[j];",
			"                }",
			"            }",
			"            return c;",
			"        }",
			"        a.resize(n);",
			"        b.resize(n);",
			"        dft(a);",
			"        dft(b);",
			"        for (int i = 0; i < n; ++i) {",
			"            a[i] *= b[i];",
			"        }",
			"        idft(a);",
			"        a.resize(tot);",
			"        return a;",
			"    }",
			"    constexpr friend Poly operator*(Value a, Poly b) {",
			"        for (int i = 0; i < int(b.size()); i++) {",
			"            b[i] *= a;",
			"        }",
			"        return b;",
			"    }",
			"    constexpr friend Poly operator*(Poly a, Value b) {",
			"        for (int i = 0; i < int(a.size()); i++) {",
			"            a[i] *= b;",
			"        }",
			"        return a;",
			"    }",
			"    constexpr friend Poly operator/(Poly a, Value b) {",
			"        for (int i = 0; i < int(a.size()); i++) {",
			"            a[i] /= b;",
			"        }",
			"        return a;",
			"    }",
			"    constexpr Poly &operator+=(Poly b) {",
			"        return (*this) = (*this) + b;",
			"    }",
			"    constexpr Poly &operator-=(Poly b) {",
			"        return (*this) = (*this) - b;",
			"    }",
			"    constexpr Poly &operator*=(Poly b) {",
			"        return (*this) = (*this) * b;",
			"    }",
			"    constexpr Poly &operator*=(Value b) {",
			"        return (*this) = (*this) * b;",
			"    }",
			"    constexpr Poly &operator/=(Value b) {",
			"        return (*this) = (*this) / b;",
			"    }",
			"    constexpr Poly deriv() const {",
			"        if (this->empty()) {",
			"            return Poly();",
			"        }",
			"        Poly res(this->size() - 1);",
			"        for (int i = 0; i < this->size() - 1; ++i) {",
			"            res[i] = (i + 1) * (*this)[i + 1];",
			"        }",
			"        return res;",
			"    }",
			"    constexpr Poly integr() const {",
			"        Poly res(this->size() + 1);",
			"        for (int i = 0; i < this->size(); ++i) {",
			"            res[i + 1] = (*this)[i] / (i + 1);",
			"        }",
			"        return res;",
			"    }",
			"    constexpr Poly inv(int m) const {",
			"        Poly x{(*this)[0].inv()};",
			"        int k = 1;",
			"        while (k < m) {",
			"            k *= 2;",
			"            x = (x * (Poly{2} - std::trunc(k) * x)).std::trunc(k);",
			"        }",
			"        return x.std::trunc(m);",
			"    }",
			"    constexpr Poly std::log(int m) const {",
			"        return (deriv() * inv(m)).integr().std::trunc(m);",
			"    }",
			"    constexpr Poly std::exp(int m) const {",
			"        Poly x{1};",
			"        int k = 1;",
			"        while (k < m) {",
			"            k *= 2;",
			"            x = (x * (Poly{1} - x.std::log(k) + std::trunc(k))).std::trunc(k);",
			"        }",
			"        return x.std::trunc(m);",
			"    }",
			"    constexpr Poly std::pow(int k, int m) const {",
			"        int i = 0;",
			"        while (i < this->size() && (*this)[i] == 0) {",
			"            i++;",
			"        }",
			"        if (i == this->size() || 1LL * i * k >= m) {",
			"            return Poly(m);",
			"        }",
			"        Value v = (*this)[i];",
			"        auto f = shift(-i) * v.inv();",
			"        return (f.std::log(m - i * k) * k).std::exp(m - i * k).shift(i * k) * power(v, k);",
			"    }",
			"    constexpr Poly std::sqrt(int m) const {",
			"        Poly x{1};",
			"        int k = 1;",
			"        while (k < m) {",
			"            k *= 2;",
			"            x = (x + (std::trunc(k) * x.inv(k)).std::trunc(k)) * CInv<2, P>;",
			"        }",
			"        return x.std::trunc(m);",
			"    }",
			"    constexpr Poly mulT(Poly b) const {",
			"        if (b.size() == 0) {",
			"            return Poly();",
			"        }",
			"        int n = b.size();",
			"        std::reverse(b.begin(), b.end());",
			"        return ((*this) * b).shift(-(n - 1));",
			"    }",
			"    constexpr std::vector<Value> eval(std::vector<Value> x) const {",
			"        if (this->size() == 0) {",
			"            return std::vector<Value>(x.size(), 0);",
			"        }",
			"        const int n = std::max(x.size(), this->size());",
			"        std::vector<Poly> q(4 * n);",
			"        std::vector<Value> ans(x.size());",
			"        x.resize(n);",
			"        function<void(int, int, int)> build = [&](int p, int l, int r) {",
			"            if (r - l == 1) {",
			"                q[p] = Poly{1, -x[l]};",
			"            } else {",
			"                int m = (l + r) / 2;",
			"                build(2 * p, l, m);",
			"                build(2 * p + 1, m, r);",
			"                q[p] = q[2 * p] * q[2 * p + 1];",
			"            }",
			"        };",
			"        build(1, 0, n);",
			"        function<void(int, int, int, const Poly &)> work = [&](int p, int l, int r,",
			"                                                                    const Poly &num) {",
			"            if (r - l == 1) {",
			"                if (l < int(ans.size())) {",
			"                    ans[l] = num[0];",
			"                }",
			"            } else {",
			"                int m = (l + r) / 2;",
			"                work(2 * p, l, m, num.mulT(q[2 * p + 1]).resize(m - l));",
			"                work(2 * p + 1, m, r, num.mulT(q[2 * p]).resize(r - m));",
			"            }",
			"        };",
			"        work(1, 0, n, mulT(q[1].inv(n)));",
			"        return ans;",
			"    }",
			"};"
		],
		"description": "Poly"
	},
	"findprimitiveroot": {
		"scope": "cpp",
		"prefix": "findprimitiveroot",
		"body": [
			"std::vector<int> rev;",
			"template<int P> std::vector<MInt<P>> roots{0, 1};",
			"",
			"template<int P> constexpr MInt<P> findPrimitiveRoot() {",
			"    MInt<P> i = 2;",
			"    int k = __builtin_ctz(P - 1);",
			"    while (true) {",
			"        if (power(i, (P - 1) / 2) != 1) {",
			"            break;",
			"        }",
			"        i += 1;",
			"    }",
			"    return power(i, (P - 1) >> k);",
			"}",
			"",
			"template<int P> constexpr MInt<P> primitiveRoot = findPrimitiveRoot<P>();",
			"template<> constexpr MInt<998244353> primitiveRoot<998244353>{31};",
			"",
			"template<int P> constexpr void dft(std::vector<MInt<P>> &a) { // 离散傅里叶变换",
			"    int n = a.size();",
			"",
			"    if (int(rev.size()) != n) {",
			"        int k = __builtin_ctz(n) - 1;",
			"        rev.resize(n);",
			"        for (int i = 0; i < n; i++) {",
			"            rev[i] = rev[i >> 1] >> 1 | (i & 1) << k;",
			"        }",
			"    }",
			"",
			"    for (int i = 0; i < n; i++) {",
			"        if (rev[i] < i) {",
			"            std::swap(a[i], a[rev[i]]);",
			"        }",
			"    }",
			"    if (roots<P>.size() < n) {",
			"        int k = __builtin_ctz(roots<P>.size());",
			"        roots<P>.resize(n);",
			"        while ((1 << k) < n) {",
			"            auto e = power(primitiveRoot<P>, 1 << (__builtin_ctz(P - 1) - k - 1));",
			"            for (int i = 1 << (k - 1); i < (1 << k); i++) {",
			"                roots<P>[2 * i] = roots<P>[i];",
			"                roots<P>[2 * i + 1] = roots<P>[i] * e;",
			"            }",
			"            k++;",
			"        }",
			"    }",
			"    for (int k = 1; k < n; k *= 2) {",
			"        for (int i = 0; i < n; i += 2 * k) {",
			"            for (int j = 0; j < k; j++) {",
			"                MInt<P> u = a[i + j];",
			"                MInt<P> v = a[i + j + k] * roots<P>[k + j];",
			"                a[i + j] = u + v;",
			"                a[i + j + k] = u - v;",
			"            }",
			"        }",
			"    }",
			"}",
			"template<int P> constexpr void idft(std::vector<MInt<P>> &a) { // 逆变换",
			"    int n = a.size();",
			"    std::reverse(a.begin() + 1, a.end());",
			"    dft(a);",
			"    MInt<P> inv = (1 - P) / n;",
			"    for (int i = 0; i < n; i++) {",
			"        a[i] *= inv;",
			"    }",
			"}"
		],
		"description": "Findprimitiveroot"
	},
	"berlekampmassey": {
		"scope": "cpp",
		"prefix": "berlekampmassey",
		"body": [
			"template<int P = 998244353> Poly<P> berlekampMassey(const Poly<P> &s) {",
			"    Poly<P> c;",
			"    Poly<P> oldC;",
			"    int f = -1;",
			"    for (int i = 0; i < s.size(); i++) {",
			"        auto delta = s[i];",
			"        for (int j = 1; j <= c.size(); j++) {",
			"            delta -= c[j - 1] * s[i - j];",
			"        }",
			"        if (delta == 0) {",
			"            continue;",
			"        }",
			"        if (f == -1) {",
			"            c.resize(i + 1);",
			"            f = i;",
			"        } else {",
			"            auto d = oldC;",
			"            d *= -1;",
			"            d.insert(d.begin(), 1);",
			"            MInt<P> df1 = 0;",
			"            for (int j = 1; j <= d.size(); j++) {",
			"                df1 += d[j - 1] * s[f + 1 - j];",
			"            }",
			"            assert(df1 != 0);",
			"            auto coef = delta / df1;",
			"            d *= coef;",
			"            Poly<P> zeros(i - f - 1);",
			"            zeros.insert(zeros.end(), d.begin(), d.end());",
			"            d = zeros;",
			"            auto temp = c;",
			"            c += d;",
			"            if (i - temp.size() > f - oldC.size()) {",
			"                oldC = temp;",
			"                f = i;",
			"            }",
			"        }",
			"    }",
			"    c *= -1;",
			"    c.insert(c.begin(), 1);",
			"    return c;",
			"}"
		],
		"description": "Berlekampmassey"
	},
	"linearrecurrence": {
		"scope": "cpp",
		"prefix": "linearrecurrence",
		"body": [
			"template<int P = 998244353> MInt<P> linearRecurrence(Poly<P> p, Poly<P> q, i64 n) {",
			"    int m = q.size() - 1;",
			"    while (n > 0) {",
			"        auto newq = q;",
			"        for (int i = 1; i <= m; i += 2) {",
			"            newq[i] *= -1;",
			"        }",
			"        auto newp = p * newq;",
			"        newq = q * newq;",
			"        for (int i = 0; i < m; i++) {",
			"            p[i] = newp[i * 2 + n % 2];",
			"        }",
			"        for (int i = 0; i <= m; i++) {",
			"            q[i] = newq[i * 2];",
			"        }",
			"        n /= 2;",
			"    }",
			"    return p[0] / q[0];",
			"}"
		],
		"description": "Linearrecurrence"
	},
	"fft_mul": {
		"scope": "cpp",
		"prefix": "fft_mul",
		"body": [
			"using i64 = long long;",
			"const double PI = std::acos(-1);",
			"struct FFT_mul {",
			"    std::vector<std::complex<double>> A, B;",
			"    std::vector<i64> ret;",
			"    std::vector<std::complex<double>> roots;  // 预处理单位根表",
			"",
			"    // 初始化单位根表",
			"    void init_roots(int n) {",
			"        roots.resize(n);",
			"        for (int i = 0; i < n; i++) {",
			"            double ang = 2 * PI * i / n;",
			"            roots[i] = std::complex<double>(cos(ang), sin(ang));",
			"        }",
			"    }",
			"",
			"    // 迭代 FFT",
			"    void FFT(std::vector<std::complex<double>>& a, bool invert) {",
			"        int n = (int)a.size();",
			"        // bit-reversal",
			"        for (int i = 1, j = 0; i < n; i++) {",
			"            int bit = n >> 1;",
			"            for (; j & bit; bit >>= 1) j ^= bit;",
			"            j ^= bit;",
			"            if (i < j) std::swap(a[i], a[j]);",
			"        }",
			"",
			"        for (int len = 2; len <= n; len <<= 1) {",
			"            int step = n / len;",
			"            for (int i = 0; i < n; i += len) {",
			"                for (int j = 0; j < len / 2; j++) {",
			"                    std::complex<double> u = a[i + j];",
			"                    // 正变换用 roots，逆变换用共轭",
			"                    std::complex<double> v =",
			"                        a[i + j + len / 2] * (invert ? conj(roots[j * step]) : roots[j * step]);",
			"                    a[i + j] = u + v;",
			"                    a[i + j + len / 2] = u - v;",
			"                }",
			"            }",
			"        }",
			"        if (invert) {",
			"            for (auto& x : a) x /= n;",
			"        }",
			"    }",
			"",
			"    // 卷积",
			"    void std::count(int x, int y) {",
			"        if ((int)A.size() < x + 1) A.resize(x + 1);",
			"        if ((int)B.size() < y + 1) B.resize(y + 1);",
			"",
			"        int need = x + y + 1;",
			"        int n = 1;",
			"        while (n < need) n <<= 1;",
			"",
			"        init_roots(n);",
			"",
			"        std::vector<std::complex<double>> fa(n), fb(n);",
			"        copy(A.begin(), A.begin() + (x + 1), fa.begin());",
			"        copy(B.begin(), B.begin() + (y + 1), fb.begin());",
			"",
			"        FFT(fa, false);",
			"        FFT(fb, false);",
			"        for (int i = 0; i < n; i++) fa[i] *= fb[i];",
			"        FFT(fa, true);",
			"",
			"        ret.assign(need, 0);",
			"        for (int i = 0; i < need; i++) {",
			"            ret[i] = (i64)llround(fa[i].real());",
			"        }",
			"    }",
			"};"
		],
		"description": "Fft Mul"
	},
	"polynomial": {
		"scope": "cpp",
		"prefix": "polynomial",
		"body": [
			"struct Polynomial {",
			"    std::vector<Z> z;",
			"    std::vector<int> r;",
			"    Polynomial(std::vector<int> &a) {",
			"        int n = a.size();",
			"        z.resize(n);",
			"        r.resize(n);",
			"        for (int i = 0; i < n; i++) {",
			"            z[i] = a[i];",
			"            r[i] = (i & 1) * (n / 2) + r[i / 2] / 2;",
			"        }",
			"        ntt(z, n, 1);",
			"    }",
			"    LL power(LL a, int b) {",
			"        LL res = 1;",
			"        for (; b; b /= 2, a = a * a % mod) {",
			"            if (b % 2) {",
			"                res = res * a % mod;",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"    void ntt(std::vector<Z> &a, int n, int opt) {",
			"        for (int i = 0; i < n; i++) {",
			"            if (r[i] < i) {",
			"                std::swap(a[i], a[r[i]]);",
			"            }",
			"        }",
			"        for (int k = 2; k <= n; k *= 2) {",
			"            Z gn = power(3, (mod - 1) / k);",
			"            for (int i = 0; i < n; i += k) {",
			"                Z g = 1;",
			"                for (int j = 0; j < k / 2; j++, g *= gn) {",
			"                    Z t = a[i + j + k / 2] * g;",
			"                    a[i + j + k / 2] = a[i + j] - t;",
			"                    a[i + j] = a[i + j] + t;",
			"                }",
			"            }",
			"        }",
			"        if (opt == -1) {",
			"            std::reverse(a.begin() + 1, a.end());",
			"            Z inv = power(n, mod - 2);",
			"            for (int i = 0; i < n; i++) {",
			"                a[i] *= inv;",
			"            }",
			"        }",
			"    }",
			"};"
		],
		"description": "Polynomial"
	},
	"qpow": {
		"scope": "cpp",
		"prefix": "qpow",
		"body": [
			"constexpr i64 mod = 998244353, g = 3;",
			"i64 qpow(i64 a, i64 b) {",
			"    i64 r = 1;",
			"    for (; b; b >>= 1, a = a * a % mod) {",
			"        if (b & 1) r = r * a % mod;",
			"    }",
			"    return r;",
			"}",
			"std::vector<i64> mul(std::vector<i64> a, std::vector<i64> b) {",
			"    int M = a.size() + b.size() - 1u, N = 1;",
			"    while (N < M) N <<= 1;",
			"    std::vector<int> r(N);",
			"    for(int i = 1;i <= N;i++)",
			"        r[i] = r[i / 2] / 2 | (i % 2 ? N / 2 : 0);",
			"",
			"    Z ntt = [&](std::vector<i64> &a, bool inv) -> void {",
			"        a.resize(N);",
			"        for(int i = 0;i < N;i++) if (i < r[i]) std::swap(a[i], a[r[i]]);",
			"        for (int sz = 1; sz < N; sz <<= 1) {",
			"            i64 wm = qpow(inv ? g : qpow(g, mod - 2), (mod - 1) / sz / 2);",
			"            for (int i = 0; i < N; i += sz * 2) {",
			"                for (int k = 0, w = 1; k < sz; ++k, w = w * wm % mod) {",
			"                    i64 &x = a[i + k + sz], &y = a[i + k], t = w * x % mod;",
			"                    std::tie(x, y) = pair((y + mod - t) % mod, (y + t) % mod);",
			"                }",
			"            }",
			"        }",
			"        if (i64 in = qpow(N, mod - 2); inv) for(int i = 0;i < N;i++) a[i] = a[i] * in % mod;",
			"    };",
			"",
			"    ntt(a, 0);",
			"    ntt(b, 0);",
			"    for(int i = 0;i < N;i++) a[i] = a[i] * b[i] % mod;",
			"    ntt(a, 1);",
			"    a.resize(M);",
			"    return a;",
			"}"
		],
		"description": "Qpow"
	},
	"lagrange": {
		"scope": "cpp",
		"prefix": "lagrange",
		"body": [
			"struct Lagrange {",
			"    int n;",
			"    std::vector<Z> x, y, fac, invfac;",
			"    Lagrange(int n) {",
			"        this->n = n;",
			"        x.resize(n + 3);",
			"        y.resize(n + 3);",
			"        fac.resize(n + 3);",
			"        invfac.resize(n + 3);",
			"        init(n);",
			"    }",
			"    void init(int n) {",
			"        std::iota(x.begin(), x.end(), 0);",
			"        for (int i = 1; i <= n + 2; i++) {",
			"            Z t;",
			"            y[i] = y[i - 1] + t.power(i, n);",
			"        }",
			"        fac[0] = 1;",
			"        for (int i = 1; i <= n + 2; i++) {",
			"            fac[i] = fac[i - 1] * i;",
			"        }",
			"        invfac[n + 2] = fac[n + 2].inv();",
			"        for (int i = n + 1; i >= 0; i--) {",
			"            invfac[i] = invfac[i + 1] * (i + 1);",
			"        }",
			"    }",
			"    Z solve(LL k) {",
			"        if (k <= n + 2) {",
			"            return y[k];",
			"        }",
			"        std::vector<Z> sub(n + 3);",
			"        for (int i = 1; i <= n + 2; i++) {",
			"            sub[i] = k - x[i];",
			"        }",
			"        std::vector<Z> mul(n + 3);",
			"        mul[0] = 1;",
			"        for (int i = 1; i <= n + 2; i++) {",
			"            mul[i] = mul[i - 1] * sub[i];",
			"        }",
			"        Z ans = 0;",
			"        for (int i = 1; i <= n + 2; i++) {",
			"            ans = ans + y[i] * mul[n + 2] * sub[i].inv() * std::pow(-1, n + 2 - i) * invfac[i - 1] *",
			"                            invfac[n + 2 - i];",
			"        }",
			"        return ans;",
			"    }",
			"};"
		],
		"description": "Lagrange"
	}
}
