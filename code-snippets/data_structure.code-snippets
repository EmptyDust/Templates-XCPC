{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"for": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"std::cin >> n;",
			"for (int i = 0;i < n;++i)std::cin >> nums[i];",
			"for (int i = 0;i < n;++i)rs[i] = -1;",
			"for (int i = 0;i < n;++i)ls[i] = -1;",
			"top = 0;",
			"for (int i = 0; i < n; i++) {",
			"    int k = top;",
			"    while (k > 0 && nums[stk[k - 1]] > nums[i]) k--;",
			"    if (k) rs[stk[k - 1]] = i;  // rs代表笛卡尔树每个节点的右儿子",
			"    if (k < top) ls[i] = stk[k];  // ls代表笛卡尔树每个节点的左儿子",
			"    stk[k++] = i;",
			"    top = k;",
			"}"
		],
		"description": "For"
	},
	"dsu": {
		"scope": "cpp",
		"prefix": "dsu",
		"body": [
			"struct dsu {",
			"    std::vector<int> d;",
			"    dsu(int n) { d.resize(n + 1); std::iota(d.begin(), d.end(), 0); }",
			"    int get_root(int x) { return d[x] = (x == d[x] ? x : get_root(d[x])); };",
			"    bool merge(int u, int v) {",
			"        if (get_root(u) != get_root(v)) {",
			"            d[get_root(u)] = get_root(v);",
			"            return true;",
			"        }",
			"        else return false;",
			"    }",
			"};"
		],
		"description": "Dsu"
	},
	"ufinit": {
		"scope": "cpp",
		"prefix": "ufinit",
		"body": [
			"//左移位数根据节点个数定",
			"#define UFLIMIT (2<<17)",
			"int unicnt[UFLIMIT];",
			"void ufinit(int n) {",
			"    for (int i = 0;i < n;i++)unicnt[i] = 1;",
			"}",
			"int ufroot(int x) { return unicnt[x] <= 0 ? -(unicnt[x] = -ufroot(-unicnt[x])) : x; }",
			"int ufsame(int x, int y) { return ufroot(x) == ufroot(y); }",
			"void uni(int x, int y) {",
			"    if ((x = ufroot(x)) == (y = ufroot(y)))return;",
			"    if (unicnt[x] < unicnt[y])std::swap(x, y);",
			"    unicnt[x] += unicnt[y];",
			"    unicnt[y] = -x;",
			"}"
		],
		"description": "Ufinit"
	},
	"unionfind": {
		"scope": "cpp",
		"prefix": "unionfind",
		"body": [
			"class UnionFind {",
			"private:",
			"    std::vector<int> parent;",
			"    std::vector<int> rank;",
			"public:",
			"    UnionFind(int n) {",
			"        parent.resize(n, 0);",
			"        rank.resize(n, 0);",
			"        std::iota(parent.begin(), parent.end(), 0);",
			"    }",
			"    int std::find(int x) {",
			"        if (parent[x] == x)",
			"            return x;",
			"        return parent[x] = std::find(parent[x]);",
			"    }",
			"    void merge(int x, int y) {",
			"        int rootX = std::find(x);",
			"        int rootY = std::find(y);",
			"        if (rootX == rootY) return;",
			"        if (rank[rootX] > rank[rootY])",
			"            std::swap(rootX, rootY);",
			"        parent[rootX] = rootY;",
			"        if (rank[rootX] == rank[rootY]) {",
			"            rank[rootY]++;",
			"        }",
			"    }",
			"    bool isConnect(int x, int y) {",
			"        return std::find(x) == std::find(y);",
			"    }",
			"};"
		],
		"description": "Unionfind"
	},
	"dsu_1": {
		"scope": "cpp",
		"prefix": "dsu",
		"body": [
			"struct DSU {",
			"    std::vector<int> fa, p, e, f;",
			"",
			"    DSU(int n) {",
			"        fa.resize(n + 1);",
			"        std::iota(fa.begin(), fa.end(), 0);",
			"        p.resize(n + 1, 1);",
			"        e.resize(n + 1);",
			"        f.resize(n + 1);",
			"    }",
			"    int get(int x) {",
			"        while (x != fa[x]) {",
			"            x = fa[x] = fa[fa[x]];",
			"        }",
			"        return x;",
			"    }",
			"    bool merge(int x, int y) { // 设x是y的祖先",
			"        if (x == y) f[get(x)] = 1;",
			"        x = get(x), y = get(y);",
			"        e[x]++;",
			"        if (x == y) return false;",
			"        if (x < y) std::swap(x, y); // 将编号小的合并到大的上",
			"        fa[y] = x;",
			"        f[x] |= f[y], p[x] += p[y], e[x] += e[y];",
			"        return true;",
			"    }",
			"    bool same(int x, int y) {",
			"        return get(x) == get(y);",
			"    }",
			"    bool F(int x) { // 判断连通块内是否存在自环",
			"        return f[get(x)];",
			"    }",
			"    int size(int x) { // 输出连通块中点的数量",
			"        return p[get(x)];",
			"    }",
			"    int E(int x) { // 输出连通块中边的数量",
			"        return e[get(x)];",
			"    }",
			"};"
		],
		"description": "Dsu"
	},
	"sparse_table": {
		"scope": "cpp",
		"prefix": "sparse_table",
		"body": [
			"template<typename T>",
			"struct sparse_table",
			"{",
			"    std::vector<std::vector<T>> vt;",
			"    sparse_table(std::vector<T> a) {",
			"        int n = a.size();",
			"        vt.assign(n, std::vector<T>(30));",
			"        for (int i = 0;i < n;++i)",
			"            vt[i][0] = a[i];",
			"        for (int s = 1;s < 30;++s) {",
			"            for (int i = 0;i < n;++i) {",
			"                int j = i + (1 << s - 1);",
			"                if (j < n) {",
			"                    vt[i][s] = vt[i][s - 1] + vt[i + (1 << s - 1)][s - 1];",
			"                }",
			"                else vt[i][s] = vt[i][s - 1];",
			"            }",
			"        }",
			"    }",
			"    T query(int l, int r) {//[l,r)",
			"        if (l == r) return T(0);",
			"        int len = r - l;",
			"        int x = std::__lg(len);",
			"        return vt[l][x] + vt[r - (1 << x)][x];",
			"    }",
			"};",
			"",
			"struct Info",
			"{",
			"    i64 a;",
			"    Info operator+(Info x) {",
			"        return Info(std::max(a, x.a));",
			"    }",
			"};"
		],
		"description": "Sparse Table"
	},
	"bit": {
		"scope": "cpp",
		"prefix": "bit",
		"body": [
			"template<typename T> struct BIT {",
			"    int n;",
			"    std::vector<T> w;",
			"    BIT(int n, auto &in) : n(n), w(n + 1) { // 预处理填值",
			"        for (int i = 1; i <= n; i++) {",
			"            add(i, in[i]);",
			"        }",
			"    }",
			"    void add(int x, T v) {",
			"        for (; x <= n; x += x & -x) {",
			"            w[x] += v;",
			"        }",
			"    }",
			"    T ask(int x) { // 前缀和查询",
			"        T ans = 0;",
			"        for (; x; x -= x & -x) {",
			"            ans += w[x];",
			"        }",
			"        return ans;",
			"    }",
			"    T ask(int l, int r) { // 差分实现区间和查询",
			"        return ask(r) - ask(l - 1);",
			"    }",
			"};"
		],
		"description": "Bit"
	},
	"bit_1": {
		"scope": "cpp",
		"prefix": "bit",
		"body": [
			"struct BIT {",
			"    int n;",
			"    std::vector<int> w, chk; // chk 为传入的待处理数组",
			"    BIT(int n, auto &in) : n(n), w(n + 1), chk(in) {}",
			"    /* 需要全部常规封装 */",
			"    int get() {",
			"        std::vector<std::array<int, 2>> alls;",
			"        for (int i = 1; i <= n; i++) {",
			"            alls.push_back({chk[i], i});",
			"        }",
			"        std::sort(alls.begin(), alls.end());",
			"        int ans = 0;",
			"        for (auto [val, idx] : alls) {",
			"            ans += ask(idx + 1, n);",
			"            add(idx, 1);",
			"        }",
			"        return ans;",
			"    }",
			"};"
		],
		"description": "Bit"
	},
	"bit_2": {
		"scope": "cpp",
		"prefix": "bit",
		"body": [
			"struct BIT {",
			"    int n;",
			"    std::vector<int> w;",
			"    BIT(int n) : n(n), w(n + 1) {}",
			"    void add(int x, int v) {",
			"        for (; x <= n; x += x & -x) {",
			"            w[x] += v;",
			"        }",
			"    }",
			"    int kth(int x) { // 查找第 k 小的值",
			"        int ans = 0;",
			"        for (int i = __lg(n); i >= 0; i--) {",
			"            int val = ans + (1 << i);",
			"            if (val < n && w[val] < x) {",
			"                x -= w[val];",
			"                ans = val;",
			"            }",
			"        }",
			"        return ans + 1;",
			"    }",
			"    int get(int x) { // 查找 x 的排名",
			"        int ans = 1;",
			"        for (x--; x; x -= x & -x) {",
			"            ans += w[x];",
			"        }",
			"        return ans;",
			"    }",
			"    int pre(int x) { return kth(get(x) - 1); } // 查找 x 的前驱",
			"    int suf(int x) { return kth(get(x + 1)); } // 查找 x 的后继",
			"};",
			"const int N = 10000000; // 可以用于在线处理平衡二叉树的全部要求",
			"signed main() {",
			"    BIT bit(N + 1); // 在线处理不能够离散化，一定要开到比最大值更大",
			"    int n;",
			"    std::cin >> n;",
			"    for (int i = 1; i <= n; i++) {",
			"        int op, x;",
			"        std::cin >> op >> x;",
			"        if (op == 1) bit.add(x, 1); // 插入 x",
			"        else if (op == 2) bit.add(x, -1); // 删除任意一个 x",
			"        else if (op == 3) cout << bit.get(x) << \"\\n\"; // 查询 x 的排名",
			"        else if (op == 4) cout << bit.kth(x) << \"\\n\"; // 查询排名为 x 的数",
			"        else if (op == 5) cout << bit.pre(x) << \"\\n\"; // 求小于 x 的最大值（前驱）",
			"        else if (op == 6) cout << bit.suf(x) << \"\\n\"; // 求大于 x 的最小值（后继）",
			"    }",
			"}"
		],
		"description": "Bit"
	},
	"bit_3": {
		"scope": "cpp",
		"prefix": "bit",
		"body": [
			"template<typename T> struct BIT {",
			"    int n;",
			"    std::vector<T> w, base;",
			"    #define low(x) (x & -x)",
			"    BIT(int n, auto &in) : n(n), w(n + 1), base(n + 1) {",
			"        for (int i = 1; i <= n; i++) {",
			"            update(i, in[i]);",
			"        }",
			"    } /* 可以增加并使用常规封装中的几个函数 */",
			"    void update(int x, int v) { // 单点赋值",
			"        base[x] = std::max(base[x], v);",
			"        for (; x <= n; x += low(x)) {",
			"            w[x] = std::max(w[x], v);",
			"        }",
			"    }",
			"    T getMax(int l, int r) { // 最值查询",
			"        T ans = T();",
			"        while (r >= l) {",
			"            ans = std::max(base[r], ans);",
			"            for (r--; r - low(r) >= l; r -= low(r)) {",
			"                ans = std::max(w[r], ans);",
			"            }",
			"        }",
			"        return ans;",
			"    }",
			"};"
		],
		"description": "Bit"
	},
	"bit_2d": {
		"scope": "cpp",
		"prefix": "bit_2d",
		"body": [
			"struct BIT_2D {",
			"    int n, m;",
			"    std::vector<std::vector<int>> w;",
			"",
			"    BIT_2D(int n, int m) : n(n), m(m) {",
			"        w.resize(n + 1, std::vector<int>(m + 1));",
			"    }",
			"    void add(int x, int y, int k) {",
			"        for (int i = x; i <= n; i += i & -i) {",
			"            for (int j = y; j <= m; j += j & -j) {",
			"                w[i][j] += k;",
			"            }",
			"        }",
			"    }",
			"    void add(int x, int y, int X, int Y, int k) { // 区块修改：二维差分",
			"        X++, Y++;",
			"        add(x, y, k), add(X, y, -k);",
			"        add(X, Y, k), add(x, Y, -k);",
			"    }",
			"    int ask(int x, int y) { // 单点查询",
			"        int ans = 0;",
			"        for (int i = x; i; i -= i & -i) {",
			"            for (int j = y; j; j -= j & -j) {",
			"                ans += w[i][j];",
			"            }",
			"        }",
			"        return ans;",
			"    }",
			"    int ask(int x, int y, int X, int Y) { // 区块查询：二维前缀和",
			"        x--, y--;",
			"        return ask(X, Y) - ask(x, Y) - ask(X, y) + ask(x, y);",
			"    }",
			"};"
		],
		"description": "Bit 2D"
	},
	"bit_2d_1": {
		"scope": "cpp",
		"prefix": "bit_2d",
		"body": [
			"struct BIT_2D {",
			"    int n, m;",
			"    std::vector<std::vector<int>> b1, b2, b3, b4;",
			"",
			"    BIT_2D(int n, int m) : n(n), m(m) {",
			"        b1.resize(n + 1, std::vector<int>(m + 1));",
			"        b2.resize(n + 1, std::vector<int>(m + 1));",
			"        b3.resize(n + 1, std::vector<int>(m + 1));",
			"        b4.resize(n + 1, std::vector<int>(m + 1));",
			"    }",
			"    void add(auto &w, int x, int y, int k) { // 单点修改",
			"        for (int i = x; i <= n; i += i & -i) {",
			"            for (int j = y; j <= m; j += j & -j) {",
			"                w[i][j] += k;",
			"            }",
			"        }",
			"    }",
			"    void add(int x, int y, int k) { // 多了一步计算",
			"        add(b1, x, y, k);",
			"        add(b2, x, y, k * (x - 1));",
			"        add(b3, x, y, k * (y - 1));",
			"        add(b4, x, y, k * (x - 1) * (y - 1));",
			"    }",
			"    void add(int x, int y, int X, int Y, int k) { // 区块修改：二维差分",
			"        X++, Y++;",
			"        add(x, y, k), add(X, y, -k);",
			"        add(X, Y, k), add(x, Y, -k);",
			"    }",
			"    int ask(auto &w, int x, int y) { // 单点查询",
			"        int ans = 0;",
			"        for (int i = x; i; i -= i & -i) {",
			"            for (int j = y; j; j -= j & -j) {",
			"                ans += w[i][j];",
			"            }",
			"        }",
			"        return ans;",
			"    }",
			"    int ask(int x, int y) { // 多了一步计算",
			"        int ans = 0;",
			"        ans += x * y * ask(b1, x, y);",
			"        ans -= y * ask(b2, x, y);",
			"        ans -= x * ask(b3, x, y);",
			"        ans += ask(b4, x, y);",
			"        return ans;",
			"    }",
			"    int ask(int x, int y, int X, int Y) { // 区块查询：二维前缀和",
			"        x--, y--;",
			"        return ask(X, Y) - ask(x, Y) - ask(X, y) + ask(x, y);",
			"    }",
			"};"
		],
		"description": "Bit 2D"
	},
	"lazysegmenttree": {
		"scope": "cpp",
		"prefix": "lazysegmenttree",
		"body": [
			"template<typename Info, typename Tag>",
			"struct LazySegmentTree {",
			"    int n;",
			"    std::vector<Info> info;",
			"    std::vector<Tag> tag;",
			"    LazySegmentTree() : n(0) {}",
			"    LazySegmentTree(int n_, Info v_ = Info()) {",
			"        init(n_, v_);",
			"    }",
			"    template<typename T>",
			"    LazySegmentTree(std::vector<T> init_) {",
			"        init(init_);",
			"    }",
			"    void init(int n_, Info v_ = Info()) {",
			"        init(std::vector(n_, v_));",
			"    }",
			"    template<typename T>",
			"    void init(std::vector<T> init_) {",
			"        n = init_.size();",
			"        info.assign(4 << std::__lg(n), Info());",
			"        tag.assign(4 << std::__lg(n), Tag());",
			"        std::function<void(int, int, int)> build = [&](int p, int l, int r) {",
			"            if (r - l == 1) {",
			"                info[p] = init_[l];",
			"                return;",
			"            }",
			"            int m = (l + r) / 2;",
			"            build(2 * p, l, m);",
			"            build(2 * p + 1, m, r);",
			"            pull(p);",
			"            };",
			"        build(1, 0, n);",
			"    }",
			"    void pull(int p) {",
			"        info[p] = info[2 * p] + info[2 * p + 1];",
			"    }",
			"    void apply(int p, const Tag& v) {",
			"        info[p].apply(v);",
			"        tag[p].apply(v);",
			"    }",
			"    void push(int p) {",
			"        apply(2 * p, tag[p]);",
			"        apply(2 * p + 1, tag[p]);",
			"        tag[p] = Tag();",
			"    }",
			"    void modify(int p, int l, int r, int x, const Info& v) {",
			"        if (r - l == 1) {",
			"            info[p] = v;",
			"            return;",
			"        }",
			"        int m = (l + r) / 2;",
			"        push(p);",
			"        if (x < m) {",
			"            modify(2 * p, l, m, x, v);",
			"        }",
			"        else {",
			"            modify(2 * p + 1, m, r, x, v);",
			"        }",
			"        pull(p);",
			"    }",
			"    void modify(int p, const Info& v) {",
			"        modify(1, 0, n, p, v);",
			"    }",
			"    Info rangeQuery(int p, int l, int r, int x, int y) {",
			"        if (l >= y || r <= x) {",
			"            return Info();",
			"        }",
			"        if (l >= x && r <= y) {",
			"            return info[p];",
			"        }",
			"        int m = (l + r) / 2;",
			"        push(p);",
			"        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);",
			"    }",
			"    Info rangeQuery(int l, int r) {",
			"        return rangeQuery(1, 0, n, l, r);",
			"    }",
			"    void rangeApply(int p, int l, int r, int x, int y, const Tag& v) {",
			"        if (l >= y || r <= x) {",
			"            return;",
			"        }",
			"        if (l >= x && r <= y) {",
			"            apply(p, v);",
			"            return;",
			"        }",
			"        int m = (l + r) / 2;",
			"        push(p);",
			"        rangeApply(2 * p, l, m, x, y, v);",
			"        rangeApply(2 * p + 1, m, r, x, y, v);",
			"        pull(p);",
			"    }",
			"    void rangeApply(int l, int r, const Tag& v) {",
			"        return rangeApply(1, 0, n, l, r, v);",
			"    }",
			"    template<typename F>",
			"    int findFirst(int p, int l, int r, int x, int y, F pred) {",
			"        if (l >= y || r <= x || !pred(info[p])) {",
			"            return -1;",
			"        }",
			"        if (r - l == 1) {",
			"            return l;",
			"        }",
			"        int m = (l + r) / 2;",
			"        push(p);",
			"        int res = findFirst(2 * p, l, m, x, y, pred);",
			"        if (res == -1) {",
			"            res = findFirst(2 * p + 1, m, r, x, y, pred);",
			"        }",
			"        return res;",
			"    }",
			"    template<typename F>",
			"    int findFirst(int l, int r, F pred) {",
			"        return findFirst(1, 0, n, l, r, pred);",
			"    }",
			"    template<typename F>",
			"    int findLast(int p, int l, int r, int x, int y, F pred) {",
			"        if (l >= y || r <= x || !pred(info[p])) {",
			"            return -1;",
			"        }",
			"        if (r - l == 1) {",
			"            return l;",
			"        }",
			"        int m = (l + r) / 2;",
			"        push(p);",
			"        int res = findLast(2 * p + 1, m, r, x, y, pred);",
			"        if (res == -1) {",
			"            res = findLast(2 * p, l, m, x, y, pred);",
			"        }",
			"        return res;",
			"    }",
			"    template<typename F>",
			"    int findLast(int l, int r, F pred) {",
			"        return findLast(1, 0, n, l, r, pred);",
			"    }",
			"};",
			"",
			"struct Tag {",
			"    i64 x = 0;",
			"    void apply(Tag t) {",
			"    }",
			"};",
			"",
			"struct Info {",
			"    i64 x = 0;",
			"    void apply(Tag t) {",
			"    }",
			"};",
			"Info operator+(Info a, Info b) {",
			"    return { a.x + b.x };",
			"}"
		],
		"description": "Lazysegmenttree"
	},
	"segt": {
		"scope": "cpp",
		"prefix": "segt",
		"body": [
			"struct Segt {",
			"    std::vector<int> w;",
			"    int n;",
			"    Segt(int n) : w(2 * n, (int)-2E9), n(n) {}",
			"",
			"    void modify(int pos, int val) {",
			"        for (w[pos += n] = val; pos > 1; pos /= 2) {",
			"            w[pos / 2] = std::max(w[pos], w[pos ^ 1]);",
			"        }",
			"    }",
			"",
			"    int ask(int l, int r) {",
			"        int res = -2E9;",
			"        for (l += n, r += n; l < r; l /= 2, r /= 2) {",
			"            if (l % 2) res = std::max(res, w[l++]);",
			"            if (r % 2) res = std::max(res, w[--r]);",
			"        }",
			"        return res;",
			"    }",
			"};"
		],
		"description": "Segt"
	},
	"segmenttree": {
		"scope": "cpp",
		"prefix": "segmenttree",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"using namespace __gnu_pbds;",
			"using pii = std::pair<int, int>;",
			"const int inf = 2147483647;",
			"",
			"tree<pii, null_type, std::less<pii>, rb_tree_tag, tree_order_statistics_node_update> ver;",
			"",
			"template<typename Info>",
			"struct SegmentTree {",
			"    int n;",
			"    std::vector<Info> info;",
			"",
			"    SegmentTree() : n(0) {}",
			"",
			"    void init(int n_) {",
			"        n = n_;",
			"        info.assign(4 << std::__lg(n), Info());",
			"    }",
			"",
			"public:",
			"    // --- 初始化与构建 ---",
			"    void build(const std::vector<int>& a) {",
			"        _build(1, 0, n, a);",
			"    }",
			"",
			"private:",
			"    void _build(int p, int l, int r, const std::vector<int>& a) {",
			"        // 从叶子节点开始，向上启发式合并来构建整棵树",
			"        if (r - l == 1) {",
			"            if (l < a.size()) info[p].ver.insert({ a[l], l });",
			"            return;",
			"        }",
			"        int m = (l + r) / 2;",
			"        _build(2 * p, l, m, a);",
			"        _build(2 * p + 1, m, r, a);",
			"",
			"        // 启发式合并 (小树合并到大树)",
			"        if (info[2 * p].ver.size() > info[2 * p + 1].ver.size()) {",
			"            info[p].ver = info[2 * p].ver;",
			"            for (const auto& item : info[2 * p + 1].ver) info[p].ver.insert(item);",
			"        }",
			"        else {",
			"            info[p].ver = info[2 * p + 1].ver;",
			"            for (const auto& item : info[2 * p].ver) info[p].ver.insert(item);",
			"        }",
			"    }",
			"",
			"public:",
			"    // 单点修改",
			"    void update(int pos, int old_val, int new_val) {",
			"        _update(1, 0, n, pos, old_val, new_val);",
			"    }",
			"",
			"    // 查询排名 (返回比 k 小的数的个数)",
			"    int query_rank_count(int l, int r, int k) {",
			"        return _query_rank_count(1, 0, n, l, r, k);",
			"    }",
			"",
			"    // 查询前驱",
			"    int query_pred(int l, int r, int k) {",
			"        return _query_pred(1, 0, n, l, r, k);",
			"    }",
			"",
			"    // 查询后继",
			"    int query_succ(int l, int r, int k) {",
			"        return _query_succ(1, 0, n, l, r, k);",
			"    }",
			"",
			"private:",
			"    void _update(int p, int l, int r, int pos, int old_val, int new_val) {",
			"        info[p].ver.erase({ old_val, pos });",
			"        info[p].ver.insert({ new_val, pos });",
			"        if (r - l == 1) return;",
			"        int m = (l + r) / 2;",
			"        if (pos < m) _update(2 * p, l, m, pos, old_val, new_val);",
			"        else _update(2 * p + 1, m, r, pos, old_val, new_val);",
			"    }",
			"",
			"    int _query_rank_count(int p, int l, int r, int x, int y, int k) {",
			"        if (l >= y || r <= x) return 0;",
			"        if (l >= x && r <= y) {",
			"            return info[p].ver.order_of_key({ k, -1 });",
			"        }",
			"        int m = (l + r) / 2;",
			"        return _query_rank_count(2 * p, l, m, x, y, k) + _query_rank_count(2 * p + 1, m, r, x, y, k);",
			"    }",
			"",
			"    int _query_pred(int p, int l, int r, int x, int y, int k) {",
			"        if (l >= y || r <= x) return -inf;",
			"        if (l >= x && r <= y) {",
			"            auto it = info[p].ver.std::lower_bound({ k, -1 });",
			"            if (it == info[p].ver.begin()) return -inf;",
			"            return (--it)->first;",
			"        }",
			"        int m = (l + r) / 2;",
			"        return std::max(_query_pred(2 * p, l, m, x, y, k), _query_pred(2 * p + 1, m, r, x, y, k));",
			"    }",
			"",
			"    int _query_succ(int p, int l, int r, int x, int y, int k) {",
			"        if (l >= y || r <= x) return inf;",
			"        if (l >= x && r <= y) {",
			"            auto it = info[p].ver.std::upper_bound({ k, inf });",
			"            if (it == info[p].ver.end()) return inf;",
			"            return it->first;",
			"        }",
			"        int m = (l + r) / 2;",
			"        return std::min(_query_succ(2 * p, l, m, x, y, k), _query_succ(2 * p + 1, m, r, x, y, k));",
			"    }",
			"};",
			"",
			"struct Info {",
			"    tree<pii, null_type, std::less<pii>, rb_tree_tag, tree_order_statistics_node_update> ver;",
			"};"
		],
		"description": "Segmenttree"
	},
	"wavelet": {
		"scope": "cpp",
		"prefix": "wavelet",
		"body": [
			"#define __count(x) __builtin_popcountll(x)",
			"struct Wavelet {",
			"    std::vector<int> val, sum;",
			"    std::vector<u64> bit;",
			"    int t, n;",
			"",
			"    int getSum(int i) {",
			"        return sum[i >> 6] + __count(bit[i >> 6] & ((1ULL << (i & 63)) - 1));",
			"    }",
			"",
			"    Wavelet(std::vector<int> v) : val(v), n(v.size()) {",
			"        std::sort(val.begin(), val.end());",
			"        val.erase(std::unique(val.begin(), val.end()), val.end());",
			"",
			"        int n_ = val.size();",
			"        t = __lg(2 * n_ - 1);",
			"        bit.resize((t * n + 64) >> 6);",
			"        sum.resize(bit.size());",
			"        std::vector<int> cnt(n_ + 1);",
			"",
			"        for (int &x : v) {",
			"            x = std::lower_bound(val.begin(), val.end(), x) - val.begin();",
			"            cnt[x + 1]++;",
			"        }",
			"        for (int i = 1; i < n_; ++i) {",
			"            cnt[i] += cnt[i - 1];",
			"        }",
			"        for (int j = 0; j < t; ++j) {",
			"            for (int i : v) {",
			"                int tmp = i >> (t - 1 - j);",
			"                int pos = (tmp >> 1) << (t - j);",
			"                auto setBit = [&](int i, u64 v) {",
			"                    bit[i >> 6] |= (v << (i & 63));",
			"                };",
			"                setBit(j * n + cnt[pos], tmp & 1);",
			"                cnt[pos]++;",
			"            }",
			"            for (int i : v) {",
			"                cnt[(i >> (t - j)) << (t - j)]--;",
			"            }",
			"        }",
			"        for (int i = 1; i < sum.size(); ++i) {",
			"            sum[i] = sum[i - 1] + __count(bit[i - 1]);",
			"        }",
			"    }",
			"",
			"    int small(int l, int r, int k) {",
			"        r++;",
			"        for (int j = 0, x = 0, y = n, res = 0;; ++j) {",
			"            if (j == t) return val[res];",
			"            int A = getSum(n * j + x), B = getSum(n * j + l);",
			"            int C = getSum(n * j + r), D = getSum(n * j + y);",
			"            int ab_zeros = r - l - C + B;",
			"            if (ab_zeros > k) {",
			"                res = res << 1;",
			"                y -= D - A;",
			"                l -= B - A;",
			"                r -= C - A;",
			"            } else {",
			"                res = (res << 1) | 1;",
			"                k -= ab_zeros;",
			"                x += y - x - D + A;",
			"                l += y - l - D + B;",
			"                r += y - r - D + C;",
			"            }",
			"        }",
			"    }",
			"    int large(int l, int r, int k) {",
			"        return small(l, r, r - l - k);",
			"    }",
			"};"
		],
		"description": "Wavelet"
	},
	"preesidenttree": {
		"scope": "cpp",
		"prefix": "preesidenttree",
		"body": [
			"struct PreesidentTree {",
			"    static constexpr int N = 2e5 + 10;",
			"    int cntNodes, root[N];",
			"",
			"    struct node {",
			"        int l, r;",
			"        int cnt;",
			"    }tr[4 * N + 17 * N];",
			"",
			"    //u 是新节点，v 是旧节点",
			"    void modify(int& u, int v, int l, int r, int x) {",
			"        u = ++cntNodes;",
			"        tr[u] = tr[v];",
			"        tr[u].cnt++;",
			"        if (l == r) return;",
			"        int mid = (l + r) / 2;",
			"        if (x <= mid) modify(tr[u].l, tr[v].l, l, mid, x);",
			"        else modify(tr[u].r, tr[v].r, mid + 1, r, x);",
			"    }",
			"",
			"    //u 是新节点，v 是旧节点",
			"    int kth(int u, int v, int l, int r, int k) {",
			"        if (l == r) return l;",
			"        int res = tr[tr[u].l].cnt - tr[tr[v].l].cnt;",
			"        int mid = (l + r) / 2;",
			"        if (k <= res) return kth(tr[u].l, tr[v].l, l, mid, k);",
			"        else return kth(tr[u].r, tr[v].r, mid + 1, r, k - res);",
			"    }",
			"};"
		],
		"description": "Preesidenttree"
	},
	"code": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"signed main() {",
			"    int n;",
			"    std::cin >> n;",
			"    std::vector<int> w(n + 1);",
			"    for (int i = 1; i <= n; i++) {",
			"        std::cin >> w[i];",
			"    }",
			"",
			"    int q;",
			"    std::cin >> q;",
			"    std::vector<std::array<int, 3>> query(q + 1);",
			"    for (int i = 1; i <= q; i++) {",
			"        int l, r;",
			"        std::cin >> l >> r;",
			"        query[i] = {l, r, i};",
			"    }",
			"",
			"    int Knum = n / std::min<int>(n, std::sqrt(q)); // 计算块长",
			"    std::vector<int> K(n + 1);",
			"    for (int i = 1; i <= n; i++) { // 固定块长",
			"        K[i] = (i - 1) / Knum + 1;",
			"    }",
			"    std::sort(query.begin() + 1, query.end(), [&](auto x, auto y) {",
			"        if (K[x[0]] != K[y[0]]) return x[0] < y[0];",
			"        if (K[x[0]] & 1) return x[1] < y[1];",
			"        return x[1] > y[1];",
			"    });",
			"",
			"    int l = 1, r = 0, val = 0;",
			"    std::vector<int> ans(q + 1);",
			"    for (int i = 1; i <= q; i++) {",
			"        auto [ql, qr, id] = query[i];",
			"        auto add = [&](int x) -> void {};",
			"        auto del = [&](int x) -> void {};",
			"        while (l > ql) add(w[--l]);",
			"        while (r < qr) add(w[++r]);",
			"        while (l < ql) del(w[l++]);",
			"        while (r > qr) del(w[r--]);",
			"        ans[id] = val;",
			"    }",
			"    for (int i = 1; i <= q; i++) {",
			"        std::cout << ans[i] << std::endl;",
			"    }",
			"}"
		],
		"description": "Code"
	},
	"code_1": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"void solve(){",
			"    int n, m;    ",
			"    std::cin >> n >> m;",
			"    std::vector<int> a(n + 1);",
			"    for (int i = 1;i <= n;i++)   std::cin >> a[i];",
			"",
			"    std::vector<a4> q{ {} };        // {左区间, 右区间, 累计修改次数, 下标}",
			"    std::vector<a2> upd{ {} };      // {修改位置，修改的值}",
			"    for (int i = 1;i <= m;i++) {",
			"        char op;    std::cin >> op;",
			"        if (op == 'Q') {",
			"            int l, r;   std::cin >> l >> r;",
			"            q.push_back(a4{ l,r,(int)upd.size() - 1 ,(int)q.size() });",
			"        }",
			"        else {",
			"            int idx, val;   std::cin >> idx >> val;",
			"            upd.push_back({ idx,val });",
			"        }",
			"    }",
			"",
			"    int block = 2610;   //n ^ (2 / 3)",
			"    std::vector<int> b(n + 1);",
			"    for (int i = 1;i <= n;i++) b[i] = (i - 1) / block + 1;",
			"    std::sort(q.begin() + 1, q.end(), [&](auto x, auto y) {",
			"        if (b[x[0]] != b[y[0]]) return x[0] < y[0];",
			"        if (b[x[1]] != b[y[1]]) return x[1] < y[1];",
			"        return x[3] < y[3];",
			"        });",
			"",
			"    n = q.size() - 1;",
			"    int l = 1, r = 0, t = 0;",
			"    std::vector<int> ans(n + 1);",
			"    for (int i = 1;i <= n;i++) {",
			"        auto [ql, qr, qt, id] = q[i];",
			"",
			"        auto add = [&](int x) {};",
			"        auto del = [&](int x) {};",
			"        auto time = [&](int t, int l, int r) {",
			"            int pos = upd[t][0];",
			"            int& val = upd[t][1];",
			"            if (pos >= l && pos <= r) {",
			"                del(a[pos]);",
			"                add(val);",
			"            }",
			"            std::swap(a[pos], val);",
			"            };",
			"",
			"        while (l > ql) add(a[--l]);",
			"        while (r < qr) add(a[++r]);",
			"        while (l < ql) del(a[l++]);",
			"        while (r > qr) del(a[r--]);",
			"        while (t < qt) time(++t, ql, qr);",
			"        while (t > qt) time(t--, ql, qr);",
			"",
			"        ans[id] = cnt;",
			"    }",
			"    for (int i = 1;i <= n;i++)    std::cout << ans[i] << '\\n';",
			"}"
		],
		"description": "Code"
	},
	"code_2": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"void solve(){",
			"    std::vector<a3> q(m + 1);",
			"    for (int i = 1;i <= m;i++) {",
			"        int l, r;   std::cin >> l >> r;",
			"        q[i] = { l,r,i };",
			"    }",
			"    int block = n / std::min<int>(n, sqrt(m));",
			"    std::vector<int> b(n + 1);",
			"    for (int i = 1;i <= n;i++) b[i] = (i - 1) / block + 1;",
			"    std::sort(q.begin() + 1, q.end(), [&](auto x, auto y) {",
			"        if (b[x[0]] != b[y[0]]) return x[0] < y[0];",
			"        return x[1] < y[1];",
			"        });",
			"",
			"    int l = 1, r = 0, cur_block = 0, tmpl;",
			"    int res = 0;",
			"    std::vector<i64> ans(m + 1);",
			"    for (int i = 1;i <= m;i++) {",
			"        auto [ql, qr, id] = q[i];",
			"",
			"        if (b[ql] == b[qr]) {",
			"            //暴力",
			"            for (int j = ql;j <= qr;j++);",
			"            //遍历答案",
			"            for (int j = ql;j <= qr;j++);",
			"            //撤销",
			"            for (int j = ql;j <= qr;j++);",
			"            continue;",
			"        }",
			"",
			"        auto add = [&](int x, i64& res) {};",
			"        auto del = [&](int x) {};",
			"",
			"        //若当前更新到了一个新的块",
			"        if (b[ql] != cur_block) {",
			"            while (r > b[ql] * block) del(w[r--]);",
			"            while (l < b[ql] * block + 1) del(w[l++]);",
			"            res = 0;",
			"            cur_block = b[ql];",
			"        }",
			"        //先移动右指针",
			"        while (r < qr) add(w[++r], res);",
			"        tmpl = l;",
			"        i64 tmpres = res;",
			"        //查询答案",
			"        while (tmpl > ql) add(w[--tmpl], tmpres);",
			"        ans[id] = tmpres;",
			"        //回滚",
			"        while (tmpl < l) del(w[tmpl++]);",
			"    }",
			"",
			"    for (int i = 1;i <= m;i++)   std::cout << ans[i] << '\\n';",
			"}"
		],
		"description": "Code"
	},
	"set": {
		"scope": "cpp",
		"prefix": "set",
		"body": [
			"namespace Set {",
			"    const int kInf = 1e9 + 2077;",
			"    std::multiset<int> less, greater;",
			"    void init() {",
			"        less.clear(), greater.clear();",
			"        less.insert(-kInf), greater.insert(kInf);",
			"    }",
			"    void adjust() {",
			"        while (less.size() > greater.size() + 1) {",
			"            std::multiset<int>::iterator it = (--less.end());",
			"            greater.insert(*it);",
			"            less.erase(it);",
			"        }",
			"        while (greater.size() > less.size()) {",
			"            std::multiset<int>::iterator it = greater.begin();",
			"            less.insert(*it);",
			"            greater.erase(it);",
			"        }",
			"    }",
			"    void add(int val_) {",
			"        if (val_ <= *greater.begin()) less.insert(val_);",
			"        else greater.insert(val_);",
			"        adjust();",
			"    }",
			"    void del(int val_) {",
			"        std::multiset<int>::iterator it = less.lower_bound(val_);",
			"        if (it != less.end()) {",
			"            less.erase(it);",
			"        }",
			"        else {",
			"            it = greater.std::lower_bound(val_);",
			"            greater.erase(it);",
			"        }",
			"        adjust();",
			"    }",
			"    int get_middle() {",
			"        return *less.rbegin();",
			"    }",
			"}"
		],
		"description": "对顶堆"
	},
	"kdt": {
		"scope": "cpp",
		"prefix": "kdt",
		"body": [
			"struct KDT {",
			"    constexpr static int N = 1e5 + 10, K = 2;",
			"    double alpha = 0.725;",
			"    struct node {",
			"        int info[K];",
			"        int mn[K], mx[K];",
			"    } tr[N];",
			"    int ls[N], rs[N], siz[N], id[N], d[N];",
			"    int idx, rt, cur;",
			"    int ans;",
			"    KDT() {",
			"        rt = 0;",
			"        cur = 0;",
			"        std::memset(ls, 0, sizeof ls);",
			"        std::memset(rs, 0, sizeof rs);",
			"        std::memset(d, 0, sizeof d);",
			"    }",
			"    void apply(int p, int son) {",
			"        if (son) {",
			"            for (int i = 0; i < K; i++) {",
			"                tr[p].mn[i] = std::min(tr[p].mn[i], tr[son].mn[i]);",
			"                tr[p].mx[i] = std::max(tr[p].mx[i], tr[son].mx[i]);",
			"            }",
			"            siz[p] += siz[son];",
			"        }",
			"    }",
			"    void maintain(int p) {",
			"        for (int i = 0; i < K; i++) {",
			"            tr[p].mn[i] = tr[p].info[i];",
			"            tr[p].mx[i] = tr[p].info[i];",
			"        }",
			"        siz[p] = 1;",
			"        apply(p, ls[p]);",
			"        apply(p, rs[p]);",
			"    }",
			"    int build(int l, int r) {",
			"        if (l > r) return 0;",
			"        std::vector<double> avg(K);",
			"        for (int i = 0; i < K; i++) {",
			"            for (int j = l; j <= r; j++) {",
			"                avg[i] += tr[id[j]].info[i];",
			"            }",
			"            avg[i] /= (r - l + 1);",
			"        }",
			"        std::vector<double> var(K);",
			"        for (int i = 0; i < K; i++) {",
			"            for (int j = l; j <= r; j++) {",
			"                var[i] += (tr[id[j]].info[i] - avg[i]) * (tr[id[j]].info[i] - avg[i]);",
			"            }",
			"        }",
			"        int mid = (l + r) / 2;",
			"        int x = max_element(var.begin(), var.end()) - var.begin();",
			"        nth_element(id + l, id + mid, id + r + 1, [&](int a, int b) {",
			"            return tr[a].info[x] < tr[b].info[x];",
			"        });",
			"        d[id[mid]] = x;",
			"        ls[id[mid]] = build(l, mid - 1);",
			"        rs[id[mid]] = build(mid + 1, r);",
			"        maintain(id[mid]);",
			"        return id[mid];",
			"    }",
			"    void print(int p) {",
			"        if (!p) return;",
			"        print(ls[p]);",
			"        id[++idx] = p;",
			"        print(rs[p]);",
			"    }",
			"    void rebuild(int &p) {",
			"        idx = 0;",
			"        print(p);",
			"        p = build(1, idx);",
			"    }",
			"    bool bad(int p) {",
			"        return alpha * siz[p] <= std::max(siz[ls[p]], siz[rs[p]]);",
			"    }",
			"    void insert(int &p, int cur) {",
			"        if (!p) {",
			"            p = cur;",
			"            maintain(p);",
			"            return;",
			"        }",
			"        if (tr[p].info[d[p]] > tr[cur].info[d[p]]) insert(ls[p], cur);",
			"        else insert(rs[p], cur);",
			"        maintain(p);",
			"        if (bad(p)) rebuild(p);",
			"    }",
			"    void insert(std::vector<int> &a) {",
			"        cur++;",
			"        for (int i = 0; i < K; i++) {",
			"            tr[cur].info[i] = a[i];",
			"        }",
			"        insert(rt, cur);",
			"    }",
			"    bool out(int p, std::vector<int> &a) {",
			"        for (int i = 0; i < K; i++) {",
			"            if (a[i] < tr[p].mn[i]) {",
			"                return true;",
			"            }",
			"        }",
			"        return false;",
			"    }",
			"    bool in(int p, std::vector<int> &a) {",
			"        for (int i = 0; i < K; i++) {",
			"            if (a[i] < tr[p].info[i]) {",
			"                return false;",
			"            }",
			"        }",
			"        return true;",
			"    }",
			"    bool all(int p, std::vector<int> &a) {",
			"        for (int i = 0; i < K; i++) {",
			"            if (a[i] < tr[p].mx[i]) {",
			"                return false;",
			"            }",
			"        }",
			"        return true;",
			"    }",
			"    void query(int p, std::vector<int> &a) {",
			"        if (!p) return;",
			"        if (out(p, a)) return;",
			"        if (all(p, a)) {",
			"            ans += siz[p];",
			"            return;",
			"        }",
			"        if (in(p, a)) ans++;",
			"        query(ls[p], a);",
			"        query(rs[p], a);",
			"    }",
			"    int query(std::vector<int> &a) {",
			"        ans = 0;",
			"        query(rt, a);",
			"        return ans;",
			"    }",
			"};"
		],
		"description": "Kdt"
	},
	"rmq": {
		"scope": "cpp",
		"prefix": "rmq",
		"body": [
			"template<typename T, typename Cmp = less<T>> struct RMQ {",
			"    const Cmp cmp = Cmp();",
			"    static constexpr unsigned B = 64;",
			"    using u64 = unsigned long long;",
			"    int n;",
			"    std::vector<std::vector<T>> a;",
			"    std::vector<T> pre, suf, ini;",
			"    std::vector<u64> stk;",
			"    RMQ() {}",
			"    RMQ(const std::vector<T> &v) {",
			"        init(v);",
			"    }",
			"    void init(const std::vector<T> &v) {",
			"        n = v.size();",
			"        pre = suf = ini = v;",
			"        stk.resize(n);",
			"        if (!n) {",
			"            return;",
			"        }",
			"        const int M = (n - 1) / B + 1;",
			"        const int lg = __lg(M);",
			"        a.assign(lg + 1, std::vector<T>(M));",
			"        for (int i = 0; i < M; i++) {",
			"            a[0][i] = v[i * B];",
			"            for (int j = 1; j < B && i * B + j < n; j++) {",
			"                a[0][i] = std::min(a[0][i], v[i * B + j], cmp);",
			"            }",
			"        }",
			"        for (int i = 1; i < n; i++) {",
			"            if (i % B) {",
			"                pre[i] = std::min(pre[i], pre[i - 1], cmp);",
			"            }",
			"        }",
			"        for (int i = n - 2; i >= 0; i--) {",
			"            if (i % B != B - 1) {",
			"                suf[i] = std::min(suf[i], suf[i + 1], cmp);",
			"            }",
			"        }",
			"        for (int j = 0; j < lg; j++) {",
			"            for (int i = 0; i + (2 << j) <= M; i++) {",
			"                a[j + 1][i] = std::min(a[j][i], a[j][i + (1 << j)], cmp);",
			"            }",
			"        }",
			"        for (int i = 0; i < M; i++) {",
			"            const int l = i * B;",
			"            const int r = std::min(1U * n, l + B);",
			"            u64 s = 0;",
			"            for (int j = l; j < r; j++) {",
			"                while (s && cmp(v[j], v[__lg(s) + l])) {",
			"                    s ^= 1ULL << __lg(s);",
			"                }",
			"                s |= 1ULL << (j - l);",
			"                stk[j] = s;",
			"            }",
			"        }",
			"    }",
			"    T operator()(int l, int r) {",
			"        if (l / B != (r - 1) / B) {",
			"            T ans = std::min(suf[l], pre[r - 1], cmp);",
			"            l = l / B + 1;",
			"            r = r / B;",
			"            if (l < r) {",
			"                int k = __lg(r - l);",
			"                ans = std::min({ans, a[k][l], a[k][r - (1 << k)]}, cmp);",
			"            }",
			"            return ans;",
			"        } else {",
			"            int x = B * (l / B);",
			"            return ini[__builtin_ctzll(stk[r - 1] >> (l - x)) + l];",
			"        }",
			"    }",
			"};"
		],
		"description": "Rmq"
	},
	"odt": {
		"scope": "cpp",
		"prefix": "odt",
		"body": [
			"struct ODT {",
			"    struct node {",
			"        int l, r;",
			"        mutable LL v;",
			"        node(int l, int r = -1, LL v = 0) : l(l), r(r), v(v) {}",
			"        bool operator<(const node &o) const {",
			"            return l < o.l;",
			"        }",
			"    };",
			"    std::set<node> s;",
			"    ODT() {",
			"        s.clear();",
			"    }",
			"    auto split(int pos) {",
			"        auto it = s.std::lower_bound(node(pos));",
			"        if (it != s.end() && it->l == pos) return it;",
			"        it--;",
			"        int l = it->l, r = it->r;",
			"        LL v = it->v;",
			"        s.erase(it);",
			"        s.insert(node(l, pos - 1, v));",
			"        return s.insert(node(pos, r, v)).first;",
			"    }",
			"    void assign(int l, int r, LL x) {",
			"        auto itr = split(r + 1), itl = split(l);",
			"        s.erase(itl, itr);",
			"        s.insert(node(l, r, x));",
			"    }",
			"    void add(int l, int r, LL x) {",
			"        auto itr = split(r + 1), itl = split(l);",
			"        for (auto it = itl; it != itr; it++) {",
			"            it->v += x;",
			"        }",
			"    }",
			"    LL kth(int l, int r, int k) {",
			"        std::vector<std::pair<LL, int>> a;",
			"        auto itr = split(r + 1), itl = split(l);",
			"        for (auto it = itl; it != itr; it++) {",
			"            a.push_back(std::pair<LL, int>(it->v, it->r - it->l + 1));",
			"        }",
			"        std::sort(a.begin(), a.end());",
			"        for (auto [val, len] : a) {",
			"            k -= len;",
			"            if (k <= 0) return val;",
			"        }",
			"    }",
			"    LL power(LL a, int b, int mod) {",
			"        a %= mod;",
			"        LL res = 1;",
			"        for (; b; b /= 2, a = a * a % mod) {",
			"            if (b % 2) {",
			"                res = res * a % mod;",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"    LL powersum(int l, int r, int x, int mod) {",
			"        auto itr = split(r + 1), itl = split(l);",
			"        LL ans = 0;",
			"        for (auto it = itl; it != itr; it++) {",
			"            ans = (ans + power(it->v, x, mod) * (it->r - it->l + 1) % mod) % mod;",
			"        }",
			"        return ans;",
			"    }",
			"};"
		],
		"description": "Odt"
	},
}
