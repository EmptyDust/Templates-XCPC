{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"get_next": {
		"scope": "cpp",
		"prefix": "get_next",
		"body": [
			"std::vector<int> get_next(std::string& t) {",
			"    std::vector<int> next(t.size());",
			"    next[0] = -1;",
			"    for (int i = 0, j = -1; i < (int)t.size();) {",
			"        if (j == -1 || t[i] == t[j]) {",
			"            ++i, ++j;",
			"            next[i] = j;",
			"        }",
			"        else",
			"            j = next[j];",
			"    }",
			"    return next;",
			"}"
		],
		"description": "Get Next"
	},
	"kmp": {
		"scope": "cpp",
		"prefix": "kmp",
		"body": [
			"bool kmp(std::string& s, std::string& t) {",
			"    if (t.length() > s.length())return false;",
			"    auto next = get_next(t);",
			"",
			"    for (int i = 0, j = 0; i < (int)s.size() && j < (int)t.size();) {",
			"        if (j == -1 || s[i] == t[j]) {",
			"            ++i, ++j;",
			"        }",
			"        else",
			"            j = next[j];",
			"        if (j == (int)t.size())return true;",
			"    }",
			"    return false;",
			"}"
		],
		"description": "Kmp"
	},
	"z_function": {
		"scope": "cpp",
		"prefix": "z_function",
		"body": [
			"std::vector<int> z_function(std::string s) {",
			"    int n = (int)s.length();",
			"    std::vector<int> z(n);",
			"    for (int i = 1, l = 0, r = 0; i < n; ++i) {",
			"        if (i <= r && z[i - l] < r - i + 1) {",
			"            z[i] = z[i - l];",
			"        }",
			"        else {",
			"            z[i] = std::max(0, r - i + 1);",
			"            while (i + z[i] < n && s[z[i]] == s[i + z[i]]) ++z[i];",
			"        }",
			"        if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;",
			"    }",
			"    return z;",
			"}"
		],
		"description": "Z Function"
	},
	"lcs": {
		"scope": "cpp",
		"prefix": "lcs",
		"body": [
			"const int N = 1e3 + 10;",
			"char a[N], b[N];",
			"int n, m, f[N][N];",
			"void solve(){",
			"    std::cin >> n >> m >> a + 1 >> b + 1;",
			"    for (int i = 1; i <= n; i++)",
			"        for (int j = 1; j <= m; j++){",
			"            f[i][j] = std::max(f[i - 1][j], f[i][j - 1]);",
			"            if (a[i] == b[j]) f[i][j] = std::max(f[i][j], f[i - 1][j - 1] + 1);",
			"        }",
			"    cout << f[n][m] << \"\\n\";",
			"}",
			"int main(){",
			"    solve();",
			"    return 0;",
			"}"
		],
		"description": "Lcs"
	},
	"lcs_1": {
		"scope": "cpp",
		"prefix": "lcs",
		"body": [
			"const int INF = 0x7fffffff;",
			"int n, a[maxn], b[maxn], f[maxn], p[maxn];",
			"int main(){",
			"    std::cin >> n;",
			"    for (int i = 1; i <= n; i++){",
			"        scanf(\"%d\", &a[i]);",
			"        p[a[i]] = i;  //将第二个序列中的元素映射到第一个中",
			"    }",
			"    for (int i = 1; i <= n; i++){",
			"        scanf(\"%d\", &b[i]);",
			"        f[i] = INF;",
			"    }",
			"    int len = 0;",
			"    f[0] = 0;",
			"    for (int i = 1; i <= n; i++){",
			"        if (p[b[i]] > f[len]) f[++len] = p[b[i]];",
			"        else {",
			"            int l = 0, r = len;",
			"            while (l < r){",
			"                int mid = (l + r) >> 1;",
			"                if (f[mid] > p[b[i]]) r = mid;",
			"                else l = mid + 1;",
			"            }",
			"            f[l] = std::min(f[l], p[b[i]]);",
			"        }",
			"    }",
			"    cout << len << \"\\n\";",
			"    return 0;",
			"}"
		],
		"description": "Lcs"
	},
	"string": {
		"scope": "cpp",
		"prefix": "string",
		"body": [
			"const int N = 1 << 21;",
			"static const int mod1 = 1E9 + 7, base1 = 127;",
			"static const int mod2 = 1E9 + 9, base2 = 131;",
			"using U = Zmod<mod1>;",
			"using V = Zmod<mod2>;",
			"std::vector<U> val1;",
			"std::vector<V> val2;",
			"void init(int n = N) {",
			"    val1.resize(n + 1), val2.resize(n + 2);",
			"    val1[0] = 1, val2[0] = 1;",
			"    for (int i = 1; i <= n; i++) {",
			"        val1[i] = val1[i - 1] * base1;",
			"        val2[i] = val2[i - 1] * base2;",
			"    }",
			"}",
			"struct String {",
			"    std::vector<U> hash1;",
			"    std::vector<V> hash2;",
			"    std::string s;",
			"",
			"    String(std::string s_) : s(s_), hash1{1}, hash2{1} {",
			"        for (auto it : s) {",
			"            hash1.push_back(hash1.back() * base1 + it);",
			"            hash2.push_back(hash2.back() * base2 + it);",
			"        }",
			"    }",
			"    std::pair<U, V> get() { // 输出整串的哈希值",
			"        return {hash1.back(), hash2.back()};",
			"    }",
			"    std::pair<U, V> substring(int l, int r) { // 输出子串的哈希值",
			"        if (l > r) std::swap(l, r);",
			"        U ans1 = hash1[r + 1] - hash1[l] * val1[r - l + 1];",
			"        V ans2 = hash2[r + 1] - hash2[l] * val2[r - l + 1];",
			"        return {ans1, ans2};",
			"    }",
			"    std::pair<U, V> modify(int idx, char x) { // 修改 idx 位为 x",
			"        int n = s.size() - 1;",
			"        U ans1 = hash1.back() + val1[n - idx] * (x - s[idx]);",
			"        V ans2 = hash2.back() + val2[n - idx] * (x - s[idx]);",
			"        return {ans1, ans2};",
			"    }",
			"};"
		],
		"description": "String"
	},
	"compress": {
		"scope": "cpp",
		"prefix": "compress",
		"body": [
			"std::string compress(std::vector<std::string> in) { // 前后缀压缩",
			"    std::vector<U> hash1{1};",
			"    std::vector<V> hash2{1};",
			"    string ans = \"#\";",
			"    for (auto s : in) {",
			"        s = \"#\" + s;",
			"        int st = 0;",
			"        U chk1 = 0;",
			"        V chk2 = 0;",
			"        for (int j = 1; j < s.size() && j < ans.size(); j++) {",
			"            chk1 = chk1 * base1 + s[j];",
			"            chk2 = chk2 * base2 + s[j];",
			"            if ((hash1.back() == hash1[ans.size() - 1 - j] * val1[j] + chk1) &&",
			"                (hash2.back() == hash2[ans.size() - 1 - j] * val2[j] + chk2)) {",
			"                st = j;",
			"            }",
			"        }",
			"        for (int j = st + 1; j < s.size(); j++) {",
			"            ans += s[j];",
			"            hash1.push_back(hash1.back() * base1 + s[j]);",
			"            hash2.push_back(hash2.back() * base2 + s[j]);",
			"        }",
			"    }",
			"    return ans.substr(1);",
			"}"
		],
		"description": "Compress"
	},
	"manachar": {
		"scope": "cpp",
		"prefix": "manachar",
		"body": [
			"struct Manachar {",
			"    std::vector<int> d1, d2;",
			"    Manachar(std::string s) {",
			"        int n = s.length();",
			"        d1.assign(n, 0);",
			"        d2.assign(n, 0);",
			"        for (int i = 0, l = 0, r = -1;i < n;++i) {",
			"            int k = (i > r) ? 1 : std::min(d1[l + r - i], r - i + 1);",
			"            while (i + k < n && i - k >= 0 && s[i + k] == s[i - k])k++;",
			"            d1[i] = k--;",
			"            if (i + k > r) {",
			"                r = i + k;",
			"                l = i - k;",
			"            }",
			"        }",
			"        for (int i = 0, l = 0, r = -1;i < n;++i) {",
			"            int k = (i > r) ? 0 : std::min(d2[l + r - i + 1], r - i + 1);",
			"            while (i + k < n && i - k - 1 >= 0 && s[i + k] == s[i - k - 1])k++;",
			"            d2[i] = k--;",
			"            if (i + k > r) {",
			"                r = i + k;",
			"                l = i - k - 1;",
			"            }",
			"        }",
			"    }",
			"    bool check(int l, int r) {",
			"        if (r < l)return false;",
			"        int len = r - l + 1;",
			"        if (len % 2) {",
			"            return d1[l + len / 2] * 2 - 1 < len;",
			"        }",
			"        else {",
			"            return d2[l + len / 2] * 2 < len;",
			"        }",
			"    }",
			"};"
		],
		"description": "Manachar"
	},
	"trie": {
		"scope": "cpp",
		"prefix": "trie",
		"body": [
			"struct Trie {",
			"    int ch[N][63], cnt[N], idx = 0;",
			"    std::map<char, int> mp;",
			"    void init() {",
			"        LL id = 0;",
			"        for (char c = 'a'; c <= 'z'; c++) mp[c] = ++id;",
			"        for (char c = 'A'; c <= 'Z'; c++) mp[c] = ++id;",
			"        for (char c = '0'; c <= '9'; c++) mp[c] = ++id;",
			"    }",
			"    void insert(std::string s) {",
			"        int u = 0;",
			"        for (int i = 0; i < s.size(); i++) {",
			"            int v = mp[s[i]];",
			"            if (!ch[u][v]) ch[u][v] = ++idx;",
			"            u = ch[u][v];",
			"            cnt[u]++;",
			"        }",
			"    }",
			"    LL query(std::string s) {",
			"        int u = 0;",
			"        for (int i = 0; i < s.size(); i++) {",
			"            int v = mp[s[i]];",
			"            if (!ch[u][v]) return 0;",
			"            u = ch[u][v];",
			"        }",
			"        return cnt[u];",
			"    }",
			"    void Clear() {",
			"        for (int i = 0; i <= idx; i++) {",
			"            cnt[i] = 0;",
			"            for (int j = 0; j <= 62; j++) {",
			"                ch[i][j] = 0;",
			"            }",
			"        }",
			"        idx = 0;",
			"    }",
			"} trie;"
		],
		"description": "Trie"
	},
	"trie_1": {
		"scope": "cpp",
		"prefix": "trie",
		"body": [
			"struct Trie {",
			"    int n, idx;",
			"    std::vector<std::vector<int>> ch;",
			"    Trie(int n) {",
			"        this->n = n;",
			"        idx = 0;",
			"        ch.resize(30 * (n + 1), std::vector<int>(2));",
			"    }",
			"    void insert(int x) {",
			"        int u = 0;",
			"        for (int i = 30; ~i; i--) {",
			"            int &v = ch[u][x >> i & 1];",
			"            if (!v) v = ++idx;",
			"            u = v;",
			"        }",
			"    }",
			"    int query(int x) {",
			"        int u = 0, res = 0;",
			"        for (int i = 30; ~i; i--) {",
			"            int v = x >> i & 1;",
			"            if (ch[u][!v]) {",
			"                res += (1 << i);",
			"                u = ch[u][!v];",
			"            } else {",
			"                u = ch[u][v];",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"};"
		],
		"description": "Trie"
	},
	"suffixarray": {
		"scope": "cpp",
		"prefix": "suffixarray",
		"body": [
			"struct SuffixArray {",
			"    int n;",
			"    std::vector<int> sa, rk, lc;",
			"    SuffixArray(const std::string &s) {",
			"        n = s.length();",
			"        sa.resize(n);",
			"        lc.resize(n - 1);",
			"        rk.resize(n);",
			"        std::iota(sa.begin(), sa.end(), 0);",
			"        std::sort(sa.begin(), sa.end(), [&](int a, int b) { return s[a] < s[b]; });",
			"        rk[sa[0]] = 0;",
			"        for (int i = 1; i < n; ++i) {",
			"            rk[sa[i]] = rk[sa[i - 1]] + (s[sa[i]] != s[sa[i - 1]]);",
			"        }",
			"        int k = 1;",
			"        std::vector<int> tmp, cnt(n);",
			"        tmp.reserve(n);",
			"        while (rk[sa[n - 1]] < n - 1) {",
			"            tmp.clear();",
			"            for (int i = 0; i < k; ++i) {",
			"                tmp.push_back(n - k + i);",
			"            }",
			"            for (auto i : sa) {",
			"                if (i >= k) {",
			"                    tmp.push_back(i - k);",
			"                }",
			"            }",
			"            std::fill(cnt.begin(), cnt.end(), 0);",
			"            for (int i = 0; i < n; ++i) {",
			"                ++cnt[rk[i]];",
			"            }",
			"            for (int i = 1; i < n; ++i) {",
			"                cnt[i] += cnt[i - 1];",
			"            }",
			"            for (int i = n - 1; i >= 0; --i) {",
			"                sa[--cnt[rk[tmp[i]]]] = tmp[i];",
			"            }",
			"            std::swap(rk, tmp);",
			"            rk[sa[0]] = 0;",
			"            for (int i = 1; i < n; ++i) {",
			"                rk[sa[i]] = rk[sa[i - 1]] + (tmp[sa[i - 1]] < tmp[sa[i]] || sa[i - 1] + k == n ||",
			"                                             tmp[sa[i - 1] + k] < tmp[sa[i] + k]);",
			"            }",
			"            k *= 2;",
			"        }",
			"        for (int i = 0, j = 0; i < n; ++i) {",
			"            if (rk[i] == 0) {",
			"                j = 0;",
			"                continue;",
			"            }",
			"            for (j -= j > 0;",
			"                 i + j < n && sa[rk[i] - 1] + j < n && s[i + j] == s[sa[rk[i] - 1] + j];) {",
			"                ++j;",
			"            }",
			"            lc[rk[i] - 1] = j;",
			"        }",
			"    }",
			"};"
		],
		"description": "Suffixarray"
	},
	"acautomaton": {
		"scope": "cpp",
		"prefix": "acautomaton",
		"body": [
			"// Trie+Kmp，多模式串匹配",
			"struct ACAutomaton {",
			"    static constexpr int N = 1e6 + 10;",
			"    int ch[N][26], fail[N], cntNodes;",
			"    int cnt[N];",
			"    ACAutomaton() {",
			"        cntNodes = 1;",
			"    }",
			"    void insert(std::string s) {",
			"        int u = 1;",
			"        for (auto c : s) {",
			"            int &v = ch[u][c - 'a'];",
			"            if (!v) v = ++cntNodes;",
			"            u = v;",
			"        }",
			"        cnt[u]++;",
			"    }",
			"    void build() {",
			"        std::fill(ch[0], ch[0] + 26, 1);",
			"        std::queue<int> q;",
			"        q.push(1);",
			"        while (!q.empty()) {",
			"            int u = q.front();",
			"            q.pop();",
			"            for (int i = 0; i < 26; i++) {",
			"                int &v = ch[u][i];",
			"                if (!v)",
			"                    v = ch[fail[u]][i];",
			"                else {",
			"                    fail[v] = ch[fail[u]][i];",
			"                    q.push(v);",
			"                }",
			"            }",
			"        }",
			"    }",
			"    LL query(std::string t) {",
			"        LL ans = 0;",
			"        int u = 1;",
			"        for (auto c : t) {",
			"            u = ch[u][c - 'a'];",
			"            for (int v = u; v && ~cnt[v]; v = fail[v]) {",
			"                ans += cnt[v];",
			"                cnt[v] = -1;",
			"            }",
			"        }",
			"        return ans;",
			"    }",
			"};"
		],
		"description": "Acautomaton"
	},
	"ahocorasick": {
		"scope": "cpp",
		"prefix": "ahocorasick",
		"body": [
			"struct AhoCorasick {",
			"    static constexpr int ALPHABET = 26;",
			"    struct Node {",
			"        int len;",
			"        int link;",
			"        std::array<int, ALPHABET> next;",
			"        Node() : len{ 0 }, link{ 0 }, next{} {}",
			"    };",
			"",
			"    std::vector<Node> t;",
			"",
			"    AhoCorasick() {",
			"        init();",
			"    }",
			"",
			"    void init() {",
			"        t.assign(2, Node());",
			"        t[0].next.std::fill(1);",
			"        t[0].len = -1;",
			"    }",
			"",
			"    int newNode() {",
			"        t.emplace_back();",
			"        return t.size() - 1;",
			"    }",
			"",
			"    int add(const std::string& a) {",
			"        int p = 1;",
			"        for (auto c : a) {",
			"            int x = c - 'a';",
			"            if (t[p].next[x] == 0) {",
			"                t[p].next[x] = newNode();",
			"                t[t[p].next[x]].len = t[p].len + 1;",
			"            }",
			"            p = t[p].next[x];",
			"        }",
			"        return p;",
			"    }",
			"",
			"    void get_fail() {",
			"        std::queue<int> q;",
			"        q.push(1);",
			"",
			"        while (!q.empty()) {",
			"            int x = q.front();",
			"            q.pop();",
			"",
			"            for (int i = 0; i < ALPHABET; i++) {",
			"                if (t[x].next[i] == 0) {",
			"                    t[x].next[i] = t[t[x].link].next[i];",
			"                }",
			"                else {",
			"                    t[t[x].next[i]].link = t[t[x].link].next[i];",
			"                    q.push(t[x].next[i]);",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    std::vector<int> work(std::string s) {",
			"        get_fail();",
			"        int p = 1;",
			"        std::vector<int> f(t.size());",
			"        for (auto c : s) {",
			"            p = next(p, c - 'a');",
			"            f[p]++;",
			"        }",
			"",
			"        std::vector<std::vector<int>> adj(t.size());",
			"        for (int i = 2; i < t.size(); i++) {",
			"            adj[link(i)].push_back(i);",
			"        }",
			"",
			"        std::function<void(int)> dfs = [&](int x) -> void {",
			"            for (auto y : adj[x]) {",
			"                dfs(y);",
			"                f[x] += f[y];",
			"            }",
			"            };",
			"        dfs(1);",
			"        return f;",
			"    }",
			"",
			"    int next(int p, int x) {",
			"        return t[p].next[x];",
			"    }",
			"",
			"    int link(int p) {",
			"        return t[p].link;",
			"    }",
			"",
			"    int len(int p) {",
			"        return t[p].len;",
			"    }",
			"",
			"    int size() {",
			"        return t.size();",
			"    }",
			"};"
		],
		"description": "Ahocorasick"
	},
	"palindromeautomaton": {
		"scope": "cpp",
		"prefix": "palindromeautomaton",
		"body": [
			"struct PalindromeAutomaton {",
			"    constexpr static int N = 5e5 + 10;",
			"    int tr[N][26], fail[N], len[N];",
			"    int cntNodes, last;",
			"    int dep[N]; //记录深度",
			"    int cnt[N]; //记录出现次数",
			"    std::string s;",
			"    PalindromeAutomaton(std::string s) {",
			"        std::memset(tr, 0, sizeof tr);",
			"        std::memset(fail, 0, sizeof fail);",
			"        std::memset(dep, 0, sizeof dep);",
			"        std::memset(cnt, 0, sizeof cnt);",
			"        len[0] = 0, fail[0] = 1;",
			"        len[1] = -1, fail[1] = 0;",
			"        cntNodes = 1;",
			"        last = 0;",
			"        this->s = s;",
			"    }",
			"    void insert(char c, int i) {",
			"        int u = get_fail(last, i);",
			"        if (!tr[u][c - 'a']) {",
			"            int v = ++cntNodes;",
			"            fail[v] = tr[get_fail(fail[u], i)][c - 'a'];",
			"            tr[u][c - 'a'] = v;",
			"            len[v] = len[u] + 2;",
			"            dep[v] = dep[fail[v]] + 1;",
			"        }",
			"        last = tr[u][c - 'a'];",
			"        cnt[last] += 1;",
			"    }",
			"    void countAll() {",
			"        for (int i = cntNodes;i >= 0;i--)",
			"            cnt[fail[i]] += cnt[i];",
			"    }",
			"    int get_fail(int u, int i) {",
			"        while (i - len[u] - 1 <= -1 || s[i - len[u] - 1] != s[i]) {",
			"            u = fail[u];",
			"        }",
			"        return u;",
			"    }",
			"};"
		],
		"description": "Palindromeautomaton"
	},
	"pam": {
		"scope": "cpp",
		"prefix": "pam",
		"body": [
			"const int TL = 10;",
			"const char BC = '0';",
			"struct PAM {",
			"    struct node",
			"    {",
			"        int len, link, cnt;",
			"        std::array<int, TL> next;",
			"    };",
			"    std::vector<node> nodes;",
			"    int last;",
			"    std::string s;",
			"    int n;",
			"    PAM(std::string& s) {",
			"        n = s.length();",
			"        nodes.reserve(n);",
			"        this->s = s;",
			"        nodes.assign(2, node());",
			"        last = 0;",
			"        nodes[0].len = 0;",
			"        nodes[0].link = 1;",
			"        nodes[1].len = -1;",
			"        nodes[1].link = 0;",
			"        for (int i = 0;i < n;++i) {",
			"            extend(s[i], i);",
			"        }",
			"    }",
			"    void extend(char ch, int p) {",
			"        int u = get_fail(last, p);",
			"        int c = ch - BC;",
			"        if (!nodes[u].next[c]) {",
			"            int v = nodes.size();",
			"            nodes.emplace_back();",
			"            nodes[v].link = nodes[get_fail(nodes[u].link, p)].next[c];",
			"            nodes[u].next[c] = v;",
			"            nodes[v].len = nodes[u].len + 2;",
			"        }",
			"        last = nodes[u].next[c];",
			"        nodes[last].cnt++;",
			"    }",
			"    int get_fail(int u, int i) {",
			"        while (i - nodes[u].len - 1 < 0 || s[i - nodes[u].len - 1] != s[i]) {",
			"            u = nodes[u].link;",
			"        }",
			"        return u;",
			"    }",
			"    void debug() {",
			"        for (auto node : nodes) {",
			"            std::cerr << node.cnt << ' ';",
			"            std::cerr << node.len << ' ';",
			"            std::cerr << node.link << '\\n';",
			"        }",
			"    }",
			"};"
		],
		"description": "Pam"
	},
	"suffixautomaton": {
		"scope": "cpp",
		"prefix": "suffixautomaton",
		"body": [
			"// 有向无环图",
			"struct SuffixAutomaton {",
			"    static constexpr int N = 1e6;",
			"    struct node {",
			"        int len, link, nxt[26];",
			"        int siz;",
			"    } t[N << 1];",
			"    int cntNodes;",
			"    SuffixAutomaton() {",
			"        cntNodes = 1;",
			"        std::fill(t[0].nxt, t[0].nxt + 26, 1);",
			"        t[0].len = -1;",
			"    }",
			"    int extend(int p, int c) {",
			"        if (t[p].nxt[c]) {",
			"            int q = t[p].nxt[c];",
			"            if (t[q].len == t[p].len + 1) {",
			"                return q;",
			"            }",
			"            int r = ++cntNodes;",
			"            t[r].siz = 0;",
			"            t[r].len = t[p].len + 1;",
			"            t[r].link = t[q].link;",
			"            copy(t[q].nxt, t[q].nxt + 26, t[r].nxt);",
			"            t[q].link = r;",
			"            while (t[p].nxt[c] == q) {",
			"                t[p].nxt[c] = r;",
			"                p = t[p].link;",
			"            }",
			"            return r;",
			"        }",
			"        int cur = ++cntNodes;",
			"        t[cur].len = t[p].len + 1;",
			"        t[cur].siz = 1;",
			"        while (!t[p].nxt[c]) {",
			"            t[p].nxt[c] = cur;",
			"            p = t[p].link;",
			"        }",
			"        t[cur].link = extend(p, c);",
			"        return cur;",
			"    }",
			"};"
		],
		"description": "Suffixautomaton"
	},
	"sam": {
		"scope": "cpp",
		"prefix": "sam",
		"body": [
			"struct SAM {",
			"    struct node {",
			"        int len, link, endpos, size;",
			"        std::map<char, int> next;",
			"        node() {",
			"            len = link = endpos = -1;",
			"            size = 0;",
			"            next = std::map<char, int>();",
			"        }",
			"    };",
			"    std::vector<node> nodes;",
			"    int last;",
			"    int n;",
			"",
			"    SAM(std::string& s) {",
			"        n = s.length();",
			"        nodes.reserve(2 * n);",
			"        nodes.assign(1, node());",
			"        nodes[0].len = 0;",
			"        nodes[0].link = -1;",
			"        last = 0;",
			"        for (int i = 0;i < n;++i) {",
			"            extend(s[i], i + 1);",
			"        }",
			"    }",
			"",
			"    void extend(char c, int pos) {",
			"        int cur = nodes.size();",
			"        nodes.emplace_back();",
			"        nodes[cur].len = nodes[last].len + 1;",
			"        int p = last;",
			"        while (p != -1 && !nodes[p].next.std::count(c)) {",
			"            nodes[p].next[c] = cur;",
			"            p = nodes[p].link;",
			"        }",
			"        if (p == -1) {",
			"            nodes[cur].link = 0;",
			"        }",
			"        else {",
			"            int q = nodes[p].next[c];",
			"            if (nodes[p].len + 1 == nodes[q].len) {",
			"                nodes[cur].link = q;",
			"            }",
			"            else {",
			"                int clone = nodes.size();",
			"                nodes.emplace_back();",
			"                nodes[clone].len = nodes[p].len + 1;",
			"                nodes[clone].link = nodes[q].link;",
			"                nodes[clone].next = nodes[q].next;",
			"                while (p != -1 && nodes[p].next[c] == q) {",
			"                    nodes[p].next[c] = clone;",
			"                    p = nodes[p].link;",
			"                }",
			"                nodes[q].link = nodes[cur].link = clone;",
			"            }",
			"        }",
			"        nodes[cur].endpos = pos;",
			"        nodes[cur].size = 1;",
			"        last = cur;",
			"    }",
			"",
			"    void debug() {",
			"        for (auto x : nodes) {",
			"            std::cerr << x.len << ' ';",
			"            std::cerr << x.link << ' ';",
			"            std::cerr << x.endpos << ' ';",
			"            std::cerr << x.size << ' ';",
			"            std::cerr << '\\n';",
			"        }",
			"    }",
			"};"
		],
		"description": "Sam"
	},
	"sequenceautomaton": {
		"scope": "cpp",
		"prefix": "sequenceautomaton",
		"body": [
			"template<typename T> struct SequenceAutomaton {",
			"    std::vector<T> alls;",
			"    std::vector<std::vector<int>> ver;",
			"",
			"    SequenceAutomaton(auto in) {",
			"        for (auto &i : in) {",
			"            alls.push_back(i);",
			"        }",
			"        std::sort(alls.begin(), alls.end());",
			"        alls.erase(std::unique(alls.begin(), alls.end()), alls.end());",
			"",
			"        ver.resize(alls.size() + 1);",
			"        for (int i = 0; i < in.size(); i++) {",
			"            ver[get(in[i])].push_back(i + 1);",
			"        }",
			"    }",
			"    bool std::count(T x) {",
			"        return std::binary_search(alls.begin(), alls.end(), x);",
			"    }",
			"    int get(T x) {",
			"        return std::lower_bound(alls.begin(), alls.end(), x) - alls.begin();",
			"    }",
			"    bool contains(auto in) {",
			"        int at = 0;",
			"        for (auto &i : in) {",
			"            if (!std::count(i)) {",
			"                return false;",
			"            }",
			"",
			"            auto j = get(i);",
			"            auto it = std::lower_bound(ver[j].begin(), ver[j].end(), at + 1);",
			"            if (it == ver[j].end()) {",
			"                return false;",
			"            }",
			"            at = *it;",
			"        }",
			"        return true;",
			"    }",
			"};"
		],
		"description": "Sequenceautomaton"
	},
	"sequenceautomaton_1": {
		"scope": "cpp",
		"prefix": "sequenceautomaton",
		"body": [
			"struct SequenceAutomaton {",
			"    std::vector<std::vector<int>> ver;",
			"",
			"    SequenceAutomaton(std::vector<int> &in, int size) : ver(size + 1) {",
			"        for (int i = 0; i < in.size(); i++) {",
			"            ver[in[i]].push_back(i + 1);",
			"        }",
			"    }",
			"    bool contains(std::vector<int> &in) {",
			"        int at = 0;",
			"        for (auto &i : in) {",
			"            auto it = std::lower_bound(ver[i].begin(), ver[i].end(), at + 1);",
			"            if (it == ver[i].end()) {",
			"                return false;",
			"            }",
			"            at = *it;",
			"        }",
			"        return true;",
			"    }",
			"};"
		],
		"description": "Sequenceautomaton"
	}
}
