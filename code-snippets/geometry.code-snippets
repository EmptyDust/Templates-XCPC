{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"geometry": {
		"scope": "cpp",
		"prefix": "geometry",
		"body": [
			"namespace computation_geometry {",
			"    using namespace std;",
			"    //计算几何",
			"    //点",
			"    struct Point {",
			"        double x, y;",
			"        Point() {};",
			"        Point(double x, double y) :x(x), y(y) {};",
			"",
			"        //减法(a-b)",
			"        Point operator-(Point& b) {",
			"            return { this->x - b.x,this->y - b.y };",
			"        }",
			"        //数乘",
			"        Point operator*(double t) const {",
			"            return { this->x * t,this->y * t };",
			"        }",
			"        //向量加法",
			"        Point operator+(Point& b) {",
			"            return Point{ this->x + b.x,this->y + b.y };",
			"        }",
			"        Point operator/(double t) {",
			"            return { this->x / t,this->y / t };",
			"        }",
			"    };",
			"",
			"    //求点积(x1*x2+y1*y2)",
			"    double dot(Point a, Point b) {",
			"        return a.x * b.x + a.y * b.y;",
			"    }",
			"    //求模长",
			"    double len(Point a) {",
			"        return sqrt(a.x * a.x + a.y * a.y);",
			"    }",
			"    //求夹角",
			"    double angle(Point a, Point b) {",
			"        return acos(dot(a, b) / len(a) / len(b));",
			"    }",
			"    //求叉积(a*b==x1*y2-x2*y1),b在a的逆时针方向值为正，否则为负",
			"    double cross(Point b, Point a, Point c = { 0,0 }) {",
			"        return ((a - c).x * (b - c).y) - ((a - c).y * (b - c).x);",
			"    }",
			"    //两点之间的距离",
			"    double dis(Point a, Point b) {",
			"        return sqrt(1.0 * (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));",
			"    }",
			"    //判断线线的位置关系",
			"    //1.直线ab与线段cd无交点：cross(a,b,c)*cross(a,b,d)>0",
			"    //2.直线ab与线段cd有交点：cross(a,b,c)*cross(a,b,d)<= 0",
			"    //计算直线交点au与bv",
			"    Point getNode(Point a, Point u, Point b, Point v) {",
			"        double t = cross((a - b), v) / cross(v, u);",
			"        u.x *= t, u.y *= t;",
			"        return a + u;",
			"    }",
			"    double eps = 1e-6;Point o = { 0,0 };",
			"    double PI = acos(-1), R;",
			"    Point p[4];",
			"    //三角剖分，计算多边形与圆的相交面积",
			"    Point rotate(Point a, double b) {//将线段旋转一定的角度",
			"        return Point(a.x * cos(b) - a.y * sin(b), a.x * sin(b) + a.y * cos(b));",
			"    }",
			"    Point norm(Point a) {//单位向量",
			"        return a / len(a);",
			"    }",
			"    bool onSegment(Point p, Point a, Point b) {//p在ab线段上",
			"        return fabs(cross(a - p, b - p) < eps) && (dot(a - p, b - p) <= 0);",
			"    }",
			"    double getDP2(Point a, Point b, Point& pa, Point& pb) {",
			"        Point e = getNode(a, b - a, o, rotate(b - a, PI / 2));//找到圆心与ab的垂足",
			"        double d = dis(o, e);",
			"        if (!onSegment(e, a, b)) d = std::min(dis(o, a), dis(o, b));",
			"        if (R <= d) return d;",
			"        double len = sqrt(R * R - dis(o, e) * dis(o, e));",
			"",
			"        pa = (norm(a - b) * len) + e;",
			"        pb = (norm(b - a) * len) + e;",
			"        return d;//d:线段到圆心的距离；pa,pb:直线与圆的交点",
			"    }",
			"    double sector(Point a, Point b) {//扇形面积",
			"        double angle = acos(dot(a, b) / len(a) / len(b));//[0,pi]",
			"        if (cross(a, b) < 0) angle = -angle;",
			"        return R * R * angle / 2;",
			"    }",
			"",
			"    double getArea(Point a, Point b) {//面积的交",
			"        if (fabs(cross(a, b)) < eps) return 0;//ab与圆心共线",
			"        double da = dis(o, a), db = dis(o, b);",
			"        if (R >= da && R >= db) return cross(a, b) / 2;//ab在圆内，R为直径",
			"        Point pa, pb;",
			"        double d = getDP2(a, b, pa, pb);",
			"        if (R <= d) return sector(a, b);//ab在圆外",
			"        if (R >= da) return cross(a, pb) / 2 + sector(pb, b);//a在圆外",
			"        if (R >= db) return sector(a, pa) + cross(pa, b) / 2;//b在圆内",
			"        return sector(a, pa) + cross(pa, pb) / 2 + sector(pb, b);//ab是割线",
			"    }",
			"",
			"",
			"    //凸包算法:Andrew算法",
			"    Point st[N], s[N];",
			"    int n;",
			"    int top;",
			"    double Andrew() {",
			"        sort(s + 1, s + n + 1, [&](Point a, Point b) {",
			"            return a.x != b.x ? a.x < b.x : a.y < b.y;",
			"            });",
			"        for (int i = 1;i <= n;i++) {//下凸包",
			"            while (top > 1 && cross(st[top], s[i], st[top - 1]) <= 0) top--;",
			"            st[++top] = s[i];",
			"        }",
			"        int t = top;",
			"        for (int i = n - 1;i >= 1;i--) {//上凸包",
			"            while (top > t && cross(st[top], s[i], st[top - 1]) <= 0) top--;",
			"            st[++top] = s[i];",
			"        }",
			"        double res = 0;//周长",
			"        for (int i = 1;i < top;i++) {",
			"            res += dis(st[i], st[i + 1]);",
			"        }",
			"        n = top - 1;//为了配合下面的旋转卡壳，只求凸包不用加",
			"        return res;",
			"    }",
			"",
			"    //旋转卡壳问题实例",
			"    //1.给定个点，求最远点对的距离",
			"    //先用Androw算法，求出凸包上的点数即n=top-1;",
			"    double rotating_calipers() {//旋转卡壳",
			"        double res = 0;",
			"        for (int i = 1, j = 2;i <= n;i++) {",
			"            while (cross(st[i + 1], st[j], st[i]) < cross(st[i + 1], st[j + 1], st[i])) j = j % n + 1;",
			"            res = max(res, max(dis(st[i], st[j]), dis(st[i + 1], s[j])));",
			"        }",
			"        return res;",
			"    }",
			"    double rotating_calipers2() {//求最大四边行的面积",
			"        double ans = 0;",
			"        for (int i = 1;i <= n;i++) {",
			"            int a = i, b = i + 1;//a为i到j之间的点，b为j到i之间的点",
			"            for (int j = i + 1;j <= n;j++) {",
			"                while (cross(st[j], st[a + 1], st[i]) < cross(st[j], st[a], st[i])) a = a % n + 1;",
			"                while (cross(st[j], st[b + 1], st[i]) > cross(st[j], st[b], st[i])) b = b % n + 1;",
			"                ans = max(ans, -cross(st[j], st[a], st[i]) + cross(st[j], st[b], st[i]));",
			"            }",
			"        }",
			"        return ans / 2;",
			"    }",
			"    void solve() {",
			"        std::cin >> n;",
			"        for (int i = 1;i <= n;++i)std::cin >> s[i].x >> s[i].y;",
			"        Andrew();",
			"        auto res = rotating_calipers();",
			"        int ans = res * res;",
			"        std::cout << ans;",
			"    }",
			"}"
		],
		"description": "geometry"
	},
	"point3": {
		"scope": "cpp",
		"prefix": "point3",
		"body": [
			"struct Point3 {",
			"    ld x, y, z;",
			"    Point3(ld x_ = 0, ld y_ = 0, ld z_ = 0) : x(x_), y(y_), z(z_) {}",
			"    Point3 &operator+=(Point3 p) & {",
			"        return x += p.x, y += p.y, z += p.z, *this;",
			"    }",
			"    Point3 &operator-=(Point3 p) & {",
			"        return x -= p.x, y -= p.y, z -= p.z, *this;",
			"    }",
			"    Point3 &operator*=(Point3 p) & {",
			"        return x *= p.x, y *= p.y, z *= p.z, *this;",
			"    }",
			"    Point3 &operator*=(ld t) & {",
			"        return x *= t, y *= t, z *= t, *this;",
			"    }",
			"    Point3 &operator/=(ld t) & {",
			"        return x /= t, y /= t, z /= t, *this;",
			"    }",
			"    friend Point3 operator+(Point3 a, Point3 b) { return a += b; }",
			"    friend Point3 operator-(Point3 a, Point3 b) { return a -= b; }",
			"    friend Point3 operator*(Point3 a, Point3 b) { return a *= b; }",
			"    friend Point3 operator*(Point3 a, ld b) { return a *= b; }",
			"    friend Point3 operator*(ld a, Point3 b) { return b *= a; }",
			"    friend Point3 operator/(Point3 a, ld b) { return a /= b; }",
			"    friend auto &operator>>(istream &is, Point3 &p) {",
			"        return is >> p.x >> p.y >> p.z;",
			"    }",
			"    friend auto &operator<<(ostream &os, Point3 p) {",
			"        return os << \"(\" << p.x << \", \" << p.y << \", \" << p.z << \")\";",
			"    }",
			"};",
			"struct Line3 {",
			"    Point3 a, b;",
			"};",
			"struct Plane {",
			"    Point3 u, v, w;",
			"};"
		],
		"description": "Point3"
	},
	"len": {
		"scope": "cpp",
		"prefix": "len",
		"body": [
			"ld len(P3 p) { // 原点到当前点的距离计算",
			"    return std::sqrt(p.x * p.x + p.y * p.y + p.z * p.z);",
			"}",
			"P3 crossEx(P3 a, P3 b) { // 叉乘",
			"    P3 ans;",
			"    ans.x = a.y * b.z - a.z * b.y;",
			"    ans.y = a.z * b.x - a.x * b.z;",
			"    ans.z = a.x * b.y - a.y * b.x;",
			"    return ans;",
			"}",
			"ld cross(P3 a, P3 b) {",
			"    return len(crossEx(a, b));",
			"}",
			"ld dot(P3 a, P3 b) { // 点乘",
			"    return a.x * b.x + a.y * b.y + a.z * b.z;",
			"}",
			"P3 getVec(Plane s) { // 获取平面法向量",
			"    return crossEx(s.u - s.v, s.v - s.w);",
			"}",
			"ld dis(P3 a, P3 b) { // 三维欧几里得距离公式",
			"    ld val = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) + (a.z - b.z) * (a.z - b.z);",
			"    return std::sqrt(val);",
			"}",
			"P3 standardize(P3 vec) { // 将三维向量转换为单位向量",
			"    return vec / len(vec);",
			"}"
		],
		"description": "Len"
	},
	"online": {
		"scope": "cpp",
		"prefix": "online",
		"body": [
			"bool onLine(P3 p1, P3 p2, P3 p3) { // 三点是否共线",
			"    return sign(cross(p1 - p2, p3 - p2)) == 0;",
			"}",
			"bool onLine(Plane s) {",
			"    return onLine(s.u, s.v, s.w);",
			"}"
		],
		"description": "Online"
	},
	"onplane": {
		"scope": "cpp",
		"prefix": "onplane",
		"body": [
			"bool onPlane(P3 p1, P3 p2, P3 p3, P3 p4) { // 四点是否共面",
			"    ld val = dot(getVec({p1, p2, p3}), p4 - p1);",
			"    return sign(val) == 0;",
			"}"
		],
		"description": "Onplane"
	},
	"pointonsegment": {
		"scope": "cpp",
		"prefix": "pointonsegment",
		"body": [
			"bool pointOnSegment(P3 p, L3 l) {",
			"    return sign(cross(p - l.a, p - l.b)) == 0 && std::min(l.a.x, l.b.x) <= p.x &&",
			"           p.x <= std::max(l.a.x, l.b.x) && std::min(l.a.y, l.b.y) <= p.y && p.y <= std::max(l.a.y, l.b.y) &&",
			"           std::min(l.a.z, l.b.z) <= p.z && p.z <= std::max(l.a.z, l.b.z);",
			"}",
			"bool pointOnSegmentEx(P3 p, L3 l) { // pointOnSegment去除端点版",
			"    return sign(cross(p - l.a, p - l.b)) == 0 && std::min(l.a.x, l.b.x) < p.x &&",
			"           p.x < std::max(l.a.x, l.b.x) && std::min(l.a.y, l.b.y) < p.y && p.y < std::max(l.a.y, l.b.y) &&",
			"           std::min(l.a.z, l.b.z) < p.z && p.z < std::max(l.a.z, l.b.z);",
			"}"
		],
		"description": "Pointonsegment"
	},
	"pointonsegmentside": {
		"scope": "cpp",
		"prefix": "pointonsegmentside",
		"body": [
			"bool pointOnSegmentSide(P3 p1, P3 p2, L3 l) {",
			"    if (!onPlane(p1, p2, l.a, l.b)) { // 特判不共面",
			"        return 0;",
			"    }",
			"    ld val = dot(crossEx(l.a - l.b, p1 - l.b), crossEx(l.a - l.b, p2 - l.b));",
			"    return sign(val) == 1;",
			"}"
		],
		"description": "Pointonsegmentside"
	},
	"pointonplaneside": {
		"scope": "cpp",
		"prefix": "pointonplaneside",
		"body": [
			"bool pointOnPlaneSide(P3 p1, P3 p2, Plane s) {",
			"    ld val = dot(getVec(s), p1 - s.u) * dot(getVec(s), p2 - s.u);",
			"    return sign(val) == 1;",
			"}"
		],
		"description": "Pointonplaneside"
	},
	"lineparallel": {
		"scope": "cpp",
		"prefix": "lineparallel",
		"body": [
			"bool lineParallel(L3 l1, L3 l2) {",
			"    return sign(cross(l1.a - l1.b, l2.a - l2.b)) == 0;",
			"}",
			"bool lineVertical(L3 l1, L3 l2) {",
			"    return sign(dot(l1.a - l1.b, l2.a - l2.b)) == 0;",
			"}"
		],
		"description": "Lineparallel"
	},
	"planeparallel": {
		"scope": "cpp",
		"prefix": "planeparallel",
		"body": [
			"bool planeParallel(Plane s1, Plane s2) {",
			"    ld val = cross(getVec(s1), getVec(s2));",
			"    return sign(val) == 0;",
			"}",
			"bool planeVertical(Plane s1, Plane s2) {",
			"    ld val = dot(getVec(s1), getVec(s2));",
			"    return sign(val) == 0;",
			"}"
		],
		"description": "Planeparallel"
	},
	"same": {
		"scope": "cpp",
		"prefix": "same",
		"body": [
			"bool same(L3 l1, L3 l2) {",
			"    return lineParallel(l1, l2) && lineParallel({l1.a, l2.b}, {l1.b, l2.a});",
			"}"
		],
		"description": "Same"
	},
	"same_1": {
		"scope": "cpp",
		"prefix": "same",
		"body": [
			"bool same(Plane s1, Plane s2) {",
			"    return onPlane(s1.u, s2.u, s2.v, s2.w) && onPlane(s1.v, s2.u, s2.v, s2.w) &&",
			"           onPlane(s1.w, s2.u, s2.v, s2.w);",
			"}"
		],
		"description": "Same"
	},
	"lineplaneparallel": {
		"scope": "cpp",
		"prefix": "lineplaneparallel",
		"body": [
			"bool linePlaneParallel(L3 l, Plane s) {",
			"    ld val = dot(l.a - l.b, getVec(s));",
			"    return sign(val) == 0;",
			"}"
		],
		"description": "Lineplaneparallel"
	},
	"segmentintersection": {
		"scope": "cpp",
		"prefix": "segmentintersection",
		"body": [
			"bool segmentIntersection(L3 l1, L3 l2) { // 重叠、相交于端点均视为相交",
			"    if (!onPlane(l1.a, l1.b, l2.a, l2.b)) { // 特判不共面",
			"        return 0;",
			"    }",
			"    if (!onLine(l1.a, l1.b, l2.a) || !onLine(l1.a, l1.b, l2.b)) {",
			"        return !pointOnSegmentSide(l1.a, l1.b, l2) && !pointOnSegmentSide(l2.a, l2.b, l1);",
			"    }",
			"    return pointOnSegment(l1.a, l2) || pointOnSegment(l1.b, l2) || pointOnSegment(l2.a, l1) ||",
			"           pointOnSegment(l2.b, l2);",
			"}",
			"bool segmentIntersection1(L3 l1, L3 l2) { // 重叠、相交于端点不视为相交",
			"    return onPlane(l1.a, l1.b, l2.a, l2.b) && !pointOnSegmentSide(l1.a, l1.b, l2) &&",
			"           !pointOnSegmentSide(l2.a, l2.b, l1);",
			"}"
		],
		"description": "Segmentintersection"
	},
	"lineintersection": {
		"scope": "cpp",
		"prefix": "lineintersection",
		"body": [
			"std::pair<bool, P3> lineIntersection(L3 l1, L3 l2) {",
			"    if (!onPlane(l1.a, l1.b, l2.a, l2.b) || lineParallel(l1, l2)) {",
			"        return {0, {}};",
			"    }",
			"    auto [s1, e1] = l1;",
			"    auto [s2, e2] = l2;",
			"    ld val = 0;",
			"    if (!onPlane(l1.a, l1.b, {0, 0, 0}, {0, 0, 1})) {",
			"        val = ((s1.x - s2.x) * (s2.y - e2.y) - (s1.y - s2.y) * (s2.x - e2.x)) /",
			"              ((s1.x - e1.x) * (s2.y - e2.y) - (s1.y - e1.y) * (s2.x - e2.x));",
			"    } else if (!onPlane(l1.a, l1.b, {0, 0, 0}, {0, 1, 0})) {",
			"        val = ((s1.x - s2.x) * (s2.z - e2.z) - (s1.z - s2.z) * (s2.x - e2.x)) /",
			"              ((s1.x - e1.x) * (s2.z - e2.z) - (s1.z - e1.z) * (s2.x - e2.x));",
			"    } else {",
			"        val = ((s1.y - s2.y) * (s2.z - e2.z) - (s1.z - s2.z) * (s2.y - e2.y)) /",
			"              ((s1.y - e1.y) * (s2.z - e2.z) - (s1.z - e1.z) * (s2.y - e2.y));",
			"    }",
			"    return {1, s1 + (e1 - s1) * val};",
			"}"
		],
		"description": "Lineintersection"
	},
	"lineplanecross": {
		"scope": "cpp",
		"prefix": "lineplanecross",
		"body": [
			"std::pair<bool, P3> linePlaneCross(L3 l, Plane s) {",
			"    if (linePlaneParallel(l, s)) {",
			"        return {0, {}};",
			"    }",
			"    P3 vec = getVec(s);",
			"    P3 U = vec * (s.u - l.a), V = vec * (l.b - l.a);",
			"    ld val = (U.x + U.y + U.z) / (V.x + V.y + V.z);",
			"    return {1, l.a + (l.b - l.a) * val};",
			"}"
		],
		"description": "Lineplanecross"
	},
	"planeintersection": {
		"scope": "cpp",
		"prefix": "planeintersection",
		"body": [
			"std::pair<bool, L3> planeIntersection(Plane s1, Plane s2) {",
			"    if (planeParallel(s1, s2) || same(s1, s2)) {",
			"        return {0, {}};",
			"    }",
			"    P3 U = linePlaneParallel({s2.u, s2.v}, s1) ? linePlaneCross({s2.v, s2.w}, s1).second",
			"                                               : linePlaneCross({s2.u, s2.v}, s1).second;",
			"    P3 V = linePlaneParallel({s2.w, s2.u}, s1) ? linePlaneCross({s2.v, s2.w}, s1).second",
			"                                               : linePlaneCross({s2.w, s2.u}, s1).second;",
			"    return {1, {U, V}};",
			"}"
		],
		"description": "Planeintersection"
	},
	"pointtoline": {
		"scope": "cpp",
		"prefix": "pointtoline",
		"body": [
			"std::pair<ld, P3> pointToLine(P3 p, L3 l) {",
			"    ld val = cross(p - l.a, l.a - l.b) / dis(l.a, l.b); // 面积除以底边长",
			"    ld val1 = dot(p - l.a, l.a - l.b) / dis(l.a, l.b);",
			"    return {val, l.a + val1 * standardize(l.a - l.b)};",
			"}"
		],
		"description": "Pointtoline"
	},
	"pointtoplane": {
		"scope": "cpp",
		"prefix": "pointtoplane",
		"body": [
			"std::pair<ld, P3> pointToPlane(P3 p, Plane s) {",
			"    P3 vec = getVec(s);",
			"    ld val = dot(vec, p - s.u);",
			"    val = std::abs(val) / len(vec); // 面积除以底边长",
			"    return {val, p - val * standardize(vec)};",
			"}"
		],
		"description": "Pointtoplane"
	},
	"linetoline": {
		"scope": "cpp",
		"prefix": "linetoline",
		"body": [
			"std::tuple<ld, P3, P3> lineToLine(L3 l1, L3 l2) {",
			"    P3 vec = crossEx(l1.a - l1.b, l2.a - l2.b); // 计算同时垂直于两直线的向量",
			"    ld val = std::abs(dot(l1.a - l2.a, vec)) / len(vec);",
			"    P3 U = l1.b - l1.a, V = l2.b - l2.a;",
			"    vec = crossEx(U, V);",
			"    ld p = dot(vec, vec);",
			"    ld t1 = dot(crossEx(l2.a - l1.a, V), vec) / p;",
			"    ld t2 = dot(crossEx(l2.a - l1.a, U), vec) / p;",
			"    return {val, l1.a + (l1.b - l1.a) * t1, l2.a + (l2.b - l2.a) * t2};",
			"}"
		],
		"description": "Linetoline"
	},
	"linecos": {
		"scope": "cpp",
		"prefix": "linecos",
		"body": [
			"ld lineCos(L3 l1, L3 l2) {",
			"    return dot(l1.a - l1.b, l2.a - l2.b) / len(l1.a - l1.b) / len(l2.a - l2.b);",
			"}"
		],
		"description": "Linecos"
	},
	"planecos": {
		"scope": "cpp",
		"prefix": "planecos",
		"body": [
			"ld planeCos(Plane s1, Plane s2) {",
			"    P3 U = getVec(s1), V = getVec(s2);",
			"    return dot(U, V) / len(U) / len(V);",
			"}"
		],
		"description": "Planecos"
	},
	"lineplanesin": {
		"scope": "cpp",
		"prefix": "lineplanesin",
		"body": [
			"ld linePlaneSin(L3 l, Plane s) {",
			"    P3 vec = getVec(s);",
			"    return dot(l.a - l.b, vec) / len(l.a - l.b) / len(vec);",
			"}"
		],
		"description": "Lineplanesin"
	},
	"v": {
		"scope": "cpp",
		"prefix": "v",
		"body": [
			"ld V(ld l, int n) { // 正n棱锥体积公式",
			"    return l * l * l * n / (12 * std::tan(PI / n)) * std::sqrt(1 - 1 / (4 * std::sin(PI / n) * std::sin(PI / n)));",
			"}"
		],
		"description": "V"
	},
	"v_1": {
		"scope": "cpp",
		"prefix": "v",
		"body": [
			"ld V(P3 a, P3 b, P3 c, P3 d) {",
			"    return std::abs(dot(d - a, crossEx(b - a, c - a))) / 6;",
			"}"
		],
		"description": "V"
	},
	"pointontriangle": {
		"scope": "cpp",
		"prefix": "pointontriangle",
		"body": [
			"bool pointOnTriangle(P3 p, P3 p1, P3 p2, P3 p3) {",
			"    return pointOnSegmentSide(p, p1, {p2, p3}) && pointOnSegmentSide(p, p2, {p1, p3}) &&",
			"           pointOnSegmentSide(p, p3, {p1, p2});",
			"}"
		],
		"description": "Pointontriangle"
	},
	"segmentontriangle": {
		"scope": "cpp",
		"prefix": "segmentontriangle",
		"body": [
			"std::pair<bool, P3> segmentOnTriangle(P3 l, P3 r, P3 p1, P3 p2, P3 p3) {",
			"    P3 x = crossEx(p2 - p1, p3 - p1);",
			"    if (sign(dot(x, r - l)) == 0) {",
			"        return {0, {}};",
			"    }",
			"    ld t = dot(x, p1 - l) / dot(x, r - l);",
			"    if (t < 0 || t - 1 > 0) { // 不在线段上",
			"        return {0, {}};",
			"    }",
			"    bool type = pointOnTriangle(l + (r - l) * t, p1, p2, p3);",
			"    if (type) {",
			"        return {1, l + (r - l) * t};",
			"    } else {",
			"        return {0, {}};",
			"    }",
			"}"
		],
		"description": "Segmentontriangle"
	},
	"triangleintersection": {
		"scope": "cpp",
		"prefix": "triangleintersection",
		"body": [
			"bool triangleIntersection(std::vector<P3> a, std::vector<P3> b) {",
			"    for (int i = 0; i < 3; i++) {",
			"        if (segmentOnTriangle(b[i], b[(i + 1) % 3], a[0], a[1], a[2]).first) {",
			"            return 1;",
			"        }",
			"        if (segmentOnTriangle(a[i], a[(i + 1) % 3], b[0], b[1], b[2]).first) {",
			"            return 1;",
			"        }",
			"    }",
			"    return 0;",
			"}"
		],
		"description": "Triangleintersection"
	},
	"code": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"signed main() {",
			"    int a, b, d;",
			"    std::cin >> a >> b >> d;",
			"",
			"    ld l = hypot(a, b); // 库函数，求直角三角形的斜边",
			"    ld alpha = atan2(b, a) + toArc(d);",
			"",
			"    cout << l * cos(alpha) << \" \" << l * sin(alpha) << endl;",
			"}"
		],
		"description": "Code"
	},
	"sqr": {
		"scope": "cpp",
		"prefix": "sqr",
		"body": [
			"template<typename T> T sqr(T x) {",
			"    return x * x;",
			"}",
			"",
			"using V = Point<int>;",
			"signed main() {",
			"    int n;",
			"    std::cin >> n;",
			"",
			"    std::vector<V> in(n);",
			"    for (auto &it : in) {",
			"        std::cin >> it;",
			"    }",
			"",
			"    int dis = disEx(in[0], in[1]); // 设定阈值",
			"    std::sort(in.begin(), in.end());",
			"",
			"    std::set<V> S;",
			"    for (int i = 0, h = 0; i < n; i++) {",
			"        V now = {in[i].y, in[i].x};",
			"        while (dis && dis <= sqr(in[i].x - in[h].x)) { // 删除超过阈值的点",
			"            S.erase({in[h].y, in[h].x});",
			"            h++;",
			"        }",
			"        auto it = S.std::lower_bound(now);",
			"        for (auto k = it; k != S.end() && sqr(k->x - now.x) < dis; k++) {",
			"            dis = std::min(dis, disEx(*k, now));",
			"        }",
			"        if (it != S.begin()) {",
			"            for (auto k = prev(it); sqr(k->x - now.x) < dis; k--) {",
			"                dis = std::min(dis, disEx(*k, now));",
			"                if (k == S.begin()) break;",
			"            }",
			"        }",
			"        S.insert(now);",
			"    }",
			"    std::cout << std::sqrt(dis) << std::endl;",
			"}"
		],
		"description": "Sqr"
	},
	"code_1": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"signed main() {",
			"    int n;",
			"    std::cin >> n;",
			"    std::vector<Pi> in(n);",
			"    for (auto &it : in) {",
			"        std::cin >> it;",
			"    }",
			"    ld ans = 0;",
			"    for (int i = 0; i < n; i++) {",
			"        for (int j = i + 1; j < n; j++) { // 枚举对角线",
			"            ld l = 0, r = 0;",
			"            for (int k = 0; k < n; k++) { // 枚举第三点",
			"                if (k == i || k == j) continue;",
			"                if (pointOnLineLeft(in[k], {in[i], in[j]})) {",
			"                    l = std::max(l, triangleS(in[k], in[j], in[i]));",
			"                } else {",
			"                    r = std::max(r, triangleS(in[k], in[j], in[i]));",
			"                }",
			"            }",
			"            if (l * r != 0) { // 确保构成的是四边形",
			"                ans = std::max(ans, l + r);",
			"            }",
			"        }",
			"    }",
			"    std::cout << ans << std::endl;",
			"}"
		],
		"description": "Code"
	},
	"code_2": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"using V = Point<int>;",
			"signed main() {",
			"    int Task = 1;",
			"    for (std::cin >> Task; Task; Task--) {",
			"        int n;",
			"        std::cin >> n;",
			"",
			"        std::vector<V> in_(n);",
			"        for (auto &it : in_) {",
			"            std::cin >> it;",
			"        }",
			"        auto in = staticConvexHull(in_, 0);",
			"        n = in.size();",
			"",
			"        int ans = 0;",
			"        if (n > 3) {",
			"            ans = rotatingCalipers(in);",
			"        } else if (n == 3) {",
			"            int area = triangleAreaEx(in[0], in[1], in[2]);",
			"            for (auto it : in_) {",
			"                if (it == in[0] || it == in[1] || it == in[2]) continue;",
			"                int Min = std::min({triangleAreaEx(it, in[0], in[1]), triangleAreaEx(it, in[0], in[2]), triangleAreaEx(it, in[1], in[2])});",
			"                ans = std::max(ans, area - Min);",
			"            }",
			"        }",
			"",
			"        std::cout << ans / 2;",
			"        if (ans % 2) {",
			"            cout << \".5\";",
			"        }",
			"        std::cout << std::endl;",
			"    }",
			"}"
		],
		"description": "Code"
	},
	"code_3": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"signed main() {",
			"    Pi s, e;",
			"    std::cin >> s >> e; // 读入线段",
			"",
			"    int n;",
			"    std::cin >> n;",
			"    std::vector<Pi> in(n);",
			"    for (auto &it : in) {",
			"        std::cin >> it; // 读入多边形端点",
			"    }",
			"",
			"    int cnt = 0;",
			"    for (int i = 0; i < n; i++) {",
			"        Pi x = in[i], y = in[(i + 1) % n];",
			"        cnt += (pointNotOnLineSide(x, y, {s, e}) && segmentIntersection(Line{x, y}, {s, e}));",
			"    }",
			"    std::cout << cnt / 2 + 1 << std::endl;",
			"}"
		],
		"description": "Code"
	},
	"code_4": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"signed main() {",
			"    int n;",
			"    std::cin >> n;",
			"",
			"    std::vector<Point<ld>> in(n);",
			"    for (auto &it : in) {",
			"        std::cin >> it;",
			"    }",
			"",
			"    for (int i = 0; i < n; i++) {",
			"        auto A = in[(i - 1 + n) % n];",
			"        auto B = in[i];",
			"        auto C = in[(i + 1) % n];",
			"        if (cross(A - B, C - B) > 0) {",
			"            cout << \"No\\n\";",
			"            return 0;",
			"        }",
			"    }",
			"    cout << \"Yes\\n\";",
			"}"
		],
		"description": "Code"
	},
	"code_5": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"signed main() {",
			"    int n;",
			"    std::cin >> n;",
			"",
			"    std::vector<Point<int>> in(n);",
			"    for (auto &it : in) {",
			"        std::cin >> it;",
			"    }",
			"",
			"    #define S(x, y, z) triangleAreaEx(in[x], in[y], in[z])",
			"",
			"    int i = 0, j = 1, k = 2;",
			"    while (true) {",
			"        int val = S(i, j, k);",
			"        if (S((i + 1) % n, j, k) > val) {",
			"            i = (i + 1) % n;",
			"        } else if (S((i - 1 + n) % n, j, k) > val) {",
			"            i = (i - 1 + n) % n;",
			"        } else if (S(i, (j + 1) % n, k) > val) {",
			"            j = (j + 1) % n;",
			"        } else if (S(i, (j - 1 + n) % n, k) > val) {",
			"            j = (j - 1 + n) % n;",
			"        } else if (S(i, j, (k + 1) % n) > val) {",
			"            k = (k + 1) % n;",
			"        } else if (S(i, j, (k - 1 + n) % n) > val) {",
			"            k = (k - 1 + n) % n;",
			"        } else {",
			"            break;",
			"        }",
			"    }",
			"    cout << i + 1 << \" \" << j + 1 << \" \" << k + 1 << endl;",
			"}"
		],
		"description": "Code"
	},
	"rotatingcalipers": {
		"scope": "cpp",
		"prefix": "rotatingcalipers",
		"body": [
			"template<typename T> T rotatingCalipers(std::vector<Point<T>> &p) {",
			"    #define S(x, y, z) triangleAreaEx(p[x], p[y], p[z])",
			"    int n = p.size();",
			"    T ans = 0;",
			"    auto nxt = [&](int i) -> int {",
			"        return i == n - 1 ? 0 : i + 1;",
			"    };",
			"    for (int i = 0; i < n; i++) {",
			"        int p1 = nxt(i), p2 = nxt(nxt(nxt(i)));",
			"        for (int j = nxt(nxt(i)); nxt(j) != i; j = nxt(j)) {",
			"            while (nxt(p1) != j && S(i, j, nxt(p1)) > S(i, j, p1)) {",
			"                p1 = nxt(p1);",
			"            }",
			"            if (p2 == j) {",
			"                p2 = nxt(p2);",
			"            }",
			"            while (nxt(p2) != i && S(i, j, nxt(p2)) > S(i, j, p2)) {",
			"                p2 = nxt(p2);",
			"            }",
			"            ans = std::max(ans, S(i, j, p1) + S(i, j, p2));",
			"        }",
			"    }",
			"    return ans;",
			"    #undef S",
			"}"
		],
		"description": "Rotatingcalipers"
	},
	"format": {
		"scope": "cpp",
		"prefix": "format",
		"body": [
			"cout << format(\"{:.2f}\", 114514.1919810) << endl;",
			"// output: 114514.19"
		],
		"description": "Format"
	},
	"cross": {
		"scope": "cpp",
		"prefix": "cross",
		"body": [
			"using Real = int;",
			"using Point = complex<Real>;",
			"",
			"Real cross(const Point &a, const Point &b) {",
			"    return (conj(a) * b).imag();",
			"}",
			"Real dot(const Point &a, const Point &b) {",
			"    return (conj(a) * b).real();",
			"}",
			"",
			"Real cross(const Point &a, const Point &b) {",
			"    return a.x * b.y - a.y * b.x;",
			"} ",
			"Real dot(const Point &a, const Point &b) {",
			"    return a.x * b.x + a.y * b.y;",
			"}"
		],
		"description": "Cross"
	},
	"read": {
		"scope": "cpp",
		"prefix": "read",
		"body": [
			"const int Knum = 4;",
			"int read(int k = Knum) {",
			"    std::string s;",
			"    std::cin >> s;",
			"",
			"    int num = 0;",
			"    int it = s.find('.');",
			"    if (it != -1) { // 存在小数点",
			"        num = s.size() - it - 1; // 计算小数位数",
			"        s.erase(s.begin() + it); // 删除小数点",
			"    }",
			"    for (int i = 1; i <= k - num; i++) { // 补全小数位数",
			"        s += '0';",
			"    }",
			"    return stoi(s);",
			"}"
		],
		"description": "Read"
	},
	"fgcd": {
		"scope": "cpp",
		"prefix": "fgcd",
		"body": [
			"using ld = long double;",
			"const ld PI = std::acos(-1);",
			"const ld EPS = 1e-7;",
			"const ld INF = numeric_limits<ld>::std::max();",
			"#define cc(x) std::cout << fixed << setprecision(x);",
			"",
			"ld fgcd(ld x, ld y) { // 实数域gcd",
			"    return std::abs(y) < EPS ? std::abs(x) : fgcd(y, std::fmod(x, y));",
			"}",
			"template<typename T, typename S>",
			"bool equal(T x, S y) {",
			"    return -EPS < x - y && x - y < EPS;",
			"}",
			"template<typename T>",
			"int sign(T x) {",
			"    if (-EPS < x && x < EPS) return 0;",
			"    return x < 0 ? -1 : 1;",
			"}"
		],
		"description": "Fgcd"
	},
	"point": {
		"scope": "cpp",
		"prefix": "point",
		"body": [
			"template<typename T>",
			"struct Point {  // 在C++17下使用emplace_back绑定可能会导致CE！",
			"    T x, y;",
			"    Point(T x_ = 0, T y_ = 0) : x(x_), y(y_) {}",
			"",
			"    template<typename U>",
			"    operator Point<U>() {  // 自动类型匹配",
			"        return Point<U>(U(x), U(y));",
			"    }",
			"",
			"    Point operator-() const { return {-x, -y}; }",
			"    Point operator+(const Point &b) const { return {x + b.x, y + b.y}; }",
			"    Point operator-(const Point &b) const { return {x - b.x, y - b.y}; }",
			"",
			"    Point operator+(const T &b) const { return {x + b, y + b}; }",
			"    Point operator-(const T &b) const { return {x - b, y - b}; }",
			"    Point operator*(const T &b) const { return {x * b, y * b}; }",
			"    Point operator/(const T &b) const { return {x / b, y / b}; }",
			"",
			"    T operator*(const Point &b) const { return x * b.x + y * b.y; }  // 点积",
			"    T operator^(const Point &b) const { return x * b.y - y * b.x; }  // 叉积",
			"",
			"    Point &operator+=(const Point &p) { x += p.x; y += p.y; return *this; }",
			"    Point &operator-=(const Point &p) { x -= p.x; y -= p.y; return *this; }",
			"",
			"    Point &operator+=(const T t) { x += t; y += t; return *this; }",
			"    Point &operator-=(const T t) { x -= t; y -= t; return *this; }",
			"    Point &operator*=(const T t) { x *= t; y *= t; return *this; }",
			"    Point &operator/=(const T t) { x /= t; y /= t; return *this; }",
			"",
			"    bool operator<(const Point &b) const {",
			"        return equal(x, b.x) ? y < b.y - EPS : x < b.x - EPS;",
			"    }",
			"    bool operator>(const Point &b) const { return b < *this; }",
			"    bool operator==(const Point &b) const { return !(b < *this) && !(*this < b); }",
			"    bool operator!=(const Point &b) const { return *this < b || b < *this; }",
			"",
			"    friend istream &operator>>(istream &is, Point &p) {",
			"        return is >> p.x >> p.y;",
			"    }",
			"    friend ostream &operator<<(ostream &os, const Point &p) {",
			"        return os << format(\"({},{})\", p.x, p.y);     // C++20",
			"        return os << '(' << p.x << ',' << p.y << ')'; // C++17",
			"    }",
			"};",
			"",
			"template<typename T>",
			"struct Line {",
			"    Point<T> a, b;",
			"    Line(Point<T> a_ = Point<T>(), Point<T> b_ = Point<T>()) : a(a_), b(b_) {}",
			"    template<typename U>",
			"    operator Line<U>() {  // 自动类型匹配",
			"        return Line<U>(Point<U>(a), Point<U>(b));",
			"    }",
			"    friend ostream &operator<<(ostream &os, const Line &l) {",
			"        return os << '<' << l.a << ',' << l.b << '>';",
			"    }",
			"};"
		],
		"description": "Point"
	},
	"cross_1": {
		"scope": "cpp",
		"prefix": "cross",
		"body": [
			"template<typename T>  // 叉乘",
			"T cross(Point<T> a, Point<T> b) { return a.x * b.y - a.y * b.x; }",
			"template<typename T>  // 叉乘 (p1 - p0) x (p2 - p0);",
			"T cross(Point<T> p1, Point<T> p2, Point<T> p0) { return cross(p1 - p0, p2 - p0); }"
		],
		"description": "Cross"
	},
	"dot": {
		"scope": "cpp",
		"prefix": "dot",
		"body": [
			"template<typename T>  // 点乘",
			"T dot(Point<T> a, Point<T> b) { return a.x * b.x + a.y * b.y; }",
			"template<typename T>  // 点乘 (p1 - p0) * (p2 - p0);",
			"T dot(Point<T> p1, Point<T> p2, Point<T> p0) { return dot(p1 - p0, p2 - p0); }"
		],
		"description": "Dot"
	},
	"disex": {
		"scope": "cpp",
		"prefix": "disex",
		"body": [
			"// Use with caution! This might not be the correct implementation of disEx as described below",
			"template<typename T>",
			"T disEx(Point<T> a, Point<T> b) {",
			"    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);",
			"}",
			"template<typename T>",
			"ld dis(Point<T> a, Point<T> b) {",
			"    return std::sqrt(disEx(a, b));",
			"}"
		],
		"description": "Disex"
	},
	"dis1": {
		"scope": "cpp",
		"prefix": "dis1",
		"body": [
			"template<typename T> T dis1(Point<T> p1, Point<T> p2) { // 曼哈顿距离公式",
			"    return std::abs(p1.x - p2.x) + std::abs(p1.y - p2.y);",
			"}"
		],
		"description": "Dis1"
	},
	"standardize": {
		"scope": "cpp",
		"prefix": "standardize",
		"body": [
			"Point<ld> standardize(Point<ld> vec) { // 转换为单位向量",
			"    return vec / std::sqrt(vec.x * vec.x + vec.y * vec.y);",
			"}"
		],
		"description": "Standardize"
	},
	"rotate": {
		"scope": "cpp",
		"prefix": "rotate",
		"body": [
			"template<typename T> Point<T> rotate(Point<T> p1, Point<T> p2) { // 旋转",
			"    Point<T> vec = p1 - p2;",
			"    return {-vec.y, vec.x};",
			"}"
		],
		"description": "Rotate"
	},
	"todeg": {
		"scope": "cpp",
		"prefix": "todeg",
		"body": [
			"ld toDeg(ld x) { // 弧度转角度",
			"    return x * 180 / PI;",
			"}",
			"ld toArc(ld x) { // 角度转弧度",
			"    return PI / 180 * x;",
			"}"
		],
		"description": "Todeg"
	},
	"angle": {
		"scope": "cpp",
		"prefix": "angle",
		"body": [
			"ld angle(ld a, ld b, ld c) { // 余弦定理",
			"    ld val = std::acos((a * a + b * b - c * c) / (2.0 * a * b)); // 计算弧度",
			"    return val;",
			"}"
		],
		"description": "Angle"
	},
	"angle_1": {
		"scope": "cpp",
		"prefix": "angle",
		"body": [
			"ld angle(Point<ld> a, Point<ld> b) {",
			"    ld val = std::abs(cross(a, b));",
			"    return std::abs(atan2(val, a.x * b.x + a.y * b.y));",
			"}"
		],
		"description": "Angle"
	},
	"rotate_1": {
		"scope": "cpp",
		"prefix": "rotate",
		"body": [
			"Point<ld> rotate(Point<ld> p, ld rad) {",
			"    return {p.x * std::cos(rad) - p.y * std::sin(rad), p.x * std::sin(rad) + p.y * std::cos(rad)};",
			"}"
		],
		"description": "Rotate"
	},
	"rotate_2": {
		"scope": "cpp",
		"prefix": "rotate",
		"body": [
			"// potentially incorrect?",
			"Point<ld> rotate(Point<ld> a, Point<ld> b, ld rad) {",
			"    ld x = (a.x - b.x) * std::cos(rad) + (a.y - b.y) * std::sin(rad) + b.x;",
			"    ld y = (b.x - a.x) * std::sin(rad) + (a.y - b.y) * std::cos(rad) + b.y;",
			"    return {x, y};",
			"}"
		],
		"description": "Rotate"
	},
	"online_1": {
		"scope": "cpp",
		"prefix": "online",
		"body": [
			"template<typename T> bool onLine(Point<T> a, Point<T> b, Point<T> c) {",
			"    return sign(cross(b, a, c)) == 0;",
			"}",
			"template<typename T> bool onLine(Point<T> p, Line<T> l) {",
			"    return onLine(p, l.a, l.b);",
			"}"
		],
		"description": "Online"
	},
	"pointonlineleft": {
		"scope": "cpp",
		"prefix": "pointonlineleft",
		"body": [
			"template<typename T> bool pointOnLineLeft(Pt p, Lt l) {",
			"    return cross(l.b, p, l.a) > 0;",
			"}"
		],
		"description": "Pointonlineleft"
	},
	"pointonlineside": {
		"scope": "cpp",
		"prefix": "pointonlineside",
		"body": [
			"template<typename T> bool pointOnLineSide(Pt p1, Pt p2, Lt vec) {",
			"    T val = cross(p1, vec.a, vec.b) * cross(p2, vec.a, vec.b);",
			"    return sign(val) == 1;",
			"}",
			"template<typename T> bool pointNotOnLineSide(Pt p1, Pt p2, Lt vec) {",
			"    T val = cross(p1, vec.a, vec.b) * cross(p2, vec.a, vec.b);",
			"    return sign(val) == -1;",
			"}"
		],
		"description": "Pointonlineside"
	},
	"lineintersection_1": {
		"scope": "cpp",
		"prefix": "lineintersection",
		"body": [
			"Pd lineIntersection(Ld l1, Ld l2) {",
			"    ld val = cross(l2.b - l2.a, l1.a - l2.a) / cross(l2.b - l2.a, l1.a - l1.b);",
			"    return l1.a + (l1.b - l1.a) * val;",
			"}"
		],
		"description": "Lineintersection"
	},
	"lineparallel_1": {
		"scope": "cpp",
		"prefix": "lineparallel",
		"body": [
			"template<typename T> bool lineParallel(Lt p1, Lt p2) {",
			"    return sign(cross(p1.a - p1.b, p2.a - p2.b)) == 0;",
			"}",
			"template<typename T> bool lineVertical(Lt p1, Lt p2) {",
			"    return sign(dot(p1.a - p1.b, p2.a - p2.b)) == 0;",
			"}",
			"template<typename T> bool same(Line<T> l1, Line<T> l2) {",
			"    return lineParallel(Line{l1.a, l2.b}, {l1.b, l2.a}) &&",
			"           lineParallel(Line{l1.a, l2.a}, {l1.b, l2.b}) && lineParallel(l1, l2);",
			"}"
		],
		"description": "Lineparallel"
	},
	"pointtoline_1": {
		"scope": "cpp",
		"prefix": "pointtoline",
		"body": [
			"std::pair<Pd, ld> pointToLine(Pd p, Ld l) {",
			"    Pd ans = lineIntersection({p, p + rotate(l.a, l.b)}, l);",
			"    return {ans, dis(p, ans)};",
			"}"
		],
		"description": "Pointtoline"
	},
	"dispointtoline": {
		"scope": "cpp",
		"prefix": "dispointtoline",
		"body": [
			"template<typename T> ld disPointToLine(Pt p, Lt l) {",
			"    ld ans = cross(p, l.a, l.b);",
			"    return std::abs(ans) / dis(l.a, l.b); // 面积除以底边长",
			"}"
		],
		"description": "Dispointtoline"
	},
	"pointonsegment_1": {
		"scope": "cpp",
		"prefix": "pointonsegment",
		"body": [
			"template<typename T> bool pointOnSegment(Pt p, Lt l) { // 端点也算作在直线上",
			"    return sign(cross(p, l.a, l.b)) == 0 && std::min(l.a.x, l.b.x) <= p.x && p.x <= std::max(l.a.x, l.b.x) &&",
			"           std::min(l.a.y, l.b.y) <= p.y && p.y <= std::max(l.a.y, l.b.y);",
			"}",
			"template<typename T> bool pointOnSegment(Pt p, Lt l) { // 端点不算",
			"    return pointOnSegment(p, l) && std::min(l.a.x, l.b.x) < p.x && p.x < std::max(l.a.x, l.b.x) &&",
			"           std::min(l.a.y, l.b.y) < p.y && p.y < std::max(l.a.y, l.b.y);",
			"}"
		],
		"description": "Pointonsegment"
	},
	"pointtosegment": {
		"scope": "cpp",
		"prefix": "pointtosegment",
		"body": [
			"std::pair<Pd, ld> pointToSegment(Pd p, Ld l) {",
			"    if (sign(dot(p, l.b, l.a)) == -1) { // 特判到两端点的距离",
			"        return {l.a, dis(p, l.a)};",
			"    } else if (sign(dot(p, l.a, l.b)) == -1) {",
			"        return {l.b, dis(p, l.b)};",
			"    }",
			"    return pointToLine(p, l);",
			"}"
		],
		"description": "Pointtosegment"
	},
	"project": {
		"scope": "cpp",
		"prefix": "project",
		"body": [
			"Pd project(Pd p, Ld l) { // 投影",
			"    Pd vec = l.b - l.a;",
			"    ld r = dot(vec, p - l.a) / (vec.x * vec.x + vec.y * vec.y);",
			"    return l.a + vec * r;",
			"}"
		],
		"description": "Project"
	},
	"midsegment": {
		"scope": "cpp",
		"prefix": "midsegment",
		"body": [
			"template<typename T> Lt midSegment(Lt l) {",
			"    Pt mid = (l.a + l.b) / 2; // 线段中点",
			"    return {mid, mid + rotate(l.a, l.b)};",
			"}"
		],
		"description": "Midsegment"
	},
	"segmentintersection_1": {
		"scope": "cpp",
		"prefix": "segmentintersection",
		"body": [
			"template<typename T> std::tuple<int, Pt, Pt> segmentIntersection(Lt l1, Lt l2) {",
			"    auto [s1, e1] = l1;",
			"    auto [s2, e2] = l2;",
			"    auto A = std::max(s1.x, e1.x), AA = std::min(s1.x, e1.x);",
			"    auto B = std::max(s1.y, e1.y), BB = std::min(s1.y, e1.y);",
			"    auto C = std::max(s2.x, e2.x), CC = std::min(s2.x, e2.x);",
			"    auto D = std::max(s2.y, e2.y), DD = std::min(s2.y, e2.y);",
			"    if (A < CC || C < AA || B < DD || D < BB) {",
			"        return {0, {}, {}};",
			"    }",
			"    if (sign(cross(e1 - s1, e2 - s2)) == 0) {",
			"        if (sign(cross(s2, e1, s1)) != 0) {",
			"            return {0, {}, {}};",
			"        }",
			"        Pt p1(std::max(AA, CC), std::max(BB, DD));",
			"        Pt p2(std::min(A, C), std::min(B, D));",
			"        if (!pointOnSegment(p1, l1)) {",
			"            std::swap(p1.y, p2.y);",
			"        }",
			"        if (p1 == p2) {",
			"            return {3, p1, p2};",
			"        } else {",
			"            return {2, p1, p2};",
			"        }",
			"    }",
			"    auto cp1 = cross(s2 - s1, e2 - s1);",
			"    auto cp2 = cross(s2 - e1, e2 - e1);",
			"    auto cp3 = cross(s1 - s2, e1 - s2);",
			"    auto cp4 = cross(s1 - e2, e1 - e2);",
			"    if (sign(cp1 * cp2) == 1 || sign(cp3 * cp4) == 1) {",
			"        return {0, {}, {}};",
			"    }",
			"    // 使用下方函数时请使用浮点数",
			"    Pd p = lineIntersection(l1, l2);",
			"    if (sign(cp1) != 0 && sign(cp2) != 0 && sign(cp3) != 0 && sign(cp4) != 0) {",
			"        return {1, p, p};",
			"    } else {",
			"        return {3, p, p};",
			"    }",
			"}"
		],
		"description": "Segmentintersection"
	},
	"segmentintersection_2": {
		"scope": "cpp",
		"prefix": "segmentintersection",
		"body": [
			"// potentially incorrect?",
			"template<typename T> bool segmentIntersection(Lt l1, Lt l2) {",
			"    auto [s1, e1] = l1;",
			"    auto [s2, e2] = l2;",
			"    auto A = std::max(s1.x, e1.x), AA = std::min(s1.x, e1.x);",
			"    auto B = std::max(s1.y, e1.y), BB = std::min(s1.y, e1.y);",
			"    auto C = std::max(s2.x, e2.x), CC = std::min(s2.x, e2.x);",
			"    auto D = std::max(s2.y, e2.y), DD = std::min(s2.y, e2.y);",
			"    return A >= CC && B >= DD && C >= AA && D >= BB &&",
			"           sign(cross(s1, s2, e1) * cross(s1, e1, e2)) == 1 &&",
			"           sign(cross(s2, s1, e2) * cross(s2, e2, e1)) == 1;",
			"}"
		],
		"description": "Segmentintersection"
	},
	"pointtocircle": {
		"scope": "cpp",
		"prefix": "pointtocircle",
		"body": [
			"std::pair<Pd, ld> pointToCircle(Pd p, Pd o, ld r) {",
			"    Pd U = o, V = o;",
			"    ld d = dis(p, o);",
			"    if (sign(d) == 0) { // p 为圆心时返回圆心本身",
			"        return {o, 0};",
			"    }",
			"    ld val1 = r * std::abs(o.x - p.x) / d;",
			"    ld val2 = r * std::abs(o.y - p.y) / d * ((o.x - p.x) * (o.y - p.y) < 0 ? -1 : 1);",
			"    U.x += val1, U.y += val2;",
			"    V.x -= val1, V.y -= val2;",
			"    if (dis(U, p) < dis(V, p)) {",
			"        return {U, dis(U, p)};",
			"    } else {",
			"        return {V, dis(V, p)};",
			"    }",
			"}"
		],
		"description": "Pointtocircle"
	},
	"getpoint": {
		"scope": "cpp",
		"prefix": "getpoint",
		"body": [
			"Point<ld> getPoint(Point<ld> p, ld r, ld rad) {",
			"    return {p.x + std::cos(rad) * r, p.y + std::sin(rad) * r};",
			"}"
		],
		"description": "Getpoint"
	},
	"linecirclecross": {
		"scope": "cpp",
		"prefix": "linecirclecross",
		"body": [
			"std::tuple<int, Pd, Pd> lineCircleCross(Ld l, Pd o, ld r) {",
			"    Pd P = project(o, l);",
			"    ld d = dis(P, o), tmp = r * r - d * d;",
			"    if (sign(tmp) == -1) {",
			"        return {0, {}, {}};",
			"    } else if (sign(tmp) == 0) {",
			"        return {1, P, {}};",
			"    }",
			"    Pd vec = standardize(l.b - l.a) * std::sqrt(tmp);",
			"    return {2, P + vec, P - vec};",
			"}"
		],
		"description": "Linecirclecross"
	},
	"segmentcirclecross": {
		"scope": "cpp",
		"prefix": "segmentcirclecross",
		"body": [
			"std::tuple<int, Pd, Pd> segmentCircleCross(Ld l, Pd o, ld r) {",
			"    auto [type, U, V] = lineCircleCross(l, o, r);",
			"    bool f1 = pointOnSegment(U, l), f2 = pointOnSegment(V, l);",
			"    if (type == 1 && f1) {",
			"        return {1, U, {}};",
			"    } else if (type == 2 && f1 && f2) {",
			"        return {3, U, V};",
			"    } else if (type == 2 && f1) {",
			"        return {2, U, {}};",
			"    } else if (type == 2 && f2) {",
			"        return {2, V, {}};",
			"    } else {",
			"        return {0, {}, {}};",
			"    }",
			"}"
		],
		"description": "Segmentcirclecross"
	},
	"circleintersection": {
		"scope": "cpp",
		"prefix": "circleintersection",
		"body": [
			"std::tuple<int, Pd, Pd> circleIntersection(Pd p1, ld r1, Pd p2, ld r2) {",
			"    ld x1 = p1.x, x2 = p2.x, y1 = p1.y, y2 = p2.y, d = dis(p1, p2);",
			"    if (sign(std::abs(r1 - r2) - d) == 1) {",
			"        return {0, {}, {}};",
			"    } else if (sign(r1 + r2 - d) == -1) {",
			"        return {1, {}, {}};",
			"    }",
			"    ld a = r1 * (x1 - x2) * 2, b = r1 * (y1 - y2) * 2, c = r2 * r2 - r1 * r1 - d * d;",
			"    ld p = a * a + b * b, q = -a * c * 2, r = c * c - b * b;",
			"    ld cosa, sina, cosb, sinb;",
			"    if (sign(d - (r1 + r2)) == 0 || sign(d - std::abs(r1 - r2)) == 0) {",
			"        cosa = -q / p / 2;",
			"        sina = std::sqrt(1 - cosa * cosa);",
			"        Point<ld> p0 = {x1 + r1 * cosa, y1 + r1 * sina};",
			"        if (sign(dis(p0, p2) - r2)) {",
			"            p0.y = y1 - r1 * sina;",
			"        }",
			"        return {2, p0, p0};",
			"    } else {",
			"        ld delta = std::sqrt(q * q - p * r * 4);",
			"        cosa = (delta - q) / p / 2;",
			"        cosb = (-delta - q) / p / 2;",
			"        sina = std::sqrt(1 - cosa * cosa);",
			"        sinb = std::sqrt(1 - cosb * cosb);",
			"        Pd ans1 = {x1 + r1 * cosa, y1 + r1 * sina};",
			"        Pd ans2 = {x1 + r1 * cosb, y1 + r1 * sinb};",
			"        if (sign(dis(ans1, p1) - r2)) ans1.y = y1 - r1 * sina;",
			"        if (sign(dis(ans2, p2) - r2)) ans2.y = y1 - r1 * sinb;",
			"        if (ans1 == ans2) ans1.y = y1 - r1 * sina;",
			"        return {3, ans1, ans2};",
			"    }",
			"}"
		],
		"description": "Circleintersection"
	},
	"circleintersectionarea": {
		"scope": "cpp",
		"prefix": "circleintersectionarea",
		"body": [
			"ld circleIntersectionArea(Pd p1, ld r1, Pd p2, ld r2) {",
			"    ld x1 = p1.x, x2 = p2.x, y1 = p1.y, y2 = p2.y, d = dis(p1, p2);",
			"    if (sign(std::abs(r1 - r2) - d) >= 0) {",
			"        return PI * std::min(r1 * r1, r2 * r2);",
			"    } else if (sign(r1 + r2 - d) == -1) {",
			"        return 0;",
			"    }",
			"    ld theta1 = angle(r1, dis(p1, p2), r2);",
			"    ld area1 = r1 * r1 * (theta1 - std::sin(theta1 * 2) / 2);",
			"    ld theta2 = angle(r2, dis(p1, p2), r1);",
			"    ld area2 = r2 * r2 * (theta2 - std::sin(theta2 * 2) / 2);",
			"    return area1 + area2;",
			"}"
		],
		"description": "Circleintersectionarea"
	},
	"getcircle": {
		"scope": "cpp",
		"prefix": "getcircle",
		"body": [
			"std::tuple<int, Pd, ld> getCircle(Pd A, Pd B, Pd C) {",
			"    if (onLine(A, B, C)) { // 特判三点共线",
			"        return {0, {}, 0};",
			"    }",
			"    Ld l1 = midSegment(Line{A, B});",
			"    Ld l2 = midSegment(Line{A, C});",
			"    Pd O = lineIntersection(l1, l2);",
			"    return {1, O, dis(A, O)};",
			"}"
		],
		"description": "Getcircle"
	},
	"tangent": {
		"scope": "cpp",
		"prefix": "tangent",
		"body": [
			"// potentially incorrect?",
			"std::pair<int, std::vector<Point<ld>>> tangent(Point<ld> p, Point<ld> A, ld r) {",
			"    std::vector<Point<ld>> ans; // 储存切点",
			"    Point<ld> u = A - p;",
			"    ld d = std::sqrt(dot(u, u));",
			"    if (d < r) {",
			"        return {0, {}};",
			"    } else if (sign(d - r) == 0) { // 点在圆上",
			"        ans.push_back(p);",
			"        return {1, ans};",
			"    } else {",
			"        ld ang = std::asin(r / d);",
			"        ans.push_back(getPoint(A, r, -ang));",
			"        ans.push_back(getPoint(A, r, ang));",
			"        return {2, ans};",
			"    }",
			"}"
		],
		"description": "Tangent"
	},
	"tangent_1": {
		"scope": "cpp",
		"prefix": "tangent",
		"body": [
			"std::tuple<int, std::vector<Point<ld>>, std::vector<Point<ld>>> tangent(Point<ld> A, ld Ar, Point<ld> B, ld Br) {",
			"    std::vector<Point<ld>> a, b; // 储存切点",
			"    if (Ar < Br) {",
			"        std::swap(Ar, Br);",
			"        std::swap(A, B);",
			"        std::swap(a, b);",
			"    }",
			"    int d = disEx(A, B), dif = Ar - Br, sum = Ar + Br;",
			"    if (d < dif * dif) { // 内含，无",
			"        return {0, {}, {}};",
			"    }",
			"    ld base = atan2(B.y - A.y, B.x - A.x);",
			"    if (d == 0 && Ar == Br) { // 完全重合，无数条外公切线",
			"        return {-1, {}, {}};",
			"    }",
			"    if (d == dif * dif) { // 内切，1条外公切线",
			"        a.push_back(getPoint(A, Ar, base));",
			"        b.push_back(getPoint(B, Br, base));",
			"        return {1, a, b};",
			"    }",
			"    ld ang = std::acos(dif / std::sqrt(d));",
			"    a.push_back(getPoint(A, Ar, base + ang)); // 保底2条外公切线",
			"    a.push_back(getPoint(A, Ar, base - ang));",
			"    b.push_back(getPoint(B, Br, base + ang));",
			"    b.push_back(getPoint(B, Br, base - ang));",
			"    if (d == sum * sum) { // 外切，多1条内公切线",
			"        a.push_back(getPoint(A, Ar, base));",
			"        b.push_back(getPoint(B, Br, base + PI));",
			"    } else if (d > sum * sum) { // 相离，多2条内公切线",
			"        ang = std::acos(sum / std::sqrt(d));",
			"        a.push_back(getPoint(A, Ar, base + ang));",
			"        a.push_back(getPoint(A, Ar, base - ang));",
			"        b.push_back(getPoint(B, Br, base + ang + PI));",
			"        b.push_back(getPoint(B, Br, base - ang + PI));",
			"    }",
			"    return {a.size(), a, b};",
			"}"
		],
		"description": "Tangent"
	},
	"area": {
		"scope": "cpp",
		"prefix": "area",
		"body": [
			"ld area(Point<ld> a, Point<ld> b, Point<ld> c) {",
			"    return std::abs(cross(b, c, a)) / 2;",
			"}"
		],
		"description": "Area"
	},
	"center1": {
		"scope": "cpp",
		"prefix": "center1",
		"body": [
			"template<typename T> Pt center1(Pt p1, Pt p2, Pt p3) { // 外心",
			"    return lineIntersection(midSegment({p1, p2}), midSegment({p2, p3}));",
			"}"
		],
		"description": "Center1"
	},
	"center2": {
		"scope": "cpp",
		"prefix": "center2",
		"body": [
			"Pd center2(Pd p1, Pd p2, Pd p3) { // 内心",
			"    #define atan2(p) atan2(p.y, p.x) // 注意先后顺序",
			"    Line<ld> U = {p1, {}}, V = {p2, {}};",
			"    ld m, n, alpha;",
			"    m = atan2((p2 - p1));",
			"    n = atan2((p3 - p1));",
			"    alpha = (m + n) / 2;",
			"    U.b = {p1.x + std::cos(alpha), p1.y + std::sin(alpha)};",
			"    m = atan2((p1 - p2));",
			"    n = atan2((p3 - p2));",
			"    alpha = (m + n) / 2;",
			"    V.b = {p2.x + std::cos(alpha), p2.y + std::sin(alpha)};",
			"    return lineIntersection(U, V);",
			"}"
		],
		"description": "Center2"
	},
	"center3": {
		"scope": "cpp",
		"prefix": "center3",
		"body": [
			"Pd center3(Pd p1, Pd p2, Pd p3) { // 垂心",
			"    Ld U = {p1, p1 + rotate(p2, p3)}; // 垂线",
			"    Ld V = {p2, p2 + rotate(p1, p3)};",
			"    return lineIntersection(U, V);",
			"}"
		],
		"description": "Center3"
	},
	"slope": {
		"scope": "cpp",
		"prefix": "slope",
		"body": [
			"template<typename T> ld slope(Pt p1, Pt p2) { // 斜率，注意 inf 的情况",
			"    return (p1.y - p2.y) / (p1.x - p2.x);",
			"}",
			"template<typename T> ld slope(Lt l) {",
			"    return slope(l.a, l.b);",
			"}"
		],
		"description": "Slope"
	},
	"slopeex": {
		"scope": "cpp",
		"prefix": "slopeex",
		"body": [
			"template<typename T> Frac<T> slopeEx(Pt p1, Pt p2) {",
			"    Frac<T> U = p1.y - p2.y;",
			"    Frac<T> V = p1.x - p2.x;",
			"    return U / V; // 调用分数精确计算",
			"}"
		],
		"description": "Slopeex"
	},
	"getfun": {
		"scope": "cpp",
		"prefix": "getfun",
		"body": [
			"template<typename T> std::tuple<int, int, int> getfun(Lt p) {",
			"    T A = p.a.y - p.b.y, B = p.b.x - p.a.x, C = p.a.x * A + p.a.y * B;",
			"    if (A < 0) { // 符号调整",
			"        A = -A, B = -B, C = -C;",
			"    } else if (A == 0) {",
			"        if (B < 0) {",
			"            B = -B, C = -C;",
			"        } else if (B == 0 && C < 0) {",
			"            C = -C;",
			"        }",
			"    }",
			"    if (A == 0) { // 数值计算",
			"        if (B == 0) {",
			"            C = 0; // 共点特判",
			"        } else {",
			"            T g = fgcd(std::abs(B), std::abs(C));",
			"            B /= g, C /= g;",
			"        }",
			"    } else if (B == 0) {",
			"        T g = fgcd(std::abs(A), std::abs(C));",
			"        A /= g, C /= g;",
			"    } else {",
			"        T g = fgcd(fgcd(std::abs(A), std::abs(B)), std::abs(C));",
			"        A /= g, B /= g, C /= g;",
			"    }",
			"    return std::tuple{A, B, C}; // Ax + By = C",
			"}"
		],
		"description": "Getfun"
	},
	"getfun_1": {
		"scope": "cpp",
		"prefix": "getfun",
		"body": [
			"Line<ld> getfun(int A, int B, int C) { // Ax + By = C",
			"    ld x1 = 0, y1 = 0, x2 = 0, y2 = 0;",
			"    if (A && B) { // 正常",
			"        if (C) {",
			"            x1 = 0, y1 = 1. * C / B;",
			"            y2 = 0, x2 = 1. * C / A;",
			"        } else { // 过原点",
			"            x1 = 1, y1 = 1. * -A / B;",
			"            x2 = 0, y2 = 0;",
			"        }",
			"    } else if (A && !B) { // 垂直",
			"        if (C) {",
			"            y1 = 0, x1 = 1. * C / A;",
			"            y2 = 1, x2 = x1;",
			"        } else {",
			"            x1 = 0, y1 = 1;",
			"            x2 = 0, y2 = 0;",
			"        }",
			"    } else if (!A && B) { // 水平",
			"        if (C) {",
			"            x1 = 0, y1 = 1. * C / B;",
			"            x2 = 1, y2 = y1;",
			"        } else {",
			"            x1 = 1, y1 = 0;",
			"            x2 = 0, y2 = 0;",
			"        }",
			"    } else { // 不合法，请特判",
			"        assert(false);",
			"    }",
			"    return {{x1, y1}, {x2, y2}};",
			"}"
		],
		"description": "Getfun"
	},
	"getans": {
		"scope": "cpp",
		"prefix": "getans",
		"body": [
			"std::tuple<int, ld, ld> getAns(ld a, ld b, ld c) {",
			"    ld delta = b * b - a * c * 4;",
			"    if (delta < 0.) {",
			"        return {0, 0, 0};",
			"    }",
			"    delta = std::sqrt(delta);",
			"    ld ans1 = -(delta + b) / 2 / a;",
			"    ld ans2 = (delta - b) / 2 / a;",
			"    if (ans1 > ans2) {",
			"        std::swap(ans1, ans2);",
			"    }",
			"    if (sign(delta) == 0) {",
			"        return {1, ans2, 0};",
			"    }",
			"    return {2, ans1, ans2};",
			"}"
		],
		"description": "Getans"
	},
	"p": {
		"scope": "cpp",
		"prefix": "p",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"#define endl '\\n'",
			"#define append push_back",
			"#define pop pop_back",
			"#define std::list std::vector",
			"//#include <bits/extc++.h>",
			"using namespace std;",
			"//using namespace __gnu_pbds;",
			"typedef long long ll;",
			"typedef unsigned long long ull;",
			"typedef std::pair<int, int> pii;",
			"typedef std::pair<ll, ll> pll;",
			"const int N = 2e5 + 5, inf = 0x3f3f3f3f, MOD = 998244353, mod = 1e9 + 7;",
			"const ll llinf = 0x3f3f3f3f3f3f3f3f;",
			"//const double PI=acos(-1);",
			"typedef double db;",
			"const db EPS = 1e-9;",
			"",
			"// long double的区分精度大约为2^-64,1e-15~1e-18",
			"// double的区分精度大约为2^-53,1e-12~1e-15",
			"//精度问题,求两个1e9内的点的斜率,误差为1e-18",
			"",
			"inline int sign(db a) { return a < -EPS ? -1 : a > EPS; }",
			"",
			"inline int cmp(db a, db b) { return sign(a - b); }",
			"",
			"struct P {",
			"    db x, y;",
			"",
			"    P() {}",
			"",
			"    P(db _x, db _y) : x(_x), y(_y) {}",
			"",
			"    P operator+(P p) { return {x + p.x, y + p.y}; }",
			"",
			"    P operator-(P p) { return {x - p.x, y - p.y}; }",
			"",
			"    P operator*(db d) { return {x * d, y * d}; }",
			"",
			"    P operator/(db d) { return {x / d, y / d}; }",
			"",
			"    bool operator<(P p) const {",
			"        int c = cmp(x, p.x);",
			"        if (c)return c == -1;",
			"        return cmp(y, p.y) == -1;",
			"    }",
			"",
			"    bool operator==(P o) const {",
			"        //没有传递性",
			"        return cmp(x, o.x) == 0 && cmp(y, o.y) == 0;",
			"    }",
			"",
			"",
			"    db dot(P p) { return x * p.x + y * p.y; }//点积, |a|*|b|*std::cos(an) 结果 大于0,两个向量夹角小于90度;等于0,两个向量夹角等于90度;小于0,两个向量夹角大于90度",
			"    db det(P p) {",
			"        return x * p.y - y * p.x;",
			"    }//叉积, |a|*|b|*std::sin(an) an为有向角, an为a逆时针旋转多少度到b, a x b = - (b x a). 结果 大于0,b在a的逆时针方向;等于0,共线;小于0,b在a的顺时针方向",
			"",
			"    db disTo(P p) { return (*this - p).std::abs(); }//两点距离",
			"    db disTo2(P p) { return (*this - p).abs2(); }//两点距离的平方",
			"    db alpha() { return atan2(y, x); }//求极角",
			"    void readint() {",
			"        int x_, y_;",
			"        std::cin >> x_ >> y_;",
			"        x = x_, y = y_;",
			"    }//输入整数",
			"    void readdb() { std::cin >> x >> y; }",
			"",
			"    void write() { cout << \"(\" << x << \", \" << y << \")\" << endl; }//输出",
			"    db std::abs() { return std::sqrt(abs2()); }//原点距离",
			"    db abs2() { return x * x + y * y; }//原点距离的平方",
			"    P rot90() { return P(-y, x); }//原点旋转90",
			"    int quad() const { return sign(y) == 1 || (sign(y) == 0 && sign(x) >= 0); }//判断点在上半边还是下半边",
			"    P unit() { return *this / std::abs(); }//单位向量",
			"",
			"    P rot(db an) {",
			"        return {x * std::cos(an) - y * std::sin(an), x * std::sin(an) + y * std::cos(an)};",
			"    }// 绕原点旋转an度表示: (x+yi)(std::cos(an)+std::sin(an)i)",
			"",
			"};",
			"",
			"#define cross(p1, p2, p3)((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))",
			"#define crossOp(p1, p2, p3) sign(cross(p1,p2,p3))",
			"",
			"//如果crossop大于0,表示p1,p2,p3为逆时针关系,小于0表示为顺时针关系,等于0为共线",
			"//也可以解释为p3在p1,p2的上方还是下方,还是p3在直线p1,p2上",
			"int cmp2(P A, P B) { return A.det(B) > 0 || (A.det(B) == 0 && A.abs2() < B.abs2()); }",
			"",
			"bool chkLL(P p1, P p2, P q1, P q2) {",
			"    ////两个线段是否平行",
			"    db a1 = cross(q1, q2, p1);",
			"    db a2 = -cross(q1, q2, p2);",
			"    return sign(a1 + a2) != 0;",
			"}",
			"",
			"P isLL(P p1, P p2, P q1, P q2) {",
			"    ////求出交点",
			"    db a1 = cross(q1, q2, p1);",
			"    db a2 = -cross(q1, q2, p2);",
			"    return (p1 * a2 + p2 * a1) / (a1 + a2);",
			"}",
			"",
			"bool intersect(db l1, db r1, db l2, db r2) {",
			"    ////判断[l1,r1],[l2,r2]是否相交",
			"    if (l1 > r1) std::swap(l1, r1);",
			"    if (l2 > r2) std::swap(l2, r2);",
			"    return !(cmp(r1, l2) == -1 || cmp(r2, l1) == -1);",
			"}",
			"",
			"bool isSS(P p1, P p2, P q1, P q2) {",
			"    ////线段是否相交",
			"    return intersect(p1.x, p2.x, q1.x, q2.x) && intersect(p1.y, p2.y, q1.y, q2.y) &&",
			"           crossOp(p1, p2, q1) * crossOp(p1, p2, q2) <= 0 && crossOp(q1, q2, p1) * crossOp(q1, q2, p2) <= 0;",
			"}",
			"",
			"bool isSS_strict(P p1, P p2, P q1, P q2) {",
			"    ////线段是否严格相交",
			"    ////严格相交指:只有一个公共点,且不能端点相交,就是一个x的形状",
			"    return crossOp(p1, p2, q1) * crossOp(p1, p2, q2) < 0 && crossOp(q1, q2, p1) * crossOp(q1, q2, p2) < 0;",
			"}",
			"",
			"bool isMiddle(db a, db b, db m) {",
			"    ////点m在不在区间[a,b]上",
			"    if (a > b)std::swap(a, b);",
			"    return cmp(a, m) <= 0 && cmp(m, b) <= 0;",
			"}",
			"",
			"bool isMiddle(P a, P b, P m) {",
			"    ////判断直线q1q2和直线p1p2的交点在不在线段p1,p2上,可以调用isMiddle,精度比onSeg更优",
			"    return isMiddle(a.x, b.x, m.x) && isMiddle(a.y, b.y, m.y);",
			"}",
			"",
			"bool onSeg(P p1, P p2, P q) {",
			"    ////p在不在线段p1,p2上",
			"    //可能精度有点问题",
			"    return crossOp(p1, p2, q) == 0 && isMiddle(p1, p2, q);",
			"}",
			"",
			"bool onSeg_strict(P p1, P p2, P q) {",
			"    ////p是不是严格在线段p1,p2上",
			"    return crossOp(p1, p2, q) == 0 && sign((q - p1).dot(p1 - p2)) * sign((q - p2).dot(p1 - p2)) < 0;",
			"}",
			"",
			"P proj(P p1, P p2, P q) {",
			"    ////求q到p1p2的垂足,且p1!=p2",
			"    if (p1 == p2)return p1;",
			"    P dir = p2 - p1;",
			"    return p1 + dir * (dir.dot(q - p1) / dir.abs2());",
			"}",
			"",
			"P reflect(P p1, P p2, P q) {",
			"    ////求q关于p1p2的反射",
			"    return proj(p1, p2, q) * 2 - q;",
			"}",
			"",
			"db nearest(P p1, P p2, P q) {",
			"    ////求q到线段p1p2的最小距离",
			"    if (p1 == p2)return p1.disTo(q);",
			"    P h = proj(p1, p2, q);",
			"    if (isMiddle(p1, p2, h))return q.disTo(h);",
			"    return std::min(p1.disTo(q), p2.disTo(q));",
			"}",
			"",
			"db disSS(P p1, P p2, P q1, P q2) {",
			"    ////求线段p1p2到q1q2的距离",
			"    if (isSS(p1, p2, q1, q2))return 0;",
			"    return std::min(std::min(nearest(p1, p2, q1), nearest(p1, p2, q2)), std::min(nearest(q1, q2, p1), nearest(q1, q2, p2)));",
			"}",
			"//极角排序",
			"/*",
			"std::sort(p,p+n,[&](const P &a,const P &b){",
			"\tint qa = a.quad(),qb=b.quad();",
			"\tif(qa!=qb) return qa<qb;",
			"\treturn sign(a.det(b)) > 0;",
			"});",
			"*/",
			"bool cmp1(P a, const P &b) {",
			"    int qa = a.quad(), qb = b.quad();",
			"    if (qa != qb) return qa < qb;",
			"    return sign(a.det(b)) > 0;",
			"}",
			"",
			"int type(P o1, db r1, P o2, db r2) {",
			"    ///求两个圆的关系",
			"    /// 4 : 相离",
			"    /// 3 : 外切",
			"    /// 2 : 相交",
			"    /// 1 : 内切",
			"    /// 0 : 内含",
			"    db d = o1.disTo(o2);",
			"    if (cmp(d, r1 + r2) == 1) return 4;",
			"    if (cmp(d, r1 + r2) == 0) return 3;",
			"    if (cmp(d, std::abs(r1 - r2)) == 1) return 2;",
			"    if (cmp(d, std::abs(r1 - r2)) == 0) return 1;",
			"    return 0;",
			"}",
			"",
			"std::vector<P> isCL(P o, db r, P p1, P p2) {",
			"    ///求圆和直线的交点,返回的两个点属于p1->p2方向",
			"    if (cmp(std::abs((o - p1).det(p2 - p1) / p1.disTo(p2)), r) > 0) return {};",
			"    db x = (p1 - o).dot(p2 - p1), y = (p2 - p1).abs2(), d = x * x - y * ((p1 - o).abs2() - r * r);",
			"    d = std::max(d, (db) 0.0);",
			"    P m = p1 - (p2 - p1) * (x / y), dr = (p2 - p1) * (std::sqrt(d) / y);",
			"    return {m - dr, m + dr};",
			"}",
			"",
			"std::vector<P> isCC(P o1, db r1, P o2, db r2) {",
			"    ///两个圆的交点,需要判断两个圆是否全等",
			"    ///返回的交点沿着第一个圆的逆时针方向",
			"    db d = o1.disTo(o2);",
			"    if (cmp(d, r1 + r2) == 1)return {};",
			"    if (cmp(d, std::abs(r1 - r2)) == -1)return {};",
			"    d = std::min(d, r1 + r2);",
			"    db y = (r1 * r1 + d * d - r2 * r2) / (2 * d), x = std::sqrt(r1 * r1 - y * y);",
			"    P dr = (o2 - o1).unit();",
			"    P q1 = o1 + dr * y, q2 = dr.rot90() * x;",
			"    return {q1 - q2, q1 + q2};",
			"}",
			"",
			"std::vector<std::pair<P, P>> tancCC(P o1, db r1, P o2, db r2) {",
			"    ///两个圆的外切线,如果需要内切线,把r2传入负值即可,如果需要点到圆的切线,把r2传为0即可",
			"    P d = o2 - o1;",
			"    db dr = r1 - r2, d2 = d.abs2(), h2 = d2 - dr * dr;",
			"    if (sign(d2) == 0 || sign(h2) < 0)return {};",
			"    h2 = std::max((db) 0.0, h2);",
			"    std::vector<std::pair<P, P>> ret;",
			"    for (db sign: {-1, 1}) {",
			"        P v = (d * dr + d.rot90() * std::sqrt(h2) * sign) / d2;",
			"        ret.push_back({o1 + v * r1, o2 + v * r2});",
			"    }",
			"    if (sign(h2) == 0)ret.pop_back();",
			"    return ret;",
			"}",
			"",
			"db rad(P p1, P p2) {",
			"    ///求两个向量的夹角弧度",
			"    return atan2l(p1.det(p2), p1.dot(p2));",
			"}",
			"",
			"db areaCT(P o, db r, P p1, P p2) {",
			"    ///圆和其中一个顶点是圆心的三角形的面积交,返回有向面积",
			"    p1 = p1 - o;",
			"    p2 = p2 - o;",
			"    std::vector<P> is = isCL(P(0, 0), r, p1, p2);",
			"    if (is.empty()) return r * r * rad(p1, p2) / 2;",
			"    bool b1 = cmp(p1.abs2(), r * r) == 1, b2 = cmp(p2.abs2(), r * r) == 1;",
			"    if (b1 && b2) {",
			"        P md = (is[0] + is[1]) / 2;",
			"        if (sign((p1 - md).dot(p2 - md)) <= 0)",
			"            return r * r * (rad(p1, is[0]) + rad(is[1], p2)) / 2 + is[0].det(is[1]) / 2;",
			"        else return r * r * rad(p1, p2) / 2;",
			"    }",
			"    if (b1) return (r * r * rad(p1, is[0]) + is[0].det(p2)) / 2;",
			"    if (b2) return (p1.det(is[1]) + r * r * rad(is[1], p2)) / 2;",
			"    return p1.det(p2) / 2;",
			"}",
			"",
			"",
			"P inCenter(P A, P B, P C) {",
			"    ///三角形内心",
			"    double a = (B - C).std::abs(), b = (C - A).std::abs(), c = (A - B).std::abs();",
			"    return (A * a + B * b + C * c) / (a + b + c);",
			"}",
			"",
			"P circumCenter(P a, P b, P c) {",
			"    ///三角形外心",
			"    P bb = b - a, cc = c - a;",
			"    double db = bb.abs2(), dc = cc.abs2(), d = 2 * bb.det(cc);",
			"    return a - P(bb.y * dc - cc.y * db, cc.x * db - bb.x * dc) / d;",
			"}",
			"",
			"P othroCenter(P a, P b, P c) {",
			"    ///三角形垂心",
			"    P ba = b - a, ca = c - a, bc = b - c;",
			"    double Y = ba.y * ca.y * bc.y,",
			"            A = ca.x * ba.y - ba.x * ca.y,",
			"            x0 = (Y + ca.x * ba.y * b.x - ba.x * ca.y * c.x) / A,",
			"            y0 = -ba.x * (x0 - c.x) / ba.y + ca.y;",
			"    return {x0, y0};",
			"}",
			"",
			"std::pair<P, db> min_circle(std::vector<P> ps) {",
			"    ///最小圆覆盖,给定若干个点,求最小的一个圆能够覆盖这些点,复杂度为O(n)",
			"    random_shuffle(ps.begin(), ps.end());",
			"    int n = ps.size();",
			"    P o = ps[0];",
			"    db r = 0;",
			"    for (int i = 1; i < n; ++i) {",
			"        if (o.disTo(ps[i]) > r + EPS)",
			"            o = ps[i], r = 0;",
			"        for (int j = 0; j < i; ++j)",
			"            if (o.disTo(ps[j]) > r + EPS) {",
			"                o = (ps[i] + ps[j]) / 2;",
			"                r = o.disTo(ps[i]);",
			"                for (int k = 0; k < j; ++k)",
			"                    if (o.disTo(ps[k]) > r + EPS) {",
			"                        o = circumCenter(ps[i], ps[j], ps[k]);",
			"                        r = o.disTo(ps[i]);",
			"                    }",
			"            }",
			"    }",
			"    return {o, r};",
			"}",
			"",
			"",
			"db area(std::vector<P> ps) {",
			"    ////计算多边形面积",
			"    db ret = 0;",
			"    int n = ps.size();",
			"    for (int i = 0; i < ps.size(); ++i) {",
			"        ret += ps[i].det(ps[(i + 1) % n]);",
			"    }",
			"    return ret / 2;",
			"}",
			"",
			"",
			"int containP(const std::vector<P> &ps, P p) {",
			"    ////判断点是否在多边形内部",
			"    ////如果返回 0:不在内部;1:在边界上;2:在内部",
			"    int n = ps.size(), ret = 0;",
			"    for (int i = 0; i < n; ++i) {",
			"        P u = ps[i], v = ps[(i + 1) % n];",
			"        if (onSeg(u, v, p)) return 1;",
			"        if (cmp(u.y, v.y) <= 0) std::swap(u, v);",
			"        if (cmp(p.y, u.y) > 0 || cmp(p.y, v.y) <= 0)continue;",
			"        ret ^= crossOp(p, u, v) > 0;",
			"    }",
			"    return ret * 2;",
			"}",
			"",
			"",
			"std::vector<P> convexHull(std::vector<P> ps) {",
			"    ////求严格凸包",
			"    int n = ps.size();",
			"    if (n <= 1)return ps;",
			"    std::sort(ps.begin(), ps.end());",
			"    std::vector<P> qs(n * 2);",
			"    int k = 0;",
			"    for (int i = 0; i < n; qs[k++] = ps[i++]) {//求下凸壳",
			"        while (k > 1 && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0)--k;",
			"    }",
			"    for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--]) {//求上凸壳",
			"        while (k > t && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0)--k;",
			"    }",
			"    qs.resize(k - 1);",
			"    return qs;",
			"}",
			"",
			"std::vector<P> convexHullnonstrict(std::vector<P> ps) {",
			"    ////求不严格凸包,需要先去重",
			"    int n = ps.size();",
			"    if (n <= 1)return ps;",
			"    std::sort(ps.begin(), ps.end());",
			"    std::vector<P> qs(n * 2);",
			"    int k = 0;",
			"    for (int i = 0; i < n; qs[k++] = ps[i++]) {//求下凸壳",
			"        while (k > 1 && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0)--k;",
			"    }",
			"    for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--]) {//求上凸壳",
			"        while (k > t && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0)--k;",
			"    }",
			"    qs.resize(k - 1);",
			"    return qs;",
			"}",
			"",
			"db convexDiamter(std::vector<P> ps) {",
			"    ////求凸包最大直径",
			"    int n = ps.size();",
			"    if (n <= 1)return 0;",
			"    int is = 0;",
			"    int js = 0;",
			"    for (int k = 1; k < n; ++k) {",
			"        is = ps[k] < ps[is] ? k : is, js = ps[js] < ps[k] ? k : js;",
			"    }",
			"    int i = is, j = js;",
			"    db ret = ps[i].disTo(ps[j]);",
			"    do {",
			"        if ((ps[(i + 1) % n] - ps[i]).det(ps[(j + 1) % n] - ps[j]) >= 0)",
			"            (++j) %= n;",
			"        else",
			"            (++i) %= n;",
			"        ret = std::max(ret, ps[i].disTo(ps[j]));",
			"    } while (i != is || j != js);",
			"    return ret;",
			"}",
			"",
			"",
			"std::vector<P> convexCut(const std::vector<P> &ps, P q1, P q2) {",
			"    ////用直线切割ps,返回切线左边的点以及交点",
			"    std::vector<P> qs;",
			"    int n = ps.size();",
			"    for (int i = 0; i < n; ++i) {",
			"        P p1 = ps[i], p2 = ps[(i + 1) % n];",
			"        int d1 = crossOp(q1, q2, p1), d2 = crossOp(q1, q2, p2);",
			"        if (d1 >= 0) qs.push_back(p1);",
			"        if (d1 * d2 < 0) qs.push_back(isLL(p1, p2, q1, q2));",
			"    }",
			"    return qs;",
			"}",
			"",
			"std::vector<P> isLD(const std::vector<P> &ps, P q1, P q2) {",
			"    ////返回直线和多边形的所有交点",
			"    int n = ps.size();",
			"    std::vector<P> qs;",
			"    for (int i = 0; i < n; ++i) {",
			"        if (crossOp(q1, q2, ps[i]) == 0)qs.push_back(ps[i]);",
			"        if (crossOp(q1, q2, ps[i]) * crossOp(q1, q2, ps[(i + 1) % n]) < 0)",
			"            qs.push_back(isLL(q1, q2, ps[i], ps[(i + 1) % n]));",
			"    }",
			"    std::sort(qs.begin(), qs.end());",
			"    qs.erase(std::unique(qs.begin(), qs.end()), qs.end());",
			"    return qs;",
			"}",
			"",
			"std::vector<P> isSD(const std::vector<P> &ps, P q1, P q2) {",
			"    ////返回直线和多边形的所有交点",
			"    int n = ps.size();",
			"    std::vector<P> qs;",
			"    qs.push_back(q1);",
			"    qs.push_back(q2);",
			"    for (int i = 0; i < n; ++i) {",
			"        if (crossOp(q1, q2, ps[i]) == 0)qs.push_back(ps[i]);",
			"        if (crossOp(q1, q2, ps[i]) * crossOp(q1, q2, ps[(i + 1) % n]) < 0)",
			"            qs.push_back(isLL(q1, q2, ps[i], ps[(i + 1) % n]));",
			"    }",
			"    std::sort(qs.begin(), qs.end());",
			"    qs.erase(std::unique(qs.begin(), qs.end()), qs.end());",
			"    int s = -1, t = -1;",
			"    for (int i = 0; i < n; ++i) {",
			"        if (q1 == qs[i])s = i;",
			"        if (q2 == qs[i])t = i;",
			"    }",
			"    if (s > t)std::swap(s, t);",
			"    std::vector<P> ks;",
			"    for (int i = s; i < t; ++i) {",
			"        ks.push_back(qs[i]);",
			"    }",
			"    return ks;",
			"}",
			"",
			"",
			"bool containSeg(std::vector<P> ps, P p1, P p2) {",
			"    ////判断线段是否在内部",
			"    std::vector<P> qs = isSD(ps, p1, p2);",
			"    int n = qs.size();",
			"    for (int i = 0; i < n - 1; ++i) {",
			"        P m = (qs[i] + qs[i + 1]) / 2;",
			"        if (containP(qs, m) == 0)return false;",
			"    }",
			"    return true;",
			"}",
			"",
			"std::vector<P> Minkowski(std::vector<P> A, std::vector<P> B) {",
			"    std::vector<P> C(A.size() + B.size() + 1), v1(A.size()), v2(B.size());",
			"    for (int i = 0; i < (int) A.size(); i++)v1[i] = A[(i + 1) % A.size()] - A[i];",
			"    for (int i = 0; i < (int) B.size(); i++)v2[i] = B[(i + 1) % B.size()] - B[i];",
			"    int cnt = 0;",
			"    C[cnt] = (A[0] + B[0]);",
			"    int p1 = 0, p2 = 0;",
			"    while (p1 < (int) A.size() && p2 < (int) B.size()) {",
			"        ++cnt;",
			"        if (sign(v1[p1].det(v2[p2])) >= 0)",
			"            C[cnt] = C[cnt - 1] + v1[p1++];",
			"        else",
			"            C[cnt] = C[cnt - 1] + v2[p2++];",
			"    }",
			"    while (p1 < (int) A.size()) {",
			"        ++cnt;",
			"        C[cnt] = C[cnt - 1] + v1[p1++];",
			"    }",
			"    while (p2 < (int) B.size()) {",
			"        ++cnt;",
			"        C[cnt] = C[cnt - 1] + v2[p2++];",
			"    }",
			"    return C;",
			"}",
			"",
			"bool containPs(const std::vector<P> &ts, P q) {",
			"    ///判断点集是否在线段内,要保证ps[0]={0,0};",
			"    int ps = std::upper_bound(ts.begin(), ts.end(), q, cmp2) - ts.begin() - 1;",
			"    return (crossOp(ts[ps], ts[(ps + 1) % ts.size()], q) >= 0);",
			"}",
			"",
			"",
			"void solve() {",
			"",
			"",
			"}",
			"",
			"",
			"int main() {",
			"    std::ios::std::sync_with_stdio(false);",
			"    std::cin.std::tie(nullptr);",
			"//    freopen(\".\\\\Template\\\\CHECK\\\\data.in\", \"r\", stdin);",
			"//    freopen(\".\\\\Template\\\\CHECK\\\\std.out\", \"w\", stdout);",
			"    int cases;",
			"    std::cin >> cases;",
			"    while (cases--)",
			"        solve();",
			"}"
		],
		"description": "P"
	},
	"areaex": {
		"scope": "cpp",
		"prefix": "areaex",
		"body": [
			"template<typename T> T areaEx(Point<T> p1, Point<T> p2, Point<T> p3) {",
			"    return cross(b, c, a);",
			"}"
		],
		"description": "Areaex"
	},
	"issquare": {
		"scope": "cpp",
		"prefix": "issquare",
		"body": [
			"template<typename T> int isSquare(std::vector<Pt> x) {",
			"    std::sort(x.begin(), x.end());",
			"    if (equal(dis(x[0], x[1]), dis(x[2], x[3])) && sign(dis(x[0], x[1])) &&",
			"        equal(dis(x[0], x[2]), dis(x[1], x[3])) && sign(dis(x[0], x[2])) &&",
			"        lineParallel(Lt{x[0], x[1]}, Lt{x[2], x[3]}) &&",
			"        lineParallel(Lt{x[0], x[2]}, Lt{x[1], x[3]}) &&",
			"        lineVertical(Lt{x[0], x[1]}, Lt{x[0], x[2]})) {",
			"        return equal(dis(x[0], x[1]), dis(x[0], x[2])) ? 2 : 1;",
			"    }",
			"    return 0;",
			"}"
		],
		"description": "Issquare"
	},
	"pointinpolygon": {
		"scope": "cpp",
		"prefix": "pointinpolygon",
		"body": [
			"template<typename T> int pointInPolygon(Point<T> a, std::vector<Point<T>> p) {",
			"    int n = p.size();",
			"    for (int i = 0; i < n; i++) {",
			"        if (pointOnSegment(a, Line{p[i], p[(i + 1) % n]})) {",
			"            return 2;",
			"        }",
			"    }",
			"    int t = 0;",
			"    for (int i = 0; i < n; i++) {",
			"        auto u = p[i], v = p[(i + 1) % n];",
			"        if (u.x < a.x && v.x >= a.x && pointOnLineLeft(a, Line{v, u})) {",
			"            t ^= 1;",
			"        }",
			"        if (u.x >= a.x && v.x < a.x && pointOnLineLeft(a, Line{u, v})) {",
			"            t ^= 1;",
			"        }",
			"    }",
			"    return t == 1;",
			"}"
		],
		"description": "Pointinpolygon"
	},
	"segmentinpolygon": {
		"scope": "cpp",
		"prefix": "segmentinpolygon",
		"body": [
			"template<typename T>",
			"bool segmentInPolygon(Line<T> l, std::vector<Point<T>> p) {",
			"// 线段与多边形边界不相交且两端点都在多边形内部",
			"#define L(x, y) pointOnLineLeft(x, y)",
			"    int n = p.size();",
			"    if (!pointInPolygon(l.a, p)) return false;",
			"    if (!pointInPolygon(l.b, p)) return false;",
			"    for (int i = 0; i < n; i++) {",
			"        auto u = p[i];",
			"        auto v = p[(i + 1) % n];",
			"        auto w = p[(i + 2) % n];",
			"        auto [t, p1, p2] = segmentIntersection(l, Line(u, v));",
			"        if (t == 1) return false;",
			"        if (t == 0) continue;",
			"        if (t == 2) {",
			"            if (pointOnSegment(v, l) && v != l.a && v != l.b) {",
			"                if (cross(v - u, w - v) > 0) {",
			"                    return false;",
			"                }",
			"            }",
			"        } else {",
			"            if (p1 != u && p1 != v) {",
			"                if (L(l.a, Line(v, u)) || L(l.b, Line(v, u))) {",
			"                    return false;",
			"                }",
			"            } else if (p1 == v) {",
			"                if (l.a == v) {",
			"                    if (L(u, l)) {",
			"                        if (L(w, l) && L(w, Line(u, v))) {",
			"                            return false;",
			"                        }",
			"                    } else {",
			"                        if (L(w, l) || L(w, Line(u, v))) {",
			"                            return false;",
			"                        }",
			"                    }",
			"                } else if (l.b == v) {",
			"                    if (L(u, Line(l.b, l.a))) {",
			"                        if (L(w, Line(l.b, l.a)) && L(w, Line(u, v))) {",
			"                            return false;",
			"                        }",
			"                    } else {",
			"                        if (L(w, Line(l.b, l.a)) || L(w, Line(u, v))) {",
			"                            return false;",
			"                        }",
			"                    }",
			"                } else {",
			"                    if (L(u, l)) {",
			"                        if (L(w, Line(l.b, l.a)) || L(w, Line(u, v))) {",
			"                            return false;",
			"                        }",
			"                    } else {",
			"                        if (L(w, l) || L(w, Line(u, v))) {",
			"                            return false;",
			"                        }",
			"                    }",
			"                }",
			"            }",
			"        }",
			"    }",
			"    return true;",
			"}"
		],
		"description": "Segmentinpolygon"
	},
	"area_1": {
		"scope": "cpp",
		"prefix": "area",
		"body": [
			"template<typename T> ld area(std::vector<Point<T>> P) {",
			"    int n = P.size();",
			"    ld ans = 0;",
			"    for (int i = 0; i < n; i++) {",
			"        ans += cross(P[i], P[(i + 1) % n]);",
			"    }",
			"    return ans / 2.0;",
			"}"
		],
		"description": "Area"
	},
	"onpolygongrid": {
		"scope": "cpp",
		"prefix": "onpolygongrid",
		"body": [
			"int onPolygonGrid(std::vector<Point<int>> p) { // 多边形上",
			"    int n = p.size(), ans = 0;",
			"    for (int i = 0; i < n; i++) {",
			"        auto a = p[i], b = p[(i + 1) % n];",
			"        ans += std::gcd(std::abs(a.x - b.x), std::abs(a.y - b.y));",
			"    }",
			"    return ans;",
			"}",
			"int inPolygonGrid(std::vector<Point<int>> p) { // 多边形内",
			"    int n = p.size(), ans = 0;",
			"    for (int i = 0; i < n; i++) {",
			"        auto a = p[i], b = p[(i + 1) % n], c = p[(i + 2) % n];",
			"        ans += b.y * (a.x - c.x);",
			"    }",
			"    ans = std::abs(ans);",
			"    return (ans - onPolygonGrid(p)) / 2 + 1;",
			"}"
		],
		"description": "Onpolygongrid"
	},
	"staticconvexhull": {
		"scope": "cpp",
		"prefix": "staticconvexhull",
		"body": [
			"template<typename T> std::vector<Point<T>> staticConvexHull(std::vector<Point<T>> A, int flag = 1) {",
			"    int n = A.size();",
			"    if (n <= 2) { // 特判",
			"        return A;",
			"    }",
			"    std::vector<Point<T>> ans(n * 2);",
			"    std::sort(A.begin(), A.end());",
			"    int now = -1;",
			"    for (int i = 0; i < n; i++) { // 维护下凸包",
			"        while (now > 0 && cross(A[i], ans[now], ans[now - 1]) <= 0) {",
			"            now--;",
			"        }",
			"        ans[++now] = A[i];",
			"    }",
			"    int pre = now;",
			"    for (int i = n - 2; i >= 0; i--) { // 维护上凸包",
			"        while (now > pre && cross(A[i], ans[now], ans[now - 1]) <= 0) {",
			"            now--;",
			"        }",
			"        ans[++now] = A[i];",
			"    }",
			"    ans.resize(now);",
			"    return ans;",
			"}"
		],
		"description": "Staticconvexhull"
	},
	"line": {
		"scope": "cpp",
		"prefix": "line",
		"body": [
			"template<typename T> bool turnRight(Pt a, Pt b) {",
			"    return cross(a, b) < 0 || (cross(a, b) == 0 && dot(a, b) < 0);",
			"}",
			"struct Line {",
			"    static int cmp;",
			"    mutable Point<int> a, b;",
			"    friend bool operator<(Line x, Line y) {",
			"        return cmp ? x.a < y.a : turnRight(x.b, y.b);",
			"    }",
			"    friend auto &operator<<(ostream &os, Line l) {",
			"        return os << \"<\" << l.a << \", \" << l.b << \">\";",
			"    }",
			"};",
			"",
			"int Line::cmp = 1;",
			"struct UpperConvexHull : std::set<Line> {",
			"    bool contains(const Point<int> &p) const {",
			"        auto it = std::lower_bound({p, 0});",
			"        if (it != end() && it->a == p) return true;",
			"        if (it != begin() && it != end() && cross(prev(it)->b, p - prev(it)->a) <= 0) {",
			"            return true;",
			"        }",
			"        return false;",
			"    }",
			"    void add(const Point<int> &p) {",
			"        if (contains(p)) return;",
			"        auto it = std::lower_bound({p, 0});",
			"        for (; it != end(); it = erase(it)) {",
			"            if (turnRight(it->a - p, it->b)) {",
			"                break;",
			"            }",
			"        }",
			"        for (; it != begin() && prev(it) != begin(); erase(prev(it))) {",
			"            if (turnRight(prev(prev(it))->b, p - prev(prev(it))->a)) {",
			"                break;",
			"            }",
			"        }",
			"        if (it != begin()) {",
			"            prev(it)->b = p - prev(it)->a;",
			"        }",
			"        if (it == end()) {",
			"            insert({p, {0, -1}});",
			"        } else {",
			"            insert({p, it->a - p});",
			"        }",
			"    }",
			"};",
			"struct ConvexHull {",
			"    UpperConvexHull up, low;",
			"    bool empty() const {",
			"        return up.empty();",
			"    }",
			"    bool contains(const Point<int> &p) const {",
			"        Line::cmp = 1;",
			"        return up.contains(p) && low.contains(-p);",
			"    }",
			"    void add(const Point<int> &p) {",
			"        Line::cmp = 1;",
			"        up.add(p);",
			"        low.add(-p);",
			"    }",
			"    bool isIntersect(int A, int B, int C) const {",
			"        Line::cmp = 0;",
			"        if (empty()) return false;",
			"        Point<int> k = {-B, A};",
			"        if (k.x < 0) k = -k;",
			"        if (k.x == 0 && k.y < 0) k.y = -k.y;",
			"        Point<int> P = up.std::upper_bound({{0, 0}, k})->a;",
			"        Point<int> Q = -low.std::upper_bound({{0, 0}, k})->a;",
			"        return sign(A * P.x + B * P.y - C) * sign(A * Q.x + B * Q.y - C) > 0;",
			"    }",
			"    friend ostream &operator<<(ostream &out, const ConvexHull &ch) {",
			"        for (const auto &line : ch.up) out << \"(\" << line.a.x << \",\" << line.a.y << \")\";",
			"        cout << \"/\";",
			"        for (const auto &line : ch.low) out << \"(\" << -line.a.x << \",\" << -line.a.y << \")\";",
			"        return out;",
			"    }",
			"};"
		],
		"description": "Line"
	},
	"contains": {
		"scope": "cpp",
		"prefix": "contains",
		"body": [
			"template<typename T> int contains(Point<T> p, std::vector<Point<T>> A) {",
			"    int n = A.size();",
			"    bool in = false;",
			"    for (int i = 0; i < n; i++) {",
			"        Point<T> a = A[i] - p, b = A[(i + 1) % n] - p;",
			"        if (a.y > b.y) {",
			"            std::swap(a, b);",
			"        }",
			"        if (a.y <= 0 && 0 < b.y && cross(a, b) < 0) {",
			"            in = !in;",
			"        }",
			"        if (cross(a, b) == 0 && dot(a, b) <= 0) {",
			"            return 1;",
			"        }",
			"    }",
			"    return in ? 2 : 0;",
			"}"
		],
		"description": "Contains"
	},
	"mincowski": {
		"scope": "cpp",
		"prefix": "mincowski",
		"body": [
			"template<typename T> std::vector<Point<T>> mincowski(std::vector<Point<T>> P1, std::vector<Point<T>> P2) {",
			"    int n = P1.size(), m = P2.size();",
			"    std::vector<Point<T>> V1(n), V2(m);",
			"    for (int i = 0; i < n; i++) {",
			"        V1[i] = P1[(i + 1) % n] - P1[i];",
			"    }",
			"    for (int i = 0; i < m; i++) {",
			"        V2[i] = P2[(i + 1) % m] - P2[i];",
			"    }",
			"    std::vector<Point<T>> ans = {P1.front() + P2.front()};",
			"    int t = 0, i = 0, j = 0;",
			"    while (i < n && j < m) {",
			"        Point<T> val = sign(cross(V1[i], V2[j])) > 0 ? V1[i++] : V2[j++];",
			"        ans.push_back(ans.back() + val);",
			"    }",
			"    while (i < n) ans.push_back(ans.back() + V1[i++]);",
			"    while (j < m) ans.push_back(ans.back() + V2[j++]);",
			"    return ans;",
			"}"
		],
		"description": "Mincowski"
	},
	"halfcut": {
		"scope": "cpp",
		"prefix": "halfcut",
		"body": [
			"template<typename T> std::vector<Point<T>> halfcut(std::vector<Line<T>> lines) {",
			"    std::sort(lines.begin(), lines.end(), [&](auto l1, auto l2) {",
			"        auto d1 = l1.b - l1.a;",
			"        auto d2 = l2.b - l2.a;",
			"        if (sign(d1) != sign(d2)) {",
			"            return sign(d1) == 1;",
			"        }",
			"        return cross(d1, d2) > 0;",
			"    });",
			"    std::deque<Line<T>> ls;",
			"    std::deque<Point<T>> ps;",
			"    for (auto l : lines) {",
			"        if (ls.empty()) {",
			"            ls.push_back(l);",
			"            continue;",
			"        }",
			"        while (!ps.empty() && !pointOnLineLeft(ps.back(), l)) {",
			"            ps.pop_back();",
			"            ls.pop_back();",
			"        }",
			"        while (!ps.empty() && !pointOnLineLeft(ps[0], l)) {",
			"            ps.pop_front();",
			"            ls.pop_front();",
			"        }",
			"        if (cross(l.b - l.a, ls.back().b - ls.back().a) == 0) {",
			"            if (dot(l.b - l.a, ls.back().b - ls.back().a) > 0) {",
			"                if (!pointOnLineLeft(ls.back().a, l)) {",
			"                    assert(ls.size() == 1);",
			"                    ls[0] = l;",
			"                }",
			"                continue;",
			"            }",
			"            return {};",
			"        }",
			"        ps.push_back(lineIntersection(ls.back(), l));",
			"        ls.push_back(l);",
			"    }",
			"    while (!ps.empty() && !pointOnLineLeft(ps.back(), ls[0])) {",
			"        ps.pop_back();",
			"        ls.pop_back();",
			"    }",
			"    if (ls.size() <= 2) {",
			"        return {};",
			"    }",
			"    ps.push_back(lineIntersection(ls[0], ls.back()));",
			"    return std::vector(ps.begin(), ps.end());",
			"}"
		],
		"description": "Halfcut"
	}
}
