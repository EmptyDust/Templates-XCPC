{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"communication": {
		"scope": "c++,cpp",
		"prefix": "communication",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"#define ranges std::ranges",
			"#define views std::views",
			"",
			"using u32 = unsigned;",
			"using i64 = long long;",
			"using u64 = unsigned long long;",
			"using u128 = unsigned __int128;",
			"",
			"using a2 = std::array<int, 2>;",
			"using a3 = std::array<int, 3>;",
			"using a4 = std::array<int, 4>;",
			"",
			"const int N = 1e6;",
			"const int MAXN = 1e6 + 10;",
			"const int inf = 1e9;",
			"// const int mod = 1e9 + 7;",
			"const int mod = 998244353;",
			"",
			"void encode() {",
			"    $0",
			"}",
			"",
			"void decode() {",
			"    ",
			"}",
			"",
			"signed main() {",
			"    std::ios::sync_with_stdio(false);",
			"    std::cin.tie(0), std::cout.tie(0);",
			"    std::string type;std::cin >> type;",
			"    int t = 1;",
			"    std::cin >> t;",
			"    while (t--) {",
			"        if (type == \"first\") {",
			"            encode();",
			"        }",
			"        else {",
			"            decode();",
			"        }",
			"    }",
			"    return 0;",
			"}"
		],
		"description": "communication"
	},
	"sort": {
		"scope": "cpp",
		"prefix": "sort",
		"body": [
			"ranges::sort(${a});"
		],
		"description": "sort"
	},
	"MultiTests": {
		"scope": "c++,cpp",
		"prefix": "MultiTests",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"#define ranges std::ranges",
			"#define views std::views",
			"",
			"using u32 = unsigned;",
			"using i64 = long long;",
			"using u64 = unsigned long long;",
			"using u128 = unsigned __int128;",
			"",
			"using a2 = std::array<int, 2>;",
			"using a3 = std::array<int, 3>;",
			"using a4 = std::array<int, 4>;",
			"",
			"const int N = 1e6;",
			"const int MAXN = 1e6 + 10;",
			"const int inf = 1e9;",
			"// const int mod = 1e9 + 7;",
			"const int mod = 998244353;",
			"",
			"void solve() {",
			"    $0",
			"}",
			"",
			"signed main() {",
			"    std::ios::sync_with_stdio(false);",
			"    std::cin.tie(0), std::cout.tie(0);",
			"    int t;std::cin >> t;",
			"    while (t--) {",
			"        solve();",
			"        std::cout << '\\n';",
			"    }",
			"    return 0;",
			"}"
		],
		"description": "MultiTests"
	},
	"OneTest": {
		"scope": "c++,cpp",
		"prefix": "OneTest",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"#define ranges std::ranges",
			"#define views std::views",
			"",
			"using u32 = unsigned;",
			"using i64 = long long;",
			"using u64 = unsigned long long;",
			"using u128 = unsigned __int128;",
			"",
			"using a2 = std::array<int, 2>;",
			"using a3 = std::array<int, 3>;",
			"using a4 = std::array<int, 4>;",
			"",
			"const int N = 1e6;",
			"const int MAXN = 1e6 + 10;",
			"const int inf = 1e9;",
			"// const int mod = 1e9 + 7;",
			"const int mod = 998244353;",
			"",
			"void solve() {",
			"    $0",
			"}",
			"",
			"signed main() {",
			"    std::ios::sync_with_stdio(false);",
			"    std::cin.tie(0), std::cout.tie(0);",
			"    int t = 1;",
			"    while (t--) {",
			"        solve();",
			"        std::cout << '\\n';",
			"    }",
			"    return 0;",
			"}"
		],
		"description": "OneTest"
	},
	"all": {
		"scope": "c++,cpp",
		"prefix": "all",
		"body": [
			"${a}.begin(),${a}.end()"
		],
		"description": "for all."
	},
	"rall": {
		"scope": "c++,cpp",
		"prefix": "rall",
		"body": [
			"${a}.rbegin(),${a}.rend()"
		],
		"description": "for all reverse."
	},
	"memset": {
		"scope": "c++,cpp",
		"prefix": "mem",
		"body": [
			"memset(${x}, ${value:-1}, sizeof ${x});"
		],
		"description": "mem"
	},
	"rng": {
		"scope": "cpp",
		"prefix": "rng",
		"body": [
			"std::mt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count());"
		],
		"description": "rng"
	},
	"DynModInt": {
		"scope": "cpp",
		"prefix": "DynModInt",
		"body": [
			"template<u32 Id>",
			"struct DynModInt {",
			"public:",
			"    constexpr DynModInt() : x(0) {}",
			"    template<std::unsigned_integral T>",
			"    constexpr DynModInt(T x_) : x(x_% mod()) {}",
			"    template<std::signed_integral T>",
			"    constexpr DynModInt(T x_) {",
			"        int v = x_ % int(mod());",
			"        if (v < 0) {",
			"            v += mod();",
			"        }",
			"        x = v;",
			"    }",
			"",
			"    constexpr static void setMod(u32 m) {",
			"        bt = m;",
			"    }",
			"",
			"    static u32 mod() {",
			"        return bt.mod();",
			"    }",
			"",
			"    constexpr u32 val() const {",
			"        return x;",
			"    }",
			"",
			"    constexpr DynModInt operator-() const {",
			"        DynModInt res;",
			"        res.x = (x == 0 ? 0 : mod() - x);",
			"        return res;",
			"    }",
			"",
			"    constexpr DynModInt inv() const {",
			"        auto v = invGcd(x, mod());",
			"        assert(v.first == 1);",
			"        return v.second;",
			"    }",
			"",
			"    constexpr DynModInt& operator*=(const DynModInt& rhs)& {",
			"        x = bt.mul(x, rhs.val());",
			"        return *this;",
			"    }",
			"    constexpr DynModInt& operator+=(const DynModInt& rhs)& {",
			"        x += rhs.val();",
			"        if (x >= mod()) {",
			"            x -= mod();",
			"        }",
			"        return *this;",
			"    }",
			"    constexpr DynModInt& operator-=(const DynModInt& rhs)& {",
			"        x -= rhs.val();",
			"        if (x >= mod()) {",
			"            x += mod();",
			"        }",
			"        return *this;",
			"    }",
			"    constexpr DynModInt& operator/=(const DynModInt& rhs)& {",
			"        return *this *= rhs.inv();",
			"    }",
			"",
			"    friend constexpr DynModInt operator*(DynModInt lhs, const DynModInt& rhs) {",
			"        lhs *= rhs;",
			"        return lhs;",
			"    }",
			"    friend constexpr DynModInt operator+(DynModInt lhs, const DynModInt& rhs) {",
			"        lhs += rhs;",
			"        return lhs;",
			"    }",
			"    friend constexpr DynModInt operator-(DynModInt lhs, const DynModInt& rhs) {",
			"        lhs -= rhs;",
			"        return lhs;",
			"    }",
			"    friend constexpr DynModInt operator/(DynModInt lhs, const DynModInt& rhs) {",
			"        lhs /= rhs;",
			"        return lhs;",
			"    }",
			"",
			"    friend constexpr std::istream& operator>>(std::istream& is, DynModInt& a) {",
			"        i64 i;",
			"        is >> i;",
			"        a = i;",
			"        return is;",
			"    }",
			"    friend constexpr std::ostream& operator<<(std::ostream& os, const DynModInt& a) {",
			"        return os << a.val();",
			"    }",
			"",
			"    friend constexpr bool operator==(const DynModInt& lhs, const DynModInt& rhs) {",
			"        return lhs.val() == rhs.val();",
			"    }",
			"    friend constexpr std::strong_ordering operator<=>(const DynModInt& lhs, const DynModInt& rhs) {",
			"        return lhs.val() <=> rhs.val();",
			"    }",
			"",
			"private:",
			"    u32 x;",
			"    static Barrett bt;",
			"};",
			"",
			"template<u32 Id>",
			"Barrett DynModInt<Id>::bt = 998244353;"
		],
		"description": "DynModInt"
	},
	"modInt": {
		"scope": "cpp",
		"prefix": "modInt",
		"body": [
			"",
			"template<class T>",
			"constexpr T power(T a, u64 b, T res = 1) {",
			"    for (; b != 0; b /= 2, a *= a) {",
			"        if (b & 1) {",
			"            res *= a;",
			"        }",
			"    }",
			"    return res;",
			"}",
			"",
			"template<u32 P>",
			"constexpr u32 mulMod(u32 a, u32 b) {",
			"    return u64(a) * b % P;",
			"}",
			"",
			"template<u64 P>",
			"constexpr u64 mulMod(u64 a, u64 b) {",
			"    u64 res = a * b - u64(1.L * a * b / P - 0.5L) * P;",
			"    res %= P;",
			"    return res;",
			"}",
			"",
			"constexpr i64 safeMod(i64 x, i64 m) {",
			"    x %= m;",
			"    if (x < 0) {",
			"        x += m;",
			"    }",
			"    return x;",
			"}",
			"",
			"constexpr std::pair<i64, i64> invGcd(i64 a, i64 b) {",
			"    a = safeMod(a, b);",
			"    if (a == 0) {",
			"        return { b, 0 };",
			"    }",
			"",
			"    i64 s = b, t = a;",
			"    i64 m0 = 0, m1 = 1;",
			"",
			"    while (t) {",
			"        i64 u = s / t;",
			"        s -= t * u;",
			"        m0 -= m1 * u;",
			"",
			"        std::swap(s, t);",
			"        std::swap(m0, m1);",
			"    }",
			"",
			"    if (m0 < 0) {",
			"        m0 += b / s;",
			"    }",
			"",
			"    return { s, m0 };",
			"}",
			"",
			"template<std::unsigned_integral U, U P>",
			"struct ModIntBase {",
			"public:",
			"    constexpr ModIntBase() : x(0) {}",
			"    template<std::unsigned_integral T>",
			"    constexpr ModIntBase(T x_) : x(x_% mod()) {}",
			"    template<std::signed_integral T>",
			"    constexpr ModIntBase(T x_) {",
			"        using S = std::make_signed_t<U>;",
			"        S v = x_ % S(mod());",
			"        if (v < 0) {",
			"            v += mod();",
			"        }",
			"        x = v;",
			"    }",
			"",
			"    constexpr static U mod() {",
			"        return P;",
			"    }",
			"",
			"    constexpr U val() const {",
			"        return x;",
			"    }",
			"",
			"    constexpr ModIntBase operator-() const {",
			"        ModIntBase res;",
			"        res.x = (x == 0 ? 0 : mod() - x);",
			"        return res;",
			"    }",
			"",
			"    constexpr ModIntBase inv() const {",
			"        return power(*this, mod() - 2);",
			"    }",
			"",
			"    constexpr ModIntBase& operator*=(const ModIntBase& rhs)& {",
			"        x = mulMod<mod()>(x, rhs.val());",
			"        return *this;",
			"    }",
			"    constexpr ModIntBase& operator+=(const ModIntBase& rhs)& {",
			"        x += rhs.val();",
			"        if (x >= mod()) {",
			"            x -= mod();",
			"        }",
			"        return *this;",
			"    }",
			"    constexpr ModIntBase& operator-=(const ModIntBase& rhs)& {",
			"        x -= rhs.val();",
			"        if (x >= mod()) {",
			"            x += mod();",
			"        }",
			"        return *this;",
			"    }",
			"    constexpr ModIntBase& operator/=(const ModIntBase& rhs)& {",
			"        return *this *= rhs.inv();",
			"    }",
			"",
			"    friend constexpr ModIntBase operator*(ModIntBase lhs, const ModIntBase& rhs) {",
			"        lhs *= rhs;",
			"        return lhs;",
			"    }",
			"    friend constexpr ModIntBase operator+(ModIntBase lhs, const ModIntBase& rhs) {",
			"        lhs += rhs;",
			"        return lhs;",
			"    }",
			"    friend constexpr ModIntBase operator-(ModIntBase lhs, const ModIntBase& rhs) {",
			"        lhs -= rhs;",
			"        return lhs;",
			"    }",
			"    friend constexpr ModIntBase operator/(ModIntBase lhs, const ModIntBase& rhs) {",
			"        lhs /= rhs;",
			"        return lhs;",
			"    }",
			"",
			"    friend constexpr std::istream& operator>>(std::istream& is, ModIntBase& a) {",
			"        i64 i;",
			"        is >> i;",
			"        a = i;",
			"        return is;",
			"    }",
			"    friend constexpr std::ostream& operator<<(std::ostream& os, const ModIntBase& a) {",
			"        return os << a.val();",
			"    }",
			"",
			"    friend constexpr bool operator==(const ModIntBase& lhs, const ModIntBase& rhs) {",
			"        return lhs.val() == rhs.val();",
			"    }",
			"    friend constexpr std::strong_ordering operator<=>(const ModIntBase& lhs, const ModIntBase& rhs) {",
			"        return lhs.val() <=> rhs.val();",
			"    }",
			"",
			"private:",
			"    U x;",
			"};",
			"",
			"template<u32 P>",
			"using ModInt = ModIntBase<u32, P>;",
			"template<u64 P>",
			"using ModInt64 = ModIntBase<u64, P>;",
			"",
			"struct Barrett {",
			"public:",
			"    Barrett(u32 m_) : m(m_), im((u64)(-1) / m_ + 1) {}",
			"",
			"    constexpr u32 mod() const {",
			"        return m;",
			"    }",
			"",
			"    constexpr u32 mul(u32 a, u32 b) const {",
			"        u64 z = a;",
			"        z *= b;",
			"",
			"        u64 x = u64((u128(z) * im) >> 64);",
			"",
			"        u32 v = u32(z - x * m);",
			"        if (m <= v) {",
			"            v += m;",
			"        }",
			"        return v;",
			"    }",
			"",
			"private:",
			"    u32 m;",
			"    u64 im;",
			"};",
			"",
			"using Z = ModInt<mod>;"
		],
		"description": "modInt"
	},
	"ModUint": {
		"scope": "cpp",
		"prefix": "ModUint",
		"body": [
			"template<typename T>",
			"constexpr T power(T a, u64 b) {",
			"    T res{ 1 };",
			"    for (; b != 0; b /= 2, a *= a) {",
			"        if (b % 2 == 1) {",
			"            res *= a;",
			"        }",
			"    }",
			"    return res;",
			"}",
			"",
			"template<u32 P>",
			"constexpr u32 mulMod(u32 a, u32 b) {",
			"    return 1ULL * a * b % P;",
			"}",
			"",
			"template<u64 P>",
			"constexpr u64 mulMod(u64 a, u64 b) {",
			"    u64 res = a * b - u64(1.L * a * b / P - 0.5L) * P;",
			"    res %= P;",
			"    return res;",
			"}",
			"",
			"template<typename U, U P>",
			"    requires std::unsigned_integral<U>",
			"struct ModIntBase {",
			"public:",
			"    constexpr ModIntBase() : x{ 0 } {}",
			"",
			"    template<typename T>",
			"        requires std::integral<T>",
			"    constexpr ModIntBase(T x_) : x{ norm(x_ % T {P}) } {}",
			"",
			"    constexpr static U norm(U x) {",
			"        if ((x >> (8 * sizeof(U) - 1) & 1) == 1) {",
			"            x += P;",
			"        }",
			"        if (x >= P) {",
			"            x -= P;",
			"        }",
			"        return x;",
			"    }",
			"",
			"    constexpr U val() const {",
			"        return x;",
			"    }",
			"",
			"    constexpr ModIntBase operator-() const {",
			"        ModIntBase res;",
			"        res.x = norm(P - x);",
			"        return res;",
			"    }",
			"",
			"    constexpr ModIntBase inv() const {",
			"        return power(*this, P - 2);",
			"    }",
			"",
			"    constexpr ModIntBase& operator*=(const ModIntBase& rhs)& {",
			"        x = mulMod<P>(x, rhs.val());",
			"        return *this;",
			"    }",
			"",
			"    constexpr ModIntBase& operator+=(const ModIntBase& rhs)& {",
			"        x = norm(x + rhs.x);",
			"        return *this;",
			"    }",
			"",
			"    constexpr ModIntBase& operator-=(const ModIntBase& rhs)& {",
			"        x = norm(x - rhs.x);",
			"        return *this;",
			"    }",
			"",
			"    constexpr ModIntBase& operator/=(const ModIntBase& rhs)& {",
			"        return *this *= rhs.inv();",
			"    }",
			"",
			"    friend constexpr ModIntBase operator*(ModIntBase lhs, const ModIntBase& rhs) {",
			"        lhs *= rhs;",
			"        return lhs;",
			"    }",
			"",
			"    friend constexpr ModIntBase operator+(ModIntBase lhs, const ModIntBase& rhs) {",
			"        lhs += rhs;",
			"        return lhs;",
			"    }",
			"",
			"    friend constexpr ModIntBase operator-(ModIntBase lhs, const ModIntBase& rhs) {",
			"        lhs -= rhs;",
			"        return lhs;",
			"    }",
			"",
			"    friend constexpr ModIntBase operator/(ModIntBase lhs, const ModIntBase& rhs) {",
			"        lhs /= rhs;",
			"        return lhs;",
			"    }",
			"",
			"    friend constexpr std::ostream& operator<<(std::ostream& os, const ModIntBase& a) {",
			"        return os << a.val();",
			"    }",
			"",
			"    friend constexpr bool operator==(ModIntBase lhs, ModIntBase rhs) {",
			"        return lhs.val() == rhs.val();",
			"    }",
			"",
			"    friend constexpr bool operator!=(ModIntBase lhs, ModIntBase rhs) {",
			"        return lhs.val() != rhs.val();",
			"    }",
			"",
			"    friend constexpr bool operator<(ModIntBase lhs, ModIntBase rhs) {",
			"        return lhs.val() < rhs.val();",
			"    }",
			"",
			"private:",
			"    U x;",
			"};",
			"",
			"template<u32 P>",
			"using ModInt = ModIntBase<u32, P>;",
			"",
			"template<u64 P>",
			"using ModInt64 = ModIntBase<u64, P>;",
			"",
			"constexpr u32 P = 998244353;",
			"using Z = ModInt<P>;"
		],
		"description": "Mi64"
	},
	"i128": {
		"scope": "cpp",
		"prefix": "i128",
		"body": [
			"using i128 = __int128;",
			"",
			"std::istream& operator>>(std::istream& is, i128& n) {",
			"    std::string s;is >> s;",
			"    n = 0;",
			"    for (char i : s) n = n * 10 + i - '0';",
			"    return is;",
			"}",
			"std::ostream& operator<<(std::ostream& os, i128 n) {",
			"    if (n == 0) {",
			"        return os << 0;",
			"    }",
			"    std::string s;",
			"    while (n) {",
			"        s += '0' + n % 10;",
			"        n /= 10;",
			"    }",
			"    std::reverse(s.begin(), s.end());",
			"    return os << s;",
			"}"
		],
		"description": "i128"
	},
	"division": {
		"scope": "cpp",
		"prefix": "division",
		"body": [
			"i64 ceilDiv(i64 n, i64 m) {",
			"    if (n >= 0) {",
			"        return (n + m - 1) / m;",
			"    } else {",
			"        return n / m;",
			"    }",
			"}",
			" ",
			"i64 floorDiv(i64 n, i64 m) {",
			"    if (n >= 0) {",
			"        return n / m;",
			"    } else {",
			"        return (n - m + 1) / m;",
			"    }",
			"}"
		],
		"description": "c_f_division"
	},
	"chmax": {
		"scope": "cpp",
		"prefix": "chmax",
		"body": [
			"template<class T>",
			"void chmax(T &a, T b) {",
			"    if (a < b) {",
			"        a = b;",
			"    }",
			"}"
		],
		"description": "chmax"
	},
	"shuffle": {
		"scope": "cpp",
		"prefix": "shuffle",
		"body": [
			"mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().std::count());",
			"shuffle(ver.begin(), ver.end(), rng);"
		],
		"description": "Shuffle"
	},
	"bit___builtin_": {
		"scope": "cpp",
		"prefix": "bit___builtin_",
		"body": [
			"__builtin_popcount(x) // 返回x二进制下含1的数量，例如x=15=(1111)时答案为4",
			"",
			"__builtin_ffs(x) // 返回x右数第一个1的位置(1-idx)，1(1) 返回 1，8(1000) 返回 4，26(11010) 返回 2",
			"",
			"__builtin_ctz(x) // 返回x二进制下后导0的个数，1(1) 返回 0，8(1000) 返回 3",
			"",
			"bit_width(x) // 返回x二进制下的位数，9(1001) 返回 4，26(11010) 返回 5"
		],
		"description": "Bit   Builtin "
	},
	"code": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"// to_string函数会直接将你的各种类型的数字转换为字符串。",
			"// string to_string(T val);",
			"double val = 12.12;",
			"std::cout << to_string(val);"
		],
		"description": "Code"
	},
	"code_1": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"// 【不建议使用】itoa允许你将整数转换成任意进制的字符串，参数为待转换整数、目标字符数组、进制。",
			"// char* itoa(int value, char* string, int radix);",
			"char ans[10] = {};",
			"itoa(12, ans, 2);",
			"std::cout << ans << std::endl; /*1100*/",
			"",
			"// 长整型函数名ltoa，最高支持到int型上限2^31。ultoa同理。"
		],
		"description": "Code"
	},
	"code_2": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"// stoi直接使用",
			"cout << stoi(\"12\") << endl;",
			"",
			"// 【不建议使用】stoi转换进制，参数为待转换字符串、起始位置、进制。",
			"// int stoi(string value, int st, int radix);",
			"cout << stoi(\"1010\", 0, 2) << endl; /*10*/",
			"cout << stoi(\"c\", 0, 16) << endl; /*12*/",
			"cout << stoi(\"0x3f3f3f3f\", 0, 0) << endl; /*1061109567*/",
			"",
			"// 长整型函数名stoll，最高支持到long long型上限2^63。stoull、stod、stold同理。"
		],
		"description": "Code"
	},
	"code_3": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"// atoi直接使用，空字符返回0，允许正负符号，数字字符前有其他字符返回0，数字字符前有空白字符自动去除",
			"cout << atoi(\"12\") << endl;",
			"cout << atoi(\"   12\") << endl; /*12*/",
			"cout << atoi(\"-12abc\") << endl; /*-12*/",
			"cout << atoi(\"abc12\") << endl; /*0*/",
			"",
			"// 长整型函数名atoll，最高支持到long long型上限2^63。"
		],
		"description": "Code"
	},
	"xxxxxxxxxx2_1pabc22sumsqrtppapbpccpp": {
		"scope": "cpp",
		"prefix": "xxxxxxxxxx2_1pabc22sumsqrtppapbpccpp",
		"body": [
			"int n;",
			"std::cin >> n;",
			"std::vector<int> a(n);",
			"// iota(a.begin(), a.end(), 1);",
			"for (auto &it : a) std::cin >> it;",
			"std::sort(a.begin(), a.end());",
			"",
			"do {",
			"    for (auto it : a) cout << it << \" \";",
			"    std::cout << std::endl;",
			"} while (next_permutation(a.begin(), a.end()));"
		],
		"description": "Xxxxxxxxxx2 1Pabc22Sumsqrtppapbpccpp"
	},
	"to_string": {
		"scope": "cpp",
		"prefix": "to_string",
		"body": [
			"//将数值num转换为字符串s",
			"std::string s = to_string(num);"
		],
		"description": "To String"
	},
	"is_sorted": {
		"scope": "cpp",
		"prefix": "is_sorted",
		"body": [
			"//a数组[start,end)区间是否是非递减的，返回bool型",
			"std::cout << is_sorted(a + start, a + end);"
		],
		"description": "Is Sorted"
	},
	"accumulate": {
		"scope": "cpp",
		"prefix": "accumulate",
		"body": [
			"//将a数组[start,end)区间的元素进行累加，并输出累加和+x的值",
			"std::cout << std::accumulate(a + start, a + end, x);"
		],
		"description": "Accumulate"
	},
	"iterator": {
		"scope": "cpp",
		"prefix": "iterator",
		"body": [
			"//构建一个UUU容器的正向迭代器，名字叫it",
			"UUU::iterator it;",
			"",
			"std::vector<int>::iterator it; //创建一个正向迭代器，++ 操作时指向下一个",
			"std::vector<int>::reverse_iterator it; //创建一个反向迭代器，++ 操作时指向上一个"
		],
		"description": "Iterator"
	},
	"next_prev": {
		"scope": "cpp",
		"prefix": "next_prev",
		"body": [
			"auto it = s.std::find(x); // 建立一个迭代器",
			"prev(it) / next(it); // 默认返回迭代器it的前/后一个迭代器",
			"prev(it, 2) / next(it, 2); // 可选参数可以控制返回前/后任意个迭代器",
			"",
			"/* 以下是一些应用 */",
			"auto pre = prev(s.std::lower_bound(x)); // 返回第一个<x的迭代器",
			"int ed = *prev(S.end(), 1); // 返回最后一个元素"
		],
		"description": "Next Prev"
	},
	"priority_queue": {
		"scope": "cpp",
		"prefix": "priority_queue",
		"body": [
			"//没有clear函数",
			"std::priority_queue<int, std::vector<int>, greater<int> > p; //重定义为降序（小根堆）",
			"push(x); //向栈顶插入x",
			"top(); //获取栈顶元素",
			"pop(); //弹出栈顶元素"
		],
		"description": "Priority Queue"
	},
	"priority_queue_1": {
		"scope": "cpp",
		"prefix": "priority_queue",
		"body": [
			"//重载运算符【注意，符号相反！！！】",
			"struct Node {",
			"    int x; std::string s;",
			"    friend bool operator < (const Node &a, const Node &b) {",
			"        if (a.x != b.x) return a.x > b.x;",
			"        return a.s > b.s;",
			"    }",
			"};"
		],
		"description": "Priority Queue"
	},
	"bitset": {
		"scope": "cpp",
		"prefix": "bitset",
		"body": [
			"// 如果输入的是01字符串，可以直接使用\">>\"读入",
			"bitset<10> s;",
			"std::cin >> s;",
			"",
			"//使用只含01的字符串构造——bitset<容器长度>B (字符串)",
			"std::string S; std::cin >> S;",
			"bitset<32> B (S);",
			"",
			"//使用整数构造（两种方式）",
			"int x; std::cin >> x;",
			"bitset<32> B1 (x);",
			"bitset<32> B2 = x;",
			"",
			"// 构造时，尖括号里的数字不能是变量",
			"int x; std::cin >> x;",
			"bitset<x> ans; // 错误构造",
			"",
			"[] //随机访问",
			"std::set(x) //将第x位置1，x省略时默认全部位置1",
			"reset(x) //将第x位置0，x省略时默认全部位置0",
			"flip(x) //将第x位取反，x省略时默认全部位取反",
			"to_ullong() //重转换为ULL类型",
			"to_string() //重转换为ULL类型",
			"std::count() //返回1的个数",
			"any() //判断是否至少有一个1",
			"none() //判断是否全为0",
			"",
			"_Find_fisrt() // 找到从低位到高位第一个1的位置",
			"_Find_next(x) // 找到当前位置x的下一个1的位置，复杂度 O(n/w + std::count)",
			"",
			"bitset<23> B1(\"11101001\"), B2(\"11101000\");",
			"cout << (B1 ^ B2) << \"\\n\";  //按位异或",
			"cout << (B1 | B2) << \"\\n\";  //按位或",
			"cout << (B1 & B2) << \"\\n\";  //按位与",
			"cout << (B1 == B2) << \"\\n\"; //比较是否相等",
			"cout << B1 << \" \" << B2 << \"\\n\"; //你可以直接使用cout输出"
		],
		"description": "Bitset"
	},
	"hash_pair": {
		"scope": "cpp",
		"prefix": "hash_pair",
		"body": [
			"struct hash_pair {",
			"    template<typename T1, typename T2>",
			"    size_t operator()(const std::pair<T1, T2> &p) const {",
			"        return hash<T1>()(p.fi) ^ hash<T2>()(p.se);",
			"    }",
			"};",
			"std::unordered_set<std::pair<int, int>, int, hash_pair> S;",
			"std::unordered_map<std::tuple<int, int, int>, int, hash_pair> M;"
		],
		"description": "Hash Pair"
	},
	"fff": {
		"scope": "cpp",
		"prefix": "fff",
		"body": [
			"struct fff {",
			"    std::string x, y;",
			"    int z;",
			"    friend bool operator == (const fff &a, const fff &b) {",
			"        return a.x == b.x || a.y == b.y || a.z == b.z;",
			"    }",
			"};",
			"struct hash_fff {",
			"    size_t operator()(const fff &p) const {",
			"        return hash<std::string>()(p.x) ^ hash<std::string>()(p.y) ^ hash<int>()(p.z);",
			"    }",
			"};",
			"std::unordered_map<fff, int, hash_fff> mp;"
		],
		"description": "Fff"
	},
	"hash_vector": {
		"scope": "cpp",
		"prefix": "hash_vector",
		"body": [
			"struct hash_vector {",
			"    size_t operator()(const std::vector<int> &p) const {",
			"        size_t seed = 0;",
			"        for (auto it : p) {",
			"            seed ^= hash<int>()(it);",
			"        }",
			"        return seed;",
			"    }",
			"};",
			"std::unordered_map<std::vector<int>, int, hash_vector> mp;"
		],
		"description": "Hash Vector"
	},
	"hash": {
		"scope": "cpp",
		"prefix": "hash",
		"body": [
			"namespace std {",
			"    template<> struct hash<std::vector<int>> {",
			"        size_t operator()(const std::vector<int> &p) const {",
			"            size_t seed = 0;",
			"            for (int i : p) {",
			"                seed ^= hash<int>()(i) + 0x9e3779b9 + (seed << 6) + (seed >> 2);",
			"            }",
			"            return seed;",
			"        }",
			"    };",
			"}",
			"std::unordered_set<std::vector<int> > S;"
		],
		"description": "Hash"
	},
	"for": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"for (int i = 1; i <= n; i++)",
			"    for (int j = 0; j <= W; j++){",
			"        dp[i][j] = dp[i - 1][j];",
			"        if (j >= w[i])",
			"            dp[i][j] = std::max(dp[i][j], dp[i - 1][j - w[i]] + v[i]);",
			"    }"
		],
		"description": "For"
	},
	"code_4": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"for (int i = 1; i <= n; i++)  //当前装第 i 件物品",
			"    for (int j = W; j >= w[i]; j--)  //背包容量为 j",
			"        dp[j] = std::max(dp[j], dp[j - w[i]] + v[i]);  //判断背包容量为 j 的情况下能是实现总价值最大是多少"
		],
		"description": "Code"
	},
	"code_5": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"for (int i = 1; i <= n; i++)",
			"    for (int j = 0; j <= W; j++)",
			"        for (int k = 0; k * w[i] <= j; k++)    //选取几个物品",
			"            dp[i][j] = std::max(dp[i][j], dp[i - 1][j - k * w[i]] + k * v[i]);"
		],
		"description": "Code"
	},
	"for_1": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"for (int i = 1; i <= n; i++)",
			"    for (int j = 0; j <= W; j++){",
			"        dp[i][j] = dp[i - 1][j];",
			"        if (j >= w[i])",
			"            dp[i][j] = std::max(dp[i][j], dp[i][j - w[i]] + v[i]);",
			"    }"
		],
		"description": "For"
	},
	"code_6": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"for (int i = 1; i <= n; i++)",
			"    for (int j = w[i]; j <= W; j++)",
			"        dp[j] = std::max(dp[j], dp[j - w[i]] + v[i]);"
		],
		"description": "Code"
	},
	"for_2": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"for (int i = 1; i <= n; i++)",
			"    for (int j = W; j >= 0; j--)",
			"        for (int k = 0; k <= s[i]; k++){",
			"            if (j - k * w[i] < 0) break;",
			"            dp[j] = std::max(dp[j], dp[j - k * w[i]] + k * v[i]);",
			"        }"
		],
		"description": "For"
	},
	"for_3": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"for (int i = 1; i <= n; i++){",
			"    scanf(\"%lld%lld%lld\", &x, &y, &s);  //x 为体积， y 为价值， s 为数量",
			"    t = 1;",
			"    while (s >= t){",
			"        w[++num] = x * t;",
			"        v[num] = y * t;",
			"        s -= t;",
			"        t *= 2;",
			"    }",
			"    w[++num] = x * s;",
			"    v[num] = y * s;",
			"}",
			"for (int i = 1; i <= num; i++)",
			"    for (int j = W; j >= w[i]; j--)",
			"        dp[j] = std::max(dp[j], dp[j - w[i]] + v[i]);"
		],
		"description": "For"
	},
	"std": {
		"scope": "cpp",
		"prefix": "std",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"const int N = 2e5 + 10;",
			"int n, W, w, v, s, f[N], g[N], q[N];",
			"int main(){",
			"    std::ios::std::sync_with_stdio(false);std::cin.std::tie(0);",
			"    std::cin >> n >> W;",
			"    for (int i = 0; i < n; i ++ ){",
			"        std::memcpy ( g, f, sizeof f);",
			"        std::cin >> w >> v >> s;",
			"        for (int j = 0; j < w; j ++ ){",
			"            int head = 0, tail = -1;",
			"            for (int k = j; k <= W; k += w){",
			"                if ( head <= tail && k - s * w > q[head] ) head ++ ;//保证队列长度 <= s",
			"                while ( head <= tail && g[q[tail]] - (q[tail] - j) / w * v <= g[k] - (k - j) / w * v ) tail -- ;//保证队列单调递减",
			"                q[ ++ tail] = k;",
			"                f[k] = g[q[head]] + (k - q[head]) / w * v;",
			"            }",
			"        }",
			"    }",
			"    cout << f[W] << \"\\n\";",
			"    return 0;",
			"}"
		],
		"description": "Std"
	},
	"std_1": {
		"scope": "cpp",
		"prefix": "std",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"int n, W, w, v, s;",
			"int main(){",
			"    std::cin >> n >> W;",
			"    std::vector <int> f(W + 1);",
			"    for (int i = 0; i < n; i ++ ){",
			"        std::cin >> w >> v >> s;",
			"        if (s == -1){",
			"            for (int j = W; j >= w; j -- )",
			"                f[j] = std::max(f[j], f[j - w] + v);",
			"        }",
			"        else if (s == 0){",
			"            for (int j = w; j <= W; j ++ )",
			"                f[j] = std::max(f[j], f[j - w] + v);",
			"        }",
			"        else {",
			"            int t = 1, cnt = 0;",
			"            std::vector <int> x(s + 1), y(s + 1);",
			"            while (s >= t){",
			"                x[++cnt] = w * t;",
			"                y[cnt] = v * t;",
			"                s -= t;",
			"                t *= 2;",
			"            }",
			"            x[++cnt] = w * s;",
			"            y[cnt] = v * s;",
			"            for (int i = 1; i <= cnt; i ++ )",
			"                for (int j = W; j >= x[i]; j -- )",
			"                    f[j] = std::max(f[j], f[j - x[i]] + y[i]);",
			"        }",
			"    }",
			"    cout << f[W] << \"\\n\";",
			"    return 0;",
			"}"
		],
		"description": "Std"
	},
	"code_7": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"for (int i = 1; i <= n; i++)",
			"    for (int j = W; j >= w; j--)  //容量限制",
			"        for (int k = M; k >= m; k--)  //重量限制",
			"            dp[j][k] = std::max(dp[j][k], dp[j - w][k - m] + v);"
		],
		"description": "Code"
	},
	"std_2": {
		"scope": "cpp",
		"prefix": "std",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"const int N = 110;",
			"int n, W, s[N], w[N][N], v[N][N], dp[N];",
			"int main(){",
			"    std::cin >> n >> W;",
			"    for (int i = 1; i <= n; i++){",
			"        scanf(\"%d\", &s[i]);",
			"        for (int j = 1; j <= s[i]; j++)",
			"            scanf(\"%d %d\", &w[i][j], &v[i][j]);",
			"    }",
			"    for (int i = 1; i <= n; i++)",
			"        for (int j = W; j >= 0; j--)",
			"            for (int k = 1; k <= s[i]; k++)",
			"                if (j - w[i][k] >= 0)",
			"                    dp[j] = std::max(dp[j], dp[j - w[i][k]] + v[i][k]);",
			"    cout << dp[W] << \"\\n\";",
			"    return 0;",
			"}"
		],
		"description": "Std"
	},
	"std_3": {
		"scope": "cpp",
		"prefix": "std",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"const int N = 110;",
			"int n, W, w[N], v[N], p, f[N][N], root;",
			"std::vector <int> g[N];",
			"void dfs(int u){",
			"    for (int i = w[u]; i <= W; i ++ )",
			"        f[u][i] = v[u];",
			"    for (auto v : g[u]){",
			"        dfs(v);",
			"        for (int j = W; j >= w[u]; j -- )",
			"            for (int k = 0; k <= j - w[u]; k ++ )",
			"                f[u][j] = std::max(f[u][j], f[u][j - k] + f[v][k]);",
			"    }",
			"}",
			"int main(){",
			"    std::cin >> n >> W;",
			"    for (int i = 1; i <= n; i ++ ){",
			"        std::cin >> w[i] >> v[i] >> p;",
			"        if (p == -1) root = i;",
			"        else g[p].push_back(i);",
			"    }",
			"    dfs(root);",
			"    cout << f[root][W] << \"\\n\";",
			"    return 0;",
			"}"
		],
		"description": "Std"
	},
	"std_4": {
		"scope": "cpp",
		"prefix": "std",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define LL long long",
			"const int mod = 1e9 + 7, N = 1010;",
			"LL n, W, cnt[N], f[N], w, v;",
			"int main(){",
			"    std::cin >> n >> W;",
			"    for (int i = 0; i <= W; i ++ )",
			"        cnt[i] = 1;",
			"    for (int i = 0; i < n; i ++ ){",
			"        std::cin >> w >> v;",
			"        for (int j = W; j >= w; j -- )",
			"            if (f[j] < f[j - w] + v){",
			"                f[j] = f[j - w] + v;",
			"                cnt[j] = cnt[j - w];",
			"            }",
			"            else if (f[j] == f[j - w] + v){",
			"                cnt[j] = (cnt[j] + cnt[j - w]) % mod;",
			"            }",
			"    }",
			"    cout << cnt[W] << \"\\n\";",
			"    return 0;",
			"}"
		],
		"description": "Std"
	},
	"for_4": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"for (int i = n; i >= 1; i--)",
			"    for (int j = 0; j <= W; j++){",
			"        dp[i][j] = dp[i + 1][j];",
			"        if (j >= w[i])",
			"            dp[i][j] = std::max(dp[i][j], dp[i + 1][j - w[i]] + v[i]);",
			"    }"
		],
		"description": "For"
	},
	"if": {
		"scope": "cpp",
		"prefix": "if",
		"body": [
			"for (int i = 1; i <= n; i++)",
			"    if (W - w[i] >= 0 && dp[i][W] == dp[i + 1][W - w[i]] + v[i]){",
			"        cout << i << \" \";",
			"        W -= w[i];",
			"    }"
		],
		"description": "If"
	},
	"dfs": {
		"scope": "cpp",
		"prefix": "dfs",
		"body": [
			"/* pos 表示当前枚举到第几位",
			"sum 表示 d 出现的次数",
			"limit 为 1 表示枚举的数字有限制",
			"zero 为 1 表示有前导 0",
			"d 表示要计算出现次数的数 */",
			"const int N = 15;",
			"LL dp[N][N];",
			"int num[N];",
			"LL dfs(int pos, LL sum, int limit, int zero, int d) {",
			"    if (pos == 0) return sum;",
			"    if (!limit && !zero && dp[pos][sum] != -1) return dp[pos][sum];",
			"    LL ans = 0;",
			"    int up = (limit ? num[pos] : 9);",
			"    for (int i = 0; i <= up; i++) {",
			"        ans += dfs(pos - 1, sum + ((!zero || i) && (i == d)), limit && (i == num[pos]),",
			"                   zero && (i == 0), d);",
			"    }",
			"    if (!limit && !zero) dp[pos][sum] = ans;",
			"    return ans;",
			"}",
			"LL solve(LL x, int d) {",
			"    std::memset(dp, -1, sizeof dp);",
			"    int len = 0;",
			"    while (x) {",
			"        num[++len] = x % 10;",
			"        x /= 10;",
			"    }",
			"    return dfs(len, 0, 1, 1, d);",
			"}"
		],
		"description": "Dfs"
	},
	"std_5": {
		"scope": "cpp",
		"prefix": "std",
		"body": [
			"#include<bits/stdc++.h>",
			"#define int long long",
			"using namespace std;",
			"constexpr int MAXN = 24 + 10;",
			"int a[MAXN], mod, f[MAXN][MAXN * 10][MAXN * 10];",
			"",
			"int dfs(int pos, int sum, int cur, bool lead0, bool lim) {",
			"    if (!pos)return !lead0 && sum == mod && cur == 0;",
			"    int& now = f[pos][cur][sum];",
			"    if (!lead0 && !lim && ~now)return now;",
			"    int up = lim ? a[pos] : 9, res = 0;",
			"    for (int i = 0;i <= up;++i)",
			"        res += dfs(pos - 1, sum + i, (cur * 10 + i) % mod, lead0 && !i, lim && i == up);",
			"    if (!lead0 && !lim)now = res;",
			"    return res;",
			"}",
			"",
			"signed main() {",
			"    std::ios::std::sync_with_stdio(false);",
			"    std::cin.std::tie(0), std::cout.std::tie(0);",
			"    int n;std::cin >> n;",
			"    int len = 0;",
			"    while (n)a[++len] = n % 10, n /= 10;",
			"    int res = 0;",
			"    for (int i = 1;i <= len * 9;++i) {",
			"        mod = i;std::memset(f, -1, sizeof f);",
			"        res += dfs(len, 0, 0, 1, 1);",
			"    }",
			"    std::cout << res;",
			"    return 0;",
			"}"
		],
		"description": "Std"
	},
	"std_6": {
		"scope": "cpp",
		"prefix": "std",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define LL long long",
			"const int N = 15, M = 150, K = 1500;",
			"LL n, k;",
			"LL cnt[K];    //每个状态的二进制中 1 的数量",
			"LL tot;    //合法状态的数量",
			"LL st[K];    //合法的状态",
			"LL dp[N][M][K];    //第 i 行，放置了 j 个国王，状态为 k 的方案数",
			"int main(){",
			"    std::ios::std::sync_with_stdio(false);std::cin.std::tie(0);",
			"    std::cin >> n >> k;",
			"    for (int s = 0; s < (1 << n); s ++ ){  //找出合法状态",
			"        LL sum = 0, t = s;",
			"        while(t){  //计算 1 的数量",
			"            sum += (t & 1);",
			"            t >>= 1;",
			"        }",
			"        cnt[s] = sum;",
			"        if ( (( (s << 1) | (s >> 1) ) & s) == 0 ){  //判断合法性",
			"            st[ ++ tot] = s;",
			"        }",
			"    }",
			"    dp[0][0][0] = 1;",
			"    for (int i = 1; i <= n + 1; i ++ ){",
			"        for (int j1 = 1; j1 <= tot; j1 ++ ){    //当前的状态",
			"            LL s1 = st[j1];",
			"            for (int j2 = 1; j2 <= tot; j2 ++ ){    //上一行的状态",
			"                LL s2 = st[j2];",
			"                if ( ( (s2 | (s2 << 1) | (s2 >> 1)) & s1 ) == 0 ){",
			"                    for (int j = 0; j <= k; j ++ ){",
			"                        if (j - cnt[s1] >= 0)",
			"                            dp[i][j][s1] += dp[i - 1][j - cnt[s1]][s2];",
			"                    }",
			"                }",
			"            }",
			"        }",
			"    }",
			"    cout << dp[n + 1][k][0] << \"\\n\";",
			"    return 0;",
			"}"
		],
		"description": "Std"
	},
	"std_7": {
		"scope": "cpp",
		"prefix": "std",
		"body": [
			"using namespace std;",
			"",
			"const int N = 20,M = 1 << N;",
			"",
			"int n;",
			"int w[N][N];",
			"int f[M][N];//第一维表示是否访问到该点的压缩状态，第二维是走到点j",
			"            //f[i][j]表示状态为i并且到j的最短路径",
			"",
			"int main(){",
			"    std::cin>>n;",
			"    for (int i = 0; i < n; i ++ )",
			"        for (int j = 0; j < n; j ++ )//读入i到j的距离",
			"            std::cin>>w[i][j];",
			"    std::memset(f, 0x3f, sizeof f);",
			"    f[1][0]=0;",
			"    for (int i = 0; i < 1 << n; i ++ )//枚举压缩的状态",
			"        for (int j = 0; j < n; j ++ )//枚举到0~j的点",
			"            if(i >> j & 1)//该状态存在j点",
			"                for (int k = 0; k < n; k ++ )//枚举从j倒数第二个点k",
			"                    if(i >> k & 1)//倒数点k存在",
			"                        f[i][j]=std::min(f[i][j],f[i-(1<<j)][k]+w[k][j]);//状态转移方程，在f[i][j]和状态去掉j的点f[i-(i<<j)][k]+w[k][j]取最小值",
			"    std::cout<<f[(1<<n)-1][n-1]<<std::endl;//输出状态全满也就是所有点都经过且到最后一个点的最短距离",
			"    return 0;",
			"}"
		],
		"description": "Std"
	},
	"code_8": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"f[i][j]=std::min(f[i][j],f[i-(1<<j)][k]+w[k][j]);"
		],
		"description": "Code"
	},
	"std_8": {
		"scope": "cpp",
		"prefix": "std",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define LL long long",
			"const int mod = 1e9 + 7;",
			"char c, s[20] = \"!helloworld\";",
			"LL dp[20];",
			"int main(){",
			"    dp[0] = 1;",
			"    while ((c = getchar()) != EOF)",
			"        for (int i = 10; i >= 1; i--)",
			"            if (c == s[i] || c == s[i] - 32)",
			"                dp[i] = (dp[i] + dp[i - 1]) % mod;",
			"    cout << dp[10] << \"\\n\";",
			"    return 0;",
			"}"
		],
		"description": "Std"
	},
	"std_9": {
		"scope": "cpp",
		"prefix": "std",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"const int maxn = 1e6 + 10;",
			"std::string s;",
			"int len, dp[maxn], ans, id;",
			"int main(){",
			"    std::cin >> s;",
			"    len = s.length();",
			"    for (int i = 1; i < len; i++){",
			"        if ((s[i] == ')' && s[i - 1 - dp[i - 1]] == '(' ) || (s[i] == ']' && s[i - 1 - dp[i - 1]] == '[')){",
			"            dp[i] = dp[i - 1] + 2 + dp[i - 2 - dp[i - 1]];",
			"            if (dp[i] > ans) {",
			"                ans = dp[i];  //记录长度",
			"                id = i;  //记录位置",
			"            }",
			"        }",
			"    }",
			"    for (int i = id - ans + 1; i <= id; i++)",
			"        std::cout << s[i];",
			"    cout << \"\\n\";",
			"    return 0;",
			"}"
		],
		"description": "Std"
	},
	"dfs_1": {
		"scope": "cpp",
		"prefix": "dfs",
		"body": [
			"int T,n,m,len,a[20];//a数组用于判断每一位能取到的最大值",
			"ll l,r,dp[20][15];",
			"ll dfs(int pos,int pre,int limit){//记搜",
			"    //pos搜到的位置，pre前一位数",
			"    //limit判断是否有最高位限制",
			"    if(pos>len) return 1;//剪枝",
			"    if(dp[pos][pre]!=-1 && !limit) return dp[pos][pre];//记录当前值",
			"    ll ret=0;//暂时记录当前方案数",
			"    int res=limit?a[len-pos+1]:9;//res当前位能取到的最大值",
			"    for(int i=0;i<=res;i++)",
			"        if(!(i==4 || (pre==6 && i==2)))",
			"            ret+=dfs(pos+1,i,i==res&&limit);",
			"    if(!limit) dp[pos][pre]=ret;//当前状态方案数记录",
			"    return ret;",
			"}",
			"ll part(ll x){//把数按位拆分",
			"    len=0;",
			"    while(x) a[++len]=x%10,x/=10;",
			"    std::memset(dp,-1,sizeof dp);//初始化-1（因为有可能某些情况下的方案数是0）",
			"    return dfs(1,0,1);//进入记搜",
			"}",
			"int main(){",
			"    std::cin>>n;",
			"    while(n--){",
			"        std::cin>>l>>r;",
			"        if(l==0 && r==0)break;",
			"        if(l) printf(\"%lld\\n\",part(r)-part(l-1));//[l,r](l!=0)",
			"        else printf(\"%lld\\n\",part(r)-part(l));//从0开始要特判",
			"    }",
			"}"
		],
		"description": "Dfs"
	},
	"sosdp": {
		"scope": "cpp",
		"prefix": "sosdp",
		"body": [
			"for(int j = 0; j < n; j++)",
			"    for(int i = 0; i < 1 << n; i++)",
			"        if(i >> j & 1) f[i] += f[i ^ (1 << j)];"
		],
		"description": "Sosdp"
	},
	"sosdp_1": {
		"scope": "cpp",
		"prefix": "sosdp",
		"body": [
			"for(int j = 0; j < n; j++)",
			"    for(int i = (1 << n) - 1; i >= 0 ; i--)",
			"        if(!(i >> j & 1)) f[i] += f[i ^ (1 << j)]"
		],
		"description": "Sosdp"
	},
	"code_9": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"for (int i = 0; (1<<i)-1 <= n; i++) {",
			"    for (int x = (1<<i)-1, t; x <= n; t = x+(x&-x), x = x ? (t|((((t&-t)/(x&-x))>>1)-1)) : (n+1)) {",
			"        // todo",
			"    }",
			"}"
		],
		"description": "Code"
	},
	"sg": {
		"scope": "cpp",
		"prefix": "sg",
		"body": [
			"int n, m, a[N], num[N];",
			"int sg(int x) {",
			"    if (num[x] != -1) return num[x];",
			"",
			"    std::unordered_set<int> S;",
			"    for (int i = 1; i <= m; ++ i)",
			"        if(x >= a[i])",
			"            S.insert(sg(x - a[i]));",
			"",
			"    for (int i = 0; ; ++ i)",
			"        if (S.std::count(i) == 0)",
			"            return num[x] = i;",
			"}",
			"void Solve() {",
			"    std::cin >> m;",
			"    for (int i = 1; i <= m; ++ i) std::cin >> a[i];",
			"    std::cin >> n;",
			"",
			"    int ans = 0; std::memset(num, -1, sizeof num);",
			"    for (int i = 1; i <= n; ++ i) {",
			"        int x; std::cin >> x;",
			"        ans ^= sg(x);",
			"    }",
			"",
			"    if (ans == 0) no;",
			"    else yes;",
			"}"
		],
		"description": "Sg"
	},
	"code_10": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"const double lorry = (std::sqrt(5.0) + 1.0) / 2.0;",
			"//const double lorry = 1.618033988749894848204586834;",
			"void Solve() {",
			"    int n, m; std::cin >> n >> m;",
			"    if (n < m) std::swap(n, m);",
			"    double x = n - m;",
			"    if ((int)(lorry * x) == m) cout << \"lose\\n\";",
			"    else cout << \"win\\n\";",
			"}"
		],
		"description": "Code"
	},
	"force": {
		"scope": "cpp",
		"prefix": "force",
		"body": [
			"int fib[100] = {1, 2};",
			"std::map<int, bool> mp;",
			"void Force() {",
			"  for (int i = 2; i <= 86; ++ i) fib[i] = fib[i - 1] + fib[i - 2];",
			"    for (int i = 0; i <= 86; ++ i) mp[fib[i]] = 1;",
			"}",
			"void Solve() {",
			"    int n; std::cin >> n;",
			"    if (mp[n] == 1) cout << \"lose\\n\";",
			"    else cout << \"win\\n\";",
			"}"
		],
		"description": "Force"
	},
	"for_5": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"auto dfs = [&](auto self, int x, int fa) -> int {",
			"    int x = 0;",
			"    for (auto y : ver[x]) {",
			"        if (y == fa) continue;",
			"        x ^= self(self, y, x);",
			"    }",
			"    return x + 1;",
			"};",
			"cout << (dfs(dfs, 1, 0) == 1 ? \"Bob\\n\" : \"Alice\\n\");"
		],
		"description": "For"
	},
	"mypow": {
		"scope": "cpp",
		"prefix": "mypow",
		"body": [
			"int mypow(int n, int k, int p = MOD) { // 复杂度是 std::log N",
			"    int r = 1;",
			"    for (; k; k >>= 1, n = n * n % p) {",
			"        if (k & 1) r = r * n % p;",
			"    }",
			"    return r;",
			"}",
			"i64 mysqrt(i64 n) { // 针对 std::sqrt 无法精确计算 ll 型",
			"    i64 ans = std::sqrt(n);",
			"    while ((ans + 1) * (ans + 1) <= n) ans++;",
			"    while (ans * ans > n) ans--;",
			"    return ans;",
			"}",
			"int mylcm(int x, int y) {",
			"    return x / std::gcd(x, y) * y;",
			"}"
		],
		"description": "Mypow"
	},
	"log2floor": {
		"scope": "cpp",
		"prefix": "log2floor",
		"body": [
			"template<typename T> int log2floor(T n) { // 针对 log2 无法精确计算 ll 型；向下取整",
			"    assert(n > 0);",
			"    for (T i = 0, chk = 1;; i++, chk *= 2) {",
			"        if (chk <= n && n < chk * 2) {",
			"            return i;",
			"        }",
			"    }",
			"}",
			"template<typename T> int log2ceil(T n) { // 向上取整",
			"    assert(n > 0);",
			"    for (T i = 0, chk = 1;; i++, chk *= 2) {",
			"        if (n <= chk) {",
			"            return i;",
			"        }",
			"    }",
			"}",
			"int log2floor(int x) {",
			"    return 31 - __builtin_clz(x);",
			"}",
			"int log2ceil(int x) { // 向上取整",
			"    return log2floor(x) + (__builtin_popcount(x) != 1);",
			"}"
		],
		"description": "Log2Floor"
	},
	"sign": {
		"scope": "cpp",
		"prefix": "sign",
		"body": [
			"template<typename T> T sign(const T &a) {",
			"    return a == 0 ? 0 : (a < 0 ? -1 : 1);",
			"}",
			"template<typename T> T std::floor(const T &a, const T &b) { // 注意大数据计算时会丢失精度",
			"    T A = std::abs(a), B = std::abs(b);",
			"    assert(B != 0);",
			"    return sign(a) * sign(b) > 0 ? A / B : -(A + B - 1) / B;",
			"}",
			"template<typename T> T std::ceil(const T &a, const T &b) { // 注意大数据计算时会丢失精度",
			"    T A = std::abs(a), B = std::abs(b);",
			"    assert(b != 0);",
			"    return sign(a) * sign(b) > 0 ? (A + B - 1) / B : -A / B;",
			"}"
		],
		"description": "Sign"
	},
	"mygcd": {
		"scope": "cpp",
		"prefix": "mygcd",
		"body": [
			"inline int mygcd(int a, int b) { return b ? std::gcd(b, a % b) : a; }"
		],
		"description": "Mygcd"
	},
	"gcd": {
		"scope": "cpp",
		"prefix": "gcd",
		"body": [
			"LL std::gcd(LL a, LL b) { // 卡常 std::gcd！！",
			"    #define tz __builtin_ctzll",
			"    if (!a || !b) return a | b;",
			"    int t = tz(a | b);",
			"    a >>= tz(a);",
			"    while (b) {",
			"        b >>= tz(b);",
			"        if (a > b) std::swap(a, b);",
			"        b -= a;",
			"    }",
			"    return a << t;",
			"    #undef tz",
			"}"
		],
		"description": "Gcd"
	},
	"while": {
		"scope": "cpp",
		"prefix": "while",
		"body": [
			"auto l = l, r = r;",
			"auto check = [&](auto x)->bool {",
			"",
			"    };",
			"while (l < r) {",
			"    auto mid = l + r >> 1;",
			"    if (check(mid))r = mid;",
			"    else l = mid + 1;",
			"}"
		],
		"description": "While"
	},
	"while_1": {
		"scope": "cpp",
		"prefix": "while",
		"body": [
			"while (l < r) {",
			"    int mid = (l + r) / 2;",
			"    if (a[mid] >= x) {",
			"        r = mid;",
			"    } else {",
			"        l = mid + 1;",
			"    }",
			"}",
			"return a[l];"
		],
		"description": "While"
	},
	"while_2": {
		"scope": "cpp",
		"prefix": "while",
		"body": [
			"while (l < r) {",
			"    int mid = (l + r + 1) / 2;",
			"    if (a[mid] <= x) {",
			"        l = mid;",
			"    } else {",
			"        r = mid - 1;",
			"    }",
			"}",
			"return a[l];"
		],
		"description": "While"
	},
	"while_3": {
		"scope": "cpp",
		"prefix": "while",
		"body": [
			"int l = 0, r = 1E8, ans = r;",
			"while (l <= r) {",
			"    int mid = (l + r) / 2;",
			"    if (judge(mid)) {",
			"        r = mid - 1;",
			"        ans = mid;",
			"    } else {",
			"        l = mid + 1;",
			"    }",
			"}",
			"return ans;"
		],
		"description": "While"
	},
	"while_4": {
		"scope": "cpp",
		"prefix": "while",
		"body": [
			"int l = 0, r = 1E8, ans = l;",
			"while (l <= r) {",
			"    int mid = (l + r) / 2;",
			"    if (judge(mid)) {",
			"        l = mid + 1;",
			"        ans = mid;",
			"    } else {",
			"        r = mid - 1;",
			"    }",
			"}",
			"return ans;"
		],
		"description": "While"
	},
	"cal": {
		"scope": "cpp",
		"prefix": "cal",
		"body": [
			"int cal(auto x) {",
			"    // todo",
			"}",
			"",
			"void solve(int ql, int qr, int l, int r) {",
			"    if (ql > qr)return;",
			"    if (l > r)return;",
			"    if (l == r) {",
			"        for (int q = ql;q <= qr;++q)ans[q] = l;",
			"        return;",
			"    }",
			"    int mid = l + r + 1 >> 1;",
			"    int cnt = cal(mid);",
			"    solve(std::max(ql, cnt + 1), qr, l, mid - 1);",
			"    solve(ql, std::min(qr, cnt), mid, r);",
			"}",
			"",
			"void solve() {",
			"    //input",
			"    solve(ql, qr, 0, n, zf);",
			"    //todo",
			"}"
		],
		"description": "Cal"
	},
	"for_6": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"for (int t = 1; t <= 100; t++) {",
			"    ld mid = (l + r) / 2;",
			"    if (judge(mid)) r = mid;",
			"    else l = mid;",
			"}",
			"std::cout << l << std::endl;"
		],
		"description": "For"
	},
	"while_5": {
		"scope": "cpp",
		"prefix": "while",
		"body": [
			"while (l < r) {",
			"    int mid = (l + r) / 2;",
			"    if (check(mid) <= check(mid + 1)) r = mid;",
			"    else l = mid + 1;",
			"}",
			"std::cout << check(l) << std::endl;"
		],
		"description": "While"
	},
	"for_7": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"ld l = -1E9, r = 1E9;",
			"for (int t = 1; t <= 100; t++) {",
			"    ld mid1 = (l * 2 + r) / 3;",
			"    ld mid2 = (l + r * 2) / 3;",
			"    if (judge(mid1) < judge(mid2)) {",
			"        r = mid2;",
			"    } else {",
			"        l = mid1;",
			"    }",
			"}",
			"std::cout << l << std::endl;"
		],
		"description": "For"
	},
	"mergesort": {
		"scope": "cpp",
		"prefix": "mergesort",
		"body": [
			"LL a[N], tmp[N], n, ans = 0;",
			"void mergeSort(LL l, LL r){",
			"    if (l >= r) return;",
			"    LL mid = (l + r) >> 1, i = l, j = mid + 1, cnt = 0;",
			"    mergeSort(l, mid);",
			"    mergeSort(mid + 1, r);",
			"    while (i <= mid || j <= r)",
			"        if (j > r || (i <= mid && a[i] <= a[j]))",
			"            tmp[cnt++] = a[i++];",
			"        else",
			"            tmp[cnt++] = a[j++], ans += mid - i + 1;",
			"    for (LL k = 0; k < r - l + 1; k++)",
			"        a[l + k] = tmp[k];",
			"}",
			"int main(){",
			"    std::cin >> n;",
			"    for (int i = 1; i <= n; i++)",
			"        scanf(\"%lld\", &a[i]);",
			"    mergeSort(1, n);",
			"    cout << ans << \"\\n\";",
			"    return 0;",
			"}"
		],
		"description": "Mergesort"
	},
	"code_11": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"signed main() {",
			"    int n;",
			"    std::cin >> n;",
			"    std::vector<int> in(n + 1);",
			"    for (int i = 1; i <= n; i++) {",
			"        std::cin >> in[i];",
			"    }",
			"    ",
			"    int q;",
			"    std::cin >> q;",
			"    std::vector<std::array<int, 3>> query;",
			"    for (int i = 0; i < q; i++) {",
			"        int l, r;",
			"        std::cin >> l >> r;",
			"        query.push_back({r, l, i});",
			"    }",
			"    std::sort(query.begin(), query.end());",
			"    ",
			"    std::vector<std::pair<int, int>> ans;",
			"    std::map<int, int> pre;",
			"    int st = 1;",
			"    BIT bit(n);",
			"    for (auto [r, l, id] : query) {",
			"        for (int i = st; i <= r; i++, st++) {",
			"            if (pre.std::count(in[i])) { // 消除此前操作的影响",
			"                bit.add(pre[in[i]], -1);",
			"            }",
			"            bit.add(i, 1);",
			"            pre[in[i]] = i; // 更新操作",
			"        }",
			"        ans.push_back({id, bit.ask(r) - bit.ask(l - 1)});",
			"    }",
			"    ",
			"    std::sort(ans.begin(), ans.end());",
			"    for (auto [id, w] : ans) {",
			"        std::cout << w << std::endl;",
			"    }",
			"}"
		],
		"description": "Code"
	},
	"for_8": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"int n, k; std::cin >> n >> k;",
			"std::vector<int> in(n), now(n);",
			"for (auto &it : in) { std::cin >> it; }",
			"auto dfs = [&](auto self, int k, int bit, int idx) -> void {",
			"    for (int i = idx; i < n; i++) {",
			"        now[bit] = in[i];",
			"        if (bit < k - 1) { self(self, k, bit + 1, i + 1); }",
			"        if (bit == k - 1) {",
			"            int add = 0;",
			"            for (int j = 0; j < k; j++) {",
			"                add += now[j];",
			"            }",
			"            std::cout << add << std::endl;",
			"        }",
			"    }",
			"};",
			"dfs(dfs, k, 0, 0);"
		],
		"description": "For"
	},
	"for_9": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"int n, k; std::cin >> n >> k;",
			"std::vector<int> in(n);",
			"for (auto &it : in) { std::cin >> it; }",
			"int comb = (1 << k) - 1, U = 1 << n;",
			"while (comb < U) {",
			"    int add = 0;",
			"    for (int i = 0; i < n; i++) {",
			"        if (1 << i & comb) {",
			"            add += in[i];",
			"        }",
			"    }",
			"    cout << add << \"\\n\";",
			"    ",
			"    int x = comb & -comb;",
			"    int y = comb + x;",
			"    int z = comb & ~y;",
			"    comb = (z / x >> 1) | y;",
			"}"
		],
		"description": "For"
	},
	"card": {
		"scope": "cpp",
		"prefix": "card",
		"body": [
			"struct card {",
			"      int suit, rank;",
			"      friend bool operator < (const card &a, const card &b) {",
			"        return a.rank < b.rank;",
			"    }",
			"    friend bool operator == (const card &a, const card &b) {",
			"        return a.rank == b.rank;",
			"    }",
			"    friend bool operator != (const card &a, const card &b) {",
			"        return a.rank != b.rank;",
			"    }",
			"    friend auto &operator>> (istream &it, card &C) {",
			"        std::string S, T; it >> S;",
			"        T = \"__23456789TJQKA\"; //点数",
			"        FOR (i, 0, T.sz - 1) {",
			"            if (T[i] == S[0]) C.rank = i;",
			"        }",
			"        T = \"_SHCD\"; //花色",
			"        FOR (i, 0, T.sz - 1) {",
			"            if (T[i] == S[1]) C.suit = i;",
			"        }",
			"        return it;",
			"    }",
			"};",
			"struct game {",
			"    int level;",
			"    std::vector<card> peo;",
			"    int a, b, c, d, e;",
			"    int u, v, w, x, y;",
			"    bool Rk10() { //Rk10: Royal Flush，五张牌同花色，且点数为AKQJT（14,13,12,11,10）",
			"        std::sort(ALL(peo));",
			"        std::reverse(ALL(peo));",
			"        a = peo[0].rank, b = peo[1].rank, c = peo[2].rank, d = peo[3].rank, e = peo[4].rank;",
			"        u = peo[0].suit, v = peo[1].suit, w = peo[2].suit, x = peo[3].suit, y = peo[4].suit;",
			"        ",
			"        if (u != v || v != w || w != x || x != y) return 0;",
			"        if (a == 14 && b == 13 && c == 12 && d == 11 && e == 10) return 1;",
			"        return 0;",
			"    }",
			"    bool Dif(std::vector<card> &peo) { //专门用于检查A2345这种顺子的情况（这是最小的顺子）",
			"        a = peo[0].rank, b = peo[1].rank, c = peo[2].rank, d = peo[3].rank, e = peo[4].rank;",
			"        u = peo[0].suit, v = peo[1].suit, w = peo[2].suit, x = peo[3].suit, y = peo[4].suit;",
			"        ",
			"        if (a != 14 || b != 5 || c != 4 || d != 3 || e != 2) return 0;",
			"        std::vector<card> peo2 = {peo[1], peo[2], peo[3], peo[4], peo[0]}; //重新排序",
			"        peo = peo2;",
			"        return 1;",
			"    }",
			"    bool Rk9() { //Rk9: Straight Flush，五张牌同花色，且顺连【r1 > r2 > r3 > r4 > r5】",
			"        std::sort(ALL(peo));",
			"        std::reverse(ALL(peo));",
			"        a = peo[0].rank, b = peo[1].rank, c = peo[2].rank, d = peo[3].rank, e = peo[4].rank;",
			"        u = peo[0].suit, v = peo[1].suit, w = peo[2].suit, x = peo[3].suit, y = peo[4].suit;",
			"        ",
			"        if (u != v || v != w || w != x || x != y) return 0;",
			"        if (Dif(peo)) return 1; //特判：A2345",
			"        if (a == b + 1 && b == c + 1 && c == d + 1 && d == e + 1) return 1;",
			"        return 0;",
			"    }",
			"    bool Rk8() { //Rk8: Four of a Kind，四张牌点数一样【r1 = r2 = r3 = r4】",
			"        std::sort(ALL(peo));",
			"        a = peo[0].rank, b = peo[1].rank, c = peo[2].rank, d = peo[3].rank, e = peo[4].rank;",
			"        u = peo[0].suit, v = peo[1].suit, w = peo[2].suit, x = peo[3].suit, y = peo[4].suit;",
			"        ",
			"        if (a == b && b == c && c == d) return 1;",
			"        if (b == c && c == d && d == e) {",
			"            std::reverse(ALL(peo));",
			"            return 1;",
			"        }",
			"        return 0;",
			"    }",
			"    bool Rk7() { //Rk7: Fullhouse，三张牌点数一样，另外两张点数也一样【r1 = r2 = r3，r4 = r5】",
			"        std::sort(ALL(peo));",
			"        a = peo[0].rank, b = peo[1].rank, c = peo[2].rank, d = peo[3].rank, e = peo[4].rank;",
			"        u = peo[0].suit, v = peo[1].suit, w = peo[2].suit, x = peo[3].suit, y = peo[4].suit;",
			"        ",
			"        if (a == b && b == c && d == e) return 1;",
			"        if (a == b && c == d && d == e) {",
			"            std::reverse(ALL(peo));",
			"            return 1;",
			"        }",
			"        return 0;",
			"    }",
			"    bool Rk6() { //Rk6: Flush，五张牌同花色【r1 > r2 > r3 > r4 > r5】",
			"        std::sort(ALL(peo));",
			"        std::reverse(ALL(peo));",
			"        a = peo[0].rank, b = peo[1].rank, c = peo[2].rank, d = peo[3].rank, e = peo[4].rank;",
			"        u = peo[0].suit, v = peo[1].suit, w = peo[2].suit, x = peo[3].suit, y = peo[4].suit;",
			"        ",
			"        if (u != v || v != w || w != x || x != y) return 0;",
			"        return 1;",
			"    }",
			"    bool Rk5() { //Rk5: Straight，五张牌顺连【r1 > r2 > r3 > r4 > r5】",
			"        std::sort(ALL(peo));",
			"        std::reverse(ALL(peo));",
			"        a = peo[0].rank, b = peo[1].rank, c = peo[2].rank, d = peo[3].rank, e = peo[4].rank;",
			"        u = peo[0].suit, v = peo[1].suit, w = peo[2].suit, x = peo[3].suit, y = peo[4].suit;",
			"        ",
			"        if (Dif(peo)) return 1; //特判：A2345",
			"        if (a == b + 1 && b == c + 1 && c == d + 1 && d == e + 1) return 1;",
			"        return 0;",
			"    }",
			"    bool Rk4() { //Rk4: Three of a kind，三张牌点数一样【r1 = r2 = r3，r4 > r5】",
			"        std::sort(ALL(peo));",
			"        std::reverse(ALL(peo));",
			"        a = peo[0].rank, b = peo[1].rank, c = peo[2].rank, d = peo[3].rank, e = peo[4].rank;",
			"        u = peo[0].suit, v = peo[1].suit, w = peo[2].suit, x = peo[3].suit, y = peo[4].suit;",
			"        ",
			"        if (a == b && b == c) return 1;",
			"        if (b == c && c == d) {",
			"            std::swap(peo[3], peo[0]);",
			"            return 1;",
			"        }",
			"        if (c == d && d == e) {",
			"            std::swap(peo[3], peo[0]);",
			"            std::swap(peo[4], peo[1]);",
			"            return 1;",
			"        }",
			"        return 0;",
			"    }",
			"    bool Rk3() { //Rk3: Two Pairs，两张牌点数一样，另外有两张点数也一样（两个对子）【r1 = r2 > r3 = r4】",
			"        std::sort(ALL(peo));",
			"        std::reverse(ALL(peo));",
			"        a = peo[0].rank, b = peo[1].rank, c = peo[2].rank, d = peo[3].rank, e = peo[4].rank;",
			"        u = peo[0].suit, v = peo[1].suit, w = peo[2].suit, x = peo[3].suit, y = peo[4].suit;",
			"        ",
			"        if (a == b && c == d) return 1;",
			"        if (a == b && d == e) {",
			"            std::swap(peo[2], peo[4]);",
			"            return 1;",
			"        }",
			"        if (b == c && d == e) {",
			"            std::swap(peo[0], peo[2]);",
			"            std::swap(peo[2], peo[4]);",
			"            return 1;",
			"        }",
			"        return 0;",
			"    }",
			"    bool Rk2() { //Rk2: One Pairs，两张牌点数一样（一个对子）【r1 = r2，r3 > r4 > r5】",
			"        std::sort(ALL(peo));",
			"        std::reverse(ALL(peo));",
			"        a = peo[0].rank, b = peo[1].rank, c = peo[2].rank, d = peo[3].rank, e = peo[4].rank;",
			"        u = peo[0].suit, v = peo[1].suit, w = peo[2].suit, x = peo[3].suit, y = peo[4].suit;",
			"        ",
			"        std::vector<card> peo2;",
			"        if (a == b) return 1;",
			"        if (b == c) {",
			"            peo2 = {peo[1], peo[2], peo[0], peo[3], peo[4]};",
			"            peo = peo2;",
			"            return 1;",
			"        }",
			"        if (c == d) {",
			"            peo2 = {peo[2], peo[3], peo[0], peo[1], peo[4]};",
			"            peo = peo2;",
			"            return 1;",
			"        }",
			"        if (d == e) {",
			"            peo2 = {peo[3], peo[4], peo[0], peo[1], peo[2]};",
			"            peo = peo2;",
			"            return 1;",
			"        }",
			"        return 0;",
			"    }",
			"    bool Rk1() { //Rk1: high card",
			"        std::sort(ALL(peo));",
			"        std::reverse(ALL(peo));",
			"        return 1;",
			"    }",
			"    game (std::vector<card> New_peo) {",
			"        peo = New_peo;",
			"        if (Rk10()) { level = 10; return; }",
			"        if (Rk9()) { level = 9; return; }",
			"        if (Rk8()) { level = 8; return; }",
			"        if (Rk7()) { level = 7; return; }",
			"        if (Rk6()) { level = 6; return; }",
			"        if (Rk5()) { level = 5; return; }",
			"        if (Rk4()) { level = 4; return; }",
			"        if (Rk3()) { level = 3; return; }",
			"        if (Rk2()) { level = 2; return; }",
			"        if (Rk1()) { level = 1; return; }",
			"    }",
			"    friend bool operator < (const game &a, const game &b) {",
			"        if (a.level != b.level) return a.level < b.level;",
			"        FOR (i, 0, 4) if (a.peo[i] != b.peo[i]) return a.peo[i] < b.peo[i];",
			"        return 0;",
			"    }",
			"    friend bool operator == (const game &a, const game &b) {",
			"        if (a.level != b.level) return 0;",
			"        FOR (i, 0, 4) if (a.peo[i] != b.peo[i]) return 0;",
			"        return 1;",
			"    }",
			"};",
			"void debug(std::vector<card> peo) {",
			"    for (auto it : peo) cout << it.rank << \" \" << it.suit << \"  \";",
			"    cout << \"\\n\\n\";",
			"}",
			"int clac(std::vector<card> Ali, std::vector<card> Bob) {",
			"    game atype(Ali), btype(Bob);",
			"    if (atype < btype) return -1;",
			"    else if (atype == btype) return 0;",
			"    return 1;",
			"}"
		],
		"description": "Card"
	},
	"std_10": {
		"scope": "cpp",
		"prefix": "std",
		"body": [
			"#include<bits/stdc++.h>",
			"using namespace std;",
			"std::map<char, int> mp; //将字符转化为数字",
			"std::map<int, char> mp2; //将数字转化为字符",
			"int main(){",
			"    for(int i = 0; i < 10; i++) mp[(char)i + 48] = i, mp2[i] = (char)i + 48;",
			"    for(int i = 10; i < 36; i++) mp[(char)i + 55] = i, mp2[i] = (char)i + 55;",
			"    for(int i = 36; i < 62; i++) mp[(char)i + 61] = i, mp2[i] = (char)i + 61;",
			"",
			"    int tt = 1, a, b; std::cin >> tt;",
			"    while(tt--){",
			"        std::string s, sh;",
			"        std::vector<int> nums, ans;",
			"        std::cin >> a >> b >> s;",
			"        for(auto c : s) nums.push_back(mp[c]);",
			"        std::reverse(nums.begin(), nums.end());",
			"        while(nums.size()){ //短除法，将整个大数一直除 b ，取余数",
			"            int remainder = 0;",
			"            for(int i = nums.size() - 1; ~i; i--){",
			"                nums[i] += remainder * a;",
			"                remainder = nums[i] % b;",
			"                nums[i] /= b;",
			"            }",
			"            ans.push_back(remainder); //得到余数",
			"            while(nums.size() && nums.back() == 0) nums.pop_back(); //去掉前导 0",
			"        }",
			"        std::reverse(ans.begin(), ans.end());",
			"        for(int i : ans) sh += mp2[i];",
			"        cout << a << ' ' << s << endl;",
			"        cout << b << ' ' << sh << endl << endl;",
			"    }",
			"    return 0;",
			"}"
		],
		"description": "Std"
	},
	"t": {
		"scope": "cpp",
		"prefix": "t",
		"body": [
			"template<class T> std::vector<Point<T>> halfcut(std::vector<Line<T>> lines) {",
			"    std::sort(lines.begin(), lines.end(), [&](auto l1, auto l2) {",
			"        auto d1 = l1.b - l1.a;",
			"        auto d2 = l2.b - l2.a;",
			"        if (sign(d1) != sign(d2)) {",
			"            return sign(d1) == 1;",
			"        }",
			"        return cross(d1, d2) > 0;",
			"    });",
			"    std::deque<Line<T>> ls;",
			"    std::deque<Point<T>> ps;",
			"    for (auto l : lines) {",
			"        if (ls.empty()) {",
			"            ls.push_back(l);",
			"            continue;",
			"        }",
			"        while (!ps.empty() &&!pointOnLineLeft(ps.back(), l)) {",
			"            ps.pop_back();",
			"            ls.pop_back();",
			"        }",
			"        while (!ps.empty() && !pointOnLineLeft(ps[0], l)) {",
			"            ps.pop_front();",
			"            ls.pop_front();",
			"        }",
			"        if (cross(l.b - l.a, ls.back().b - ls.back().a) == 0) {",
			"            if (dot(l.b - l.a, ls.back().b - ls.back().a) > 0) {",
			"                if (!pointOnLineLeft(ls.back().a, l)) {",
			"                    assert(ls.size() == 1);",
			"                    ls[0] = l;",
			"                }",
			"                continue;",
			"            }",
			"            return {};",
			"        }",
			"        ps.push_back(lineIntersection(ls.back(), l));",
			"        ls.push_back(l);",
			"    }",
			"    while (!ps.empty() && !pointOnLineLeft(ps.back(), ls[0])) {",
			"        ps.pop_back();",
			"        ls.pop_back();",
			"    }",
			"    if (ls.size() <= 2) {",
			"        return {};",
			"    }",
			"    ps.push_back(lineIntersection(ls[0], ls.back()));",
			"    return std::vector(ps.begin(), ps.end());",
			"}"
		],
		"description": "T"
	},
	"pushup": {
		"scope": "cpp",
		"prefix": "pushup",
		"body": [
			"const int N = 1e6 + 10;",
			"int T, n, a[N], c, tr[N << 2];",
			"void pushup(int u){",
			"    tr[u] = std::max(tr[u << 1], tr[u << 1 | 1]);",
			"}",
			"void build(int u, int l, int r){",
			"    if (l == r) tr[u] = c;",
			"    else {",
			"        int mid = l + r >> 1;",
			"        build(u << 1, l, mid);",
			"        build(u << 1 | 1, mid + 1, r);",
			"        pushup(u);",
			"    }",
			"}",
			"void update(int u, int l, int r, int p, int k){",
			"    if (l > p || r < p) return;",
			"    if (l == r) tr[u] -= k;",
			"    else {",
			"        int mid = l + r >> 1;",
			"        update(u << 1, l, mid, p, k);",
			"        update(u << 1 | 1, mid + 1, r, p, k);",
			"        pushup(u);",
			"    }",
			"}",
			"int query(int u, int l, int r, int k){",
			"    if (l == r){",
			"        if (tr[u] >= k) return l;",
			"        return n + 1;",
			"    }",
			"    int mid = l + r >> 1;",
			"    if (tr[u << 1] >= k) return query(u << 1, l, mid, k);",
			"    else return query(u << 1 | 1, mid + 1, r, k);",
			"}",
			"int main() {",
			"    std::cin >> n >> c;",
			"    for (int i = 1; i <= n; i++) std::cin >> a[i];",
			"    build(1, 1, n);",
			"    for (int i = 1; i <= n; i++)",
			"        update(1, 1, n, query(1, 1, n, a[i]), a[i]);",
			"    cout << query(1, 1, n, c) - 1 << \" \";",
			"}"
		],
		"description": "Pushup"
	},
	"code_12": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"void solve(){",
			"    std::cin >> n >> c;",
			"    for (int i = 1; i <= n; i++) std::cin >> a[i];",
			"    multiset <int> s;",
			"    for (int i = 1; i <= n; i++){",
			"        auto it = s.std::lower_bound(a[i]);",
			"        if (it == s.end()) s.insert(c - a[i]);",
			"        else {",
			"            int x = *it;",
			"            // multiset 可以存放重复数据，如果是删除某个值的话，会去掉多个箱子",
			"            // 导致答案错误，所以直接删除对应位置的元素",
			"            s.erase(it);  ",
			"            s.insert(x - a[i]);",
			"        }",
			"    }",
			"    cout << s.size() << \"\\n\";",
			"}"
		],
		"description": "Code"
	},
	"code_13": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"std::vector<std::pair<ld, int>> val = {",
			"    {std::log(x) * std::pow(y, z), 0}, {std::log(x) * std::pow(z, y), 1}, {std::log(x) * y * z, 2},",
			"    {std::log(x) * z * y, 3},     {std::log(y) * std::pow(x, z), 4}, {std::log(y) * std::pow(z, x), 5},",
			"    {std::log(y) * x * z, 6},     {std::log(y) * z * x, 7},     {std::log(z) * std::pow(x, y), 8},",
			"    {std::log(z) * std::pow(y, x), 9}, {std::log(z) * x * y, 10},    {std::log(z) * y * x, 11}};",
			"",
			"std::sort(val.begin(), val.end(), [&](auto x, auto y) {",
			"    if (equal(x.first, y.first)) return x.second < y.second; // queal比较两个浮点数是否相等",
			"    return x.first > y.first;",
			"});",
			"std::cout << ans[val.front().second] << std::endl;"
		],
		"description": "Code"
	},
	"code_14": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"#define ranges std::ranges",
			"#define views std::views",
			"",
			"using u32 = unsigned;",
			"using i64 = long long;",
			"using u64 = unsigned long long;",
			"",
			"using pii = std::pair<int, int>;",
			"using a2 = std::array<int, 2>;",
			"using a3 = std::array<int, 3>;",
			"using a4 = std::array<int, 4>;",
			"",
			"const int N = 1e6;",
			"const int MAXN = 1e6 + 10;",
			"const int inf = 1e9;",
			"// const int mod = 1e9 + 7;",
			"const int mod = 998244353;",
			"",
			"std::mt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count());",
			"",
			"void solve() {",
			"",
			"}",
			"",
			"signed main() {",
			"    std::ios::sync_with_stdio(false);",
			"    std::cin.tie(0), std::cout.tie(0);",
			"    int t = 1;//std::cin >> t;",
			"    while (t--) {",
			"        solve();",
			"        std::cout << '\\n';",
			"    }",
			"    return 0;",
			"}"
		],
		"description": "Code"
	},
	"code_15": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"auto operator<=>(const V &) const = default;"
		],
		"description": "Code"
	},
	"zmod": {
		"scope": "cpp",
		"prefix": "zmod",
		"body": [
			"using i64 = long long;",
			"",
			"template<typename T> constexpr T mypow(T n, i64 k) {",
			"    T r = 1;",
			"    for (; k; k /= 2, n *= n) {",
			"        if (k % 2) {",
			"            r *= n;",
			"        }",
			"    }",
			"    return r;",
			"}",
			"",
			"template<typename T> constexpr T power(int n) {",
			"    return mypow(T(2), n);",
			"}",
			"",
			"template<const int &MOD> struct Zmod {",
			"    int x;",
			"    Zmod(signed x = 0) : x(norm(x % MOD)) {}",
			"    Zmod(i64 x) : x(norm(x % MOD)) {}",
			"",
			"    constexpr int norm(int x) const noexcept {",
			"        if (x < 0) [[unlikely]] {",
			"            x += MOD;",
			"        }",
			"        if (x >= MOD) [[unlikely]] {",
			"            x -= MOD;",
			"        }",
			"        return x;",
			"    }",
			"    explicit operator int() const {",
			"        return x;",
			"    }",
			"    constexpr int val() const {",
			"        return x;",
			"    }",
			"    constexpr Zmod operator-() const {",
			"        Zmod val = norm(MOD - x);",
			"        return val;",
			"    }",
			"    constexpr Zmod inv() const {",
			"        assert(x != 0);",
			"        return mypow(*this, MOD - 2);",
			"    }",
			"    friend constexpr auto &operator>>(istream &in, Zmod &j) {",
			"        int v;",
			"        in >> v;",
			"        j = Zmod(v);",
			"        return in;",
			"    }",
			"    friend constexpr auto &operator<<(ostream &o, const Zmod &j) {",
			"        return o << j.val();",
			"    }",
			"    constexpr Zmod &operator++() {",
			"        x = norm(x + 1);",
			"        return *this;",
			"    }",
			"    constexpr Zmod &operator--() {",
			"        x = norm(x - 1);",
			"        return *this;",
			"    }",
			"    constexpr Zmod operator++(signed) {",
			"        Zmod res = *this;",
			"        ++*this;",
			"        return res;",
			"    }",
			"    constexpr Zmod operator--(signed) {",
			"        Zmod res = *this;",
			"        --*this;",
			"        return res;",
			"    }",
			"    constexpr Zmod &operator+=(const Zmod &i) {",
			"        x = norm(x + i.x);",
			"        return *this;",
			"    }",
			"    constexpr Zmod &operator-=(const Zmod &i) {",
			"        x = norm(x - i.x);",
			"        return *this;",
			"    }",
			"    constexpr Zmod &operator*=(const Zmod &i) {",
			"        x = i64(x) * i.x % MOD;",
			"        return *this;",
			"    }",
			"    constexpr Zmod &operator/=(const Zmod &i) {",
			"        return *this *= i.inv();",
			"    }",
			"    constexpr Zmod &operator%=(const int &i) {",
			"        return x %= i, *this;",
			"    }",
			"    friend constexpr Zmod operator+(const Zmod i, const Zmod j) {",
			"        return Zmod(i) += j;",
			"    }",
			"    friend constexpr Zmod operator-(const Zmod i, const Zmod j) {",
			"        return Zmod(i) -= j;",
			"    }",
			"    friend constexpr Zmod operator*(const Zmod i, const Zmod j) {",
			"        return Zmod(i) *= j;",
			"    }",
			"    friend constexpr Zmod operator/(const Zmod i, const Zmod j) {",
			"        return Zmod(i) /= j;",
			"    }",
			"    friend constexpr Zmod operator%(const Zmod i, const int j) {",
			"        return Zmod(i) %= j;",
			"    }",
			"    friend constexpr bool operator==(const Zmod i, const Zmod j) {",
			"        return i.val() == j.val();",
			"    }",
			"    friend constexpr bool operator!=(const Zmod i, const Zmod j) {",
			"        return i.val() != j.val();",
			"    }",
			"    friend constexpr bool operator<(const Zmod i, const Zmod j) {",
			"        return i.val() < j.val();",
			"    }",
			"    friend constexpr bool operator>(const Zmod i, const Zmod j) {",
			"        return i.val() > j.val();",
			"    }",
			"};",
			"",
			"int MOD[] = {998244353, 1000000007};",
			"using Z = Zmod<MOD[1]>;"
		],
		"description": "Zmod"
	},
	"frac": {
		"scope": "cpp",
		"prefix": "frac",
		"body": [
			"template<typename T> struct Frac {",
			"    T x, y;",
			"    Frac() : Frac(0, 1) {}",
			"    Frac(T x_) : Frac(x_, 1) {}",
			"    Frac(T x_, T y_) : x(x_), y(y_) {",
			"        if (y < 0) {",
			"            y = -y;",
			"            x = -x;",
			"        }",
			"    }",
			"",
			"    constexpr double val() const {",
			"        return 1. * x / y;",
			"    }",
			"    constexpr Frac norm() const { // 调整符号、转化为最简形式",
			"        T p = std::gcd(x, y);",
			"        return {x / p, y / p};",
			"    }",
			"    friend constexpr auto &operator<<(ostream &o, const Frac &j) {",
			"        T p = std::gcd(j.x, j.y);",
			"        if (j.y == p) {",
			"            return o << j.x / p;",
			"        } else {",
			"            return o << j.x / p << \"/\" << j.y / p;",
			"        }",
			"    }",
			"    constexpr Frac &operator/=(const Frac &i) {",
			"        x *= i.y;",
			"        y *= i.x;",
			"        if (y < 0) {",
			"            x = -x;",
			"            y = -y;",
			"        }",
			"        return *this;",
			"    }",
			"    constexpr Frac &operator+=(const Frac &i) { return x = x * i.y + y * i.x, y *= i.y, *this; }",
			"    constexpr Frac &operator-=(const Frac &i) { return x = x * i.y - y * i.x, y *= i.y, *this; }",
			"    constexpr Frac &operator*=(const Frac &i) { return x *= i.x, y *= i.y, *this; }",
			"    friend constexpr Frac operator+(const Frac i, const Frac j) { return i += j; }",
			"    friend constexpr Frac operator-(const Frac i, const Frac j) { return i -= j; }",
			"    friend constexpr Frac operator*(const Frac i, const Frac j) { return i *= j; }",
			"    friend constexpr Frac operator/(const Frac i, const Frac j) { return i /= j; }",
			"    friend constexpr Frac operator-(const Frac i) { return Frac(-i.x, i.y); }",
			"    friend constexpr bool operator<(const Frac i, const Frac j) { return i.x * j.y < i.y * j.x; }",
			"    friend constexpr bool operator>(const Frac i, const Frac j) { return i.x * j.y > i.y * j.x; }",
			"    friend constexpr bool operator==(const Frac i, const Frac j) { return i.x * j.y == i.y * j.x; }",
			"    friend constexpr bool operator!=(const Frac i, const Frac j) { return i.x * j.y != i.y * j.x; }",
			"};"
		],
		"description": "Frac"
	},
	"bigint": {
		"scope": "cpp",
		"prefix": "bigint",
		"body": [
			"const int base = 1000000000;",
			"const int base_digits = 9; // 分解为九个数位一个数字",
			"struct bigint {",
			"    std::vector<int> a;",
			"    int sign;",
			"",
			"    bigint() : sign(1) {}",
			"    bigint operator-() const {",
			"        bigint res = *this;",
			"        res.sign = -sign;",
			"        return res;",
			"    }",
			"    bigint(long long v) {",
			"        *this = v;",
			"    }",
			"    bigint(const std::string &s) {",
			"        read(s);",
			"    }",
			"    void operator=(const bigint &v) {",
			"        sign = v.sign;",
			"        a = v.a;",
			"    }",
			"    void operator=(long long v) {",
			"        a.clear();",
			"        sign = 1;",
			"        if (v < 0) sign = -1, v = -v;",
			"        for (; v > 0; v = v / base) {",
			"            a.push_back(v % base);",
			"        }",
			"    }",
			"",
			"    // 基础加减乘除",
			"    bigint operator+(const bigint &v) const {",
			"        if (sign == v.sign) {",
			"            bigint res = v;",
			"            for (int i = 0, carry = 0; i < (int)std::max(a.size(), v.a.size()) || carry; ++i) {",
			"                if (i == (int)res.a.size()) {",
			"                    res.a.push_back(0);",
			"                }",
			"                res.a[i] += carry + (i < (int)a.size() ? a[i] : 0);",
			"                carry = res.a[i] >= base;",
			"                if (carry) {",
			"                    res.a[i] -= base;",
			"                }",
			"            }",
			"            return res;",
			"        }",
			"        return *this - (-v);",
			"    }",
			"    bigint operator-(const bigint &v) const {",
			"        if (sign == v.sign) {",
			"            if (std::abs() >= v.std::abs()) {",
			"                bigint res = *this;",
			"                for (int i = 0, carry = 0; i < (int)v.a.size() || carry; ++i) {",
			"                    res.a[i] -= carry + (i < (int)v.a.size() ? v.a[i] : 0);",
			"                    carry = res.a[i] < 0;",
			"                    if (carry) {",
			"                        res.a[i] += base;",
			"                    }",
			"                }",
			"                res.trim();",
			"                return res;",
			"            }",
			"            return -(v - *this);",
			"        }",
			"        return *this + (-v);",
			"    }",
			"    void operator*=(int v) {",
			"        check(v);",
			"        for (int i = 0, carry = 0; i < (int)a.size() || carry; ++i) {",
			"            if (i == (int)a.size()) {",
			"                a.push_back(0);",
			"            }",
			"            long long cur = a[i] * (long long)v + carry;",
			"            carry = (int)(cur / base);",
			"            a[i] = (int)(cur % base);",
			"        }",
			"        trim();",
			"    }",
			"    void operator/=(int v) {",
			"        check(v);",
			"        for (int i = (int)a.size() - 1, rem = 0; i >= 0; --i) {",
			"            long long cur = a[i] + rem * (long long)base;",
			"            a[i] = (int)(cur / v);",
			"            rem = (int)(cur % v);",
			"        }",
			"        trim();",
			"    }",
			"    int operator%(int v) const {",
			"        if (v < 0) {",
			"            v = -v;",
			"        }",
			"        int m = 0;",
			"        for (int i = a.size() - 1; i >= 0; --i) {",
			"            m = (a[i] + m * (long long)base) % v;",
			"        }",
			"        return m * sign;",
			"    }",
			"",
			"    void operator+=(const bigint &v) {",
			"        *this = *this + v;",
			"    }",
			"    void operator-=(const bigint &v) {",
			"        *this = *this - v;",
			"    }",
			"    bigint operator*(int v) const {",
			"        bigint res = *this;",
			"        res *= v;",
			"        return res;",
			"    }",
			"    bigint operator/(int v) const {",
			"        bigint res = *this;",
			"        res /= v;",
			"        return res;",
			"    }",
			"    void operator%=(const int &v) {",
			"        *this = *this % v;",
			"    }",
			"",
			"    bool operator<(const bigint &v) const {",
			"        if (sign != v.sign) return sign < v.sign;",
			"        if (a.size() != v.a.size()) return a.size() * sign < v.a.size() * v.sign;",
			"        for (int i = a.size() - 1; i >= 0; i--)",
			"            if (a[i] != v.a[i]) return a[i] * sign < v.a[i] * sign;",
			"        return false;",
			"    }",
			"    bool operator>(const bigint &v) const {",
			"        return v < *this;",
			"    }",
			"    bool operator<=(const bigint &v) const {",
			"        return !(v < *this);",
			"    }",
			"    bool operator>=(const bigint &v) const {",
			"        return !(*this < v);",
			"    }",
			"    bool operator==(const bigint &v) const {",
			"        return !(*this < v) && !(v < *this);",
			"    }",
			"    bool operator!=(const bigint &v) const {",
			"        return *this < v || v < *this;",
			"    }",
			"",
			"    bigint std::abs() const {",
			"        bigint res = *this;",
			"        res.sign *= res.sign;",
			"        return res;",
			"    }",
			"    void check(int v) { // 检查输入的是否为负数",
			"        if (v < 0) {",
			"            sign = -sign;",
			"            v = -v;",
			"        }",
			"    }",
			"    void trim() { // 去除前导零",
			"        while (!a.empty() && !a.back()) a.pop_back();",
			"        if (a.empty()) sign = 1;",
			"    }",
			"    bool isZero() const { // 判断是否等于零",
			"        return a.empty() || (a.size() == 1 && !a[0]);",
			"    }",
			"    friend bigint std::gcd(const bigint &a, const bigint &b) {",
			"        return b.isZero() ? a : std::gcd(b, a % b);",
			"    }",
			"    friend bigint std::lcm(const bigint &a, const bigint &b) {",
			"        return a / std::gcd(a, b) * b;",
			"    }",
			"    void read(const std::string &s) {",
			"        sign = 1;",
			"        a.clear();",
			"        int pos = 0;",
			"        while (pos < (int)s.size() && (s[pos] == '-' || s[pos] == '+')) {",
			"            if (s[pos] == '-') sign = -sign;",
			"            ++pos;",
			"        }",
			"        for (int i = s.size() - 1; i >= pos; i -= base_digits) {",
			"            int x = 0;",
			"            for (int j = max(pos, i - base_digits + 1); j <= i; j++) x = x * 10 + s[j] - '0';",
			"            a.push_back(x);",
			"        }",
			"        trim();",
			"    }",
			"    friend istream &operator>>(istream &stream, bigint &v) {",
			"        std::string s;",
			"        stream >> s;",
			"        v.read(s);",
			"        return stream;",
			"    }",
			"    friend ostream &operator<<(ostream &stream, const bigint &v) {",
			"        if (v.sign == -1) stream << '-';",
			"        stream << (v.a.empty() ? 0 : v.a.back());",
			"        for (int i = (int)v.a.size() - 2; i >= 0; --i)",
			"            stream << setw(base_digits) << setfill('0') << v.a[i];",
			"        return stream;",
			"    }",
			"",
			"    /* 大整数乘除大整数部分 */",
			"    typedef std::vector<long long> vll;",
			"    bigint operator*(const bigint &v) const { // 大整数乘大整数",
			"        std::vector<int> a6 = convert_base(this->a, base_digits, 6);",
			"        std::vector<int> b6 = convert_base(v.a, base_digits, 6);",
			"        vll a(a6.begin(), a6.end());",
			"        vll b(b6.begin(), b6.end());",
			"        while (a.size() < b.size()) a.push_back(0);",
			"        while (b.size() < a.size()) b.push_back(0);",
			"        while (a.size() & (a.size() - 1)) a.push_back(0), b.push_back(0);",
			"        vll c = karatsubaMultiply(a, b);",
			"        bigint res;",
			"        res.sign = sign * v.sign;",
			"        for (int i = 0, carry = 0; i < (int)c.size(); i++) {",
			"            long long cur = c[i] + carry;",
			"            res.a.push_back((int)(cur % 1000000));",
			"            carry = (int)(cur / 1000000);",
			"        }",
			"        res.a = convert_base(res.a, 6, base_digits);",
			"        res.trim();",
			"        return res;",
			"    }",
			"    friend std::pair<bigint, bigint> divmod(const bigint &a1,",
			"                                       const bigint &b1) { // 大整数除大整数，同时返回答案与余数",
			"        int norm = base / (b1.a.back() + 1);",
			"        bigint a = a1.std::abs() * norm;",
			"        bigint b = b1.std::abs() * norm;",
			"        bigint q, r;",
			"        q.a.resize(a.a.size());",
			"        for (int i = a.a.size() - 1; i >= 0; i--) {",
			"            r *= base;",
			"            r += a.a[i];",
			"            int s1 = r.a.size() <= b.a.size() ? 0 : r.a[b.a.size()];",
			"            int s2 = r.a.size() <= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];",
			"            int d = ((long long)base * s1 + s2) / b.a.back();",
			"            r -= b * d;",
			"            while (r < 0) r += b, --d;",
			"            q.a[i] = d;",
			"        }",
			"        q.sign = a1.sign * b1.sign;",
			"        r.sign = a1.sign;",
			"        q.trim();",
			"        r.trim();",
			"        return std::make_pair(q, r / norm);",
			"    }",
			"    static std::vector<int> convert_base(const std::vector<int> &a, int old_digits, int new_digits) {",
			"        std::vector<long long> p(std::max(old_digits, new_digits) + 1);",
			"        p[0] = 1;",
			"        for (int i = 1; i < (int)p.size(); i++) p[i] = p[i - 1] * 10;",
			"        std::vector<int> res;",
			"        long long cur = 0;",
			"        int cur_digits = 0;",
			"        for (int i = 0; i < (int)a.size(); i++) {",
			"            cur += a[i] * p[cur_digits];",
			"            cur_digits += old_digits;",
			"            while (cur_digits >= new_digits) {",
			"                res.push_back((int)(cur % p[new_digits]));",
			"                cur /= p[new_digits];",
			"                cur_digits -= new_digits;",
			"            }",
			"        }",
			"        res.push_back((int)cur);",
			"        while (!res.empty() && !res.back()) res.pop_back();",
			"        return res;",
			"    }",
			"    static vll karatsubaMultiply(const vll &a, const vll &b) {",
			"        int n = a.size();",
			"        vll res(n + n);",
			"        if (n <= 32) {",
			"            for (int i = 0; i < n; i++) {",
			"                for (int j = 0; j < n; j++) {",
			"                    res[i + j] += a[i] * b[j];",
			"                }",
			"            }",
			"            return res;",
			"        }",
			"",
			"        int k = n >> 1;",
			"        vll a1(a.begin(), a.begin() + k);",
			"        vll a2(a.begin() + k, a.end());",
			"        vll b1(b.begin(), b.begin() + k);",
			"        vll b2(b.begin() + k, b.end());",
			"",
			"        vll a1b1 = karatsubaMultiply(a1, b1);",
			"        vll a2b2 = karatsubaMultiply(a2, b2);",
			"",
			"        for (int i = 0; i < k; i++) a2[i] += a1[i];",
			"        for (int i = 0; i < k; i++) b2[i] += b1[i];",
			"",
			"        vll r = karatsubaMultiply(a2, b2);",
			"        for (int i = 0; i < (int)a1b1.size(); i++) r[i] -= a1b1[i];",
			"        for (int i = 0; i < (int)a2b2.size(); i++) r[i] -= a2b2[i];",
			"",
			"        for (int i = 0; i < (int)r.size(); i++) res[i + k] += r[i];",
			"        for (int i = 0; i < (int)a1b1.size(); i++) res[i] += a1b1[i];",
			"        for (int i = 0; i < (int)a2b2.size(); i++) res[i + n] += a2b2[i];",
			"        return res;",
			"    }",
			"",
			"    void operator*=(const bigint &v) {",
			"        *this = *this * v;",
			"    }",
			"    bigint operator/(const bigint &v) const {",
			"        return divmod(*this, v).first;",
			"    }",
			"    void operator/=(const bigint &v) {",
			"        *this = *this / v;",
			"    }",
			"    bigint operator%(const bigint &v) const {",
			"        return divmod(*this, v).second;",
			"    }",
			"    void operator%=(const bigint &v) {",
			"        *this = *this % v;",
			"    }",
			"};"
		],
		"description": "Bigint"
	},
	"for_10": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"int n;",
			"std::cin >> n;",
			"int N = std::pow(2, n);",
			"std::vector ans(N, std::vector<int>(N));",
			"ans[0][0] = 1;",
			"for (int t = 0; t < n; t++) {",
			"    int m = std::pow(2, t);",
			"    for (int i = 0; i < m; i++) {",
			"        for (int j = m; j < 2 * m; j++) {",
			"            ans[i][j] = ans[i][j - m];",
			"        }",
			"    }",
			"    for (int i = m; i < 2 * m; i++) {",
			"        for (int j = 0; j < m; j++) {",
			"            ans[i][j] = ans[i - m][j];",
			"        }",
			"    }",
			"    for (int i = m; i < 2 * m; i++) {",
			"        for (int j = m; j < 2 * m; j++) {",
			"            ans[i][j] = 1 - ans[i - m][j - m];",
			"        }",
			"    }",
			"}"
		],
		"description": "For"
	},
	"for_11": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"int n;",
			"std::cin >> n;",
			"int x = 1, y = (n + 1) / 2;",
			"std::vector ans(n + 1, std::vector<int>(n + 1));",
			"for (int i = 1; i <= n * n; i++) {",
			"    ans[x][y] = i;",
			"    if (!ans[(x - 2 + n) % n + 1][y % n + 1]){",
			"        x = (x - 2 + n) % n + 1;",
			"        y = y % n + 1;",
			"    } else {",
			"        x = x % n + 1;",
			"    }",
			"}"
		],
		"description": "For"
	},
	"for_12": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"std::vector<int> val; // 堆数",
			"for (int i = 1, x; i <= n; i++) {",
			"    std::cin >> x;",
			"    int it = std::upper_bound(val.begin(), val.end(), x) - val.begin(); // low/upp: 严格/非严格递增",
			"    if (it >= val.size()) { // 新增一堆",
			"        val.push_back(x);",
			"    } else { // 更新对应位置元素",
			"        val[it] = x;",
			"    }",
			"}",
			"std::cout << val.size() << std::endl;"
		],
		"description": "For"
	},
	"for_13": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"std::vector<std::array<int, 3>> in(n + 1);",
			"for (int i = 1; i <= n; i++) {",
			"    std::cin >> in[i][0] >> in[i][1];",
			"    in[i][2] = i;",
			"}",
			"std::sort(in.begin() + 1, in.end(), [&](auto x, auto y) {",
			"    if (x[0] != y[0]) return x[0] < y[0];",
			"    return x[1] > y[1];",
			"});",
			"",
			"std::vector<int> val{0}, idx{0}, pre(n + 1);",
			"for (int i = 1; i <= n; i++) {",
			"    auto [x, y, z] = in[i];",
			"    int it = std::lower_bound(val.begin(), val.end(), y) - val.begin(); // low/upp: 严格/非严格递增",
			"    if (it >= val.size()) { // 新增一堆",
			"        pre[z] = idx.back();",
			"        val.push_back(y);",
			"        idx.push_back(z);",
			"    } else { // 更新对应位置元素",
			"        pre[z] = idx[it - 1];",
			"        val[it] = y;",
			"        idx[it] = z;",
			"    }",
			"}",
			"",
			"std::vector<int> ans;",
			"for (int i = idx.back(); i != 0; i = pre[i]) {",
			"    ans.push_back(i);",
			"}",
			"std::reverse(ans.begin(), ans.end());",
			"cout << ans.size() << \"\\n\";",
			"for (auto it : ans) {",
			"    cout << it << \" \";",
			"}"
		],
		"description": "For"
	},
	"cout": {
		"scope": "cpp",
		"prefix": "cout",
		"body": [
			"bool Solve() {",
			"    std::cout << 12 << std::endl;",
			"    std::cout << setw(12) << 12 << std::endl;",
			"    return 0;",
			"}"
		],
		"description": "Cout"
	},
	"cout_1": {
		"scope": "cpp",
		"prefix": "cout",
		"body": [
			"bool Solve() {",
			"    std::cout << 12 << std::endl;",
			"    cout << setw(12) << setfill('*') << 12 << endl;",
			"    return 0;",
			"}"
		],
		"description": "Cout"
	},
	"while_6": {
		"scope": "cpp",
		"prefix": "while",
		"body": [
			"std::string s;",
			"getline(std::cin, s);",
			"stringstream ss;",
			"ss << s;",
			"while (ss >> s) {",
			"    auto res = stoi(s);",
			"    std::cout << res * 100 << std::endl;",
			"}"
		],
		"description": "While"
	},
	"jos": {
		"scope": "cpp",
		"prefix": "jos",
		"body": [
			"int jos(int n,int k){",
			"    int res=0;",
			"    repeat(i,1,n+1)res=(res+k)%i;",
			"    return res; // res+1，如果编号从1开始",
			"}"
		],
		"description": "Jos"
	},
	"jos_1": {
		"scope": "cpp",
		"prefix": "jos",
		"body": [
			"int jos(int n,int k){",
			"    if(n==1 || k==1)return n-1;",
			"    if(k>n)return (jos(n-1,k)+k)%n; // 线性算法",
			"    int res=jos(n-n/k,k)-n%k;",
			"    if(res<0)res+=n; // mod n",
			"    else res+=res/(k-1); // 还原位置",
			"    return res; // res+1，如果编号从1开始",
			"}"
		],
		"description": "Jos"
	},
	"jos_2": {
		"scope": "cpp",
		"prefix": "jos",
		"body": [
			"void jos(){",
			"\tint64_t n, k, a{}, b{ 1 }; std::cin >> n >> k; --k;",
			"    while (b < n) {",
			"        auto s = a / k + 1, u = b / k + 1, v = std::min(k - a / s, (std::min(u * k, n) - b + u - 1) / u);",
			"        a += s * v, b += u * v;",
			"    }",
			"    cout << a + 1 << '\\n';",
			"}"
		],
		"description": "Jos"
	},
	"week": {
		"scope": "cpp",
		"prefix": "week",
		"body": [
			"int week(int y,int m,int d){",
			"    if(m<=2)m+=12,y--;",
			"    return (d+2*m+3*(m+1)/5+y+y/4-y/100+y/400)%7+1;",
			"}"
		],
		"description": "Week"
	},
	"mypow10": {
		"scope": "cpp",
		"prefix": "mypow10",
		"body": [
			"int mypow10(int n, std::vector<int> k, int p) {",
			"    int r = 1;",
			"    for (int i = k.size() - 1; i >= 0; i--) {",
			"        for (int j = 1; j <= k[i]; j++) {",
			"            r = r * n % p;",
			"        }",
			"        int v = 1;",
			"        for (int j = 0; j <= 9; j++) {",
			"            v = v * n % p;",
			"        }",
			"        n = v;",
			"    }",
			"    return r;",
			"}",
			"signed main() {",
			"    std::string n_, k_;",
			"    int p;",
			"    std::cin >> n_ >> k_ >> p;",
			"",
			"    int n = 0; // 转化并计算 n % p",
			"    for (auto it : n_) {",
			"        n = n * 10 + it - '0';",
			"        n %= p;",
			"    }",
			"    std::vector<int> k; // 转化 k",
			"    for (auto it : k_) {",
			"        k.push_back(it - '0');",
			"    }",
			"    std::cout << mypow10(n, k, p) << std::endl; // 暴力快速幂",
			"}"
		],
		"description": "Mypow10"
	},
	"phi": {
		"scope": "cpp",
		"prefix": "phi",
		"body": [
			"int phi(int n) { //求解 phi(n)",
			"    int ans = n;",
			"    for (int i = 2; i <= n / i; i++) {",
			"        if (n % i == 0) {",
			"            ans = ans / i * (i - 1);",
			"            while (n % i == 0) {",
			"                n /= i;",
			"            }",
			"        }",
			"    }",
			"    if (n > 1) { //特判 n 为质数的情况",
			"        ans = ans / n * (n - 1);",
			"    }",
			"    return ans;",
			"}",
			"signed main() {",
			"    std::string n_, k_;",
			"    int p;",
			"    std::cin >> n_ >> k_ >> p;",
			"",
			"    int n = 0; // 转化并计算 n % p",
			"    for (auto it : n_) {",
			"        n = n * 10 + it - '0';",
			"        n %= p;",
			"    }",
			"    int mul = phi(p), type = 0, k = 0; // 转化 k",
			"    for (auto it : k_) {",
			"        k = k * 10 + it - '0';",
			"        type |= (k >= mul);",
			"        k %= mul;",
			"    }",
			"    if (type) {",
			"        k += mul;",
			"    }",
			"    std::cout << mypow(n, k, p) << std::endl;",
			"}"
		],
		"description": "Phi"
	},
	"getc": {
		"scope": "cpp",
		"prefix": "getc",
		"body": [
			"char buf[1 << 21], *p1 = buf, *p2 = buf;",
			"inline char getc() {",
			"    return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? 0 : *p1++;",
			"}",
			"template<typename T> void Cin(T &a) {",
			"    T ans = 0;",
			"    bool f = 0;",
			"    char c = getc();",
			"    for (; c < '0' || c > '9'; c = getc()) {",
			"        if (c == '-') f = -1;",
			"    }",
			"    for (; c >= '0' && c <= '9'; c = getc()) {",
			"        ans = ans * 10 + c - '0';",
			"    }",
			"    a = f ? -ans : ans;",
			"}",
			"template<typename T, typename... Args> void Cin(T &a, Args &...args) {",
			"    Cin(a), Cin(args...);",
			"}",
			"template<typename T> void Cout(T x) { // 注意，这里输出不带换行",
			"    if (x < 0) putchar('-'), x = -x;",
			"    if (x > 9) Cout(x / 10);",
			"    putchar(x % 10 + '0');",
			"}"
		],
		"description": "Getc"
	},
	"if_1": {
		"scope": "cpp",
		"prefix": "if",
		"body": [
			"using i128 = __int128;",
			"",
			"std::istream& operator>>(std::istream& is, i128& n) {",
			"    std::string s;is >> s;",
			"    n = 0;",
			"    for (char i : s) n = n * 10 + i - '0';",
			"    return is;",
			"}",
			"std::ostream& operator<<(std::ostream& os, i128 n) {",
			"    if (n == 0) {",
			"        return os << 0;",
			"    }",
			"    std::string s;",
			"    while (n) {",
			"        s += '0' + n % 10;",
			"        n /= 10;",
			"    }",
			"    std::reverse(s.begin(), s.end());",
			"    return os << s;",
			"}"
		],
		"description": "If"
	},
	"r": {
		"scope": "cpp",
		"prefix": "r",
		"body": [
			"",
			"mt19937 rnd(chrono::steady_clock::now().time_since_epoch().std::count());",
			"int r(int a, int b) {",
			"    return rnd() % (b - a + 1) + a;",
			"}",
			"",
			"void graph(int n, int root = -1, int m = -1) {",
			"    std::vector<std::pair<int, int>> t;",
			"    for (int i = 1; i < n; i++) { // 先建立一棵以0为根节点的树",
			"        t.emplace_back(i, r(0, i - 1));",
			"    }",
			"",
			"    std::vector<std::pair<int, int>> edge;",
			"    std::set<std::pair<int, int>> uni;",
			"    if (root == -1) root = r(0, n - 1); // 确定根节点",
			"    for (auto [x, y] : t) { // 偏移建树",
			"        x = (x + root) % n + 1;",
			"        y = (y + root) % n + 1;",
			"        edge.emplace_back(x, y);",
			"        uni.emplace(x, y);",
			"    }",
			"",
			"    if (m != -1) { // 如果是图，则在树的基础上继续加边",
			"        for (int i = n; i <= m; i++) {",
			"            while (true) {",
			"                int x = r(1, n), y = r(1, n);",
			"                if (x == y) continue; // 拒绝自环",
			"                if (uni.std::count({x, y})) continue; // 拒绝重边",
			"                edge.emplace_back(x, y);",
			"                uni.emplace(x, y);",
			"            }",
			"        }",
			"    }",
			"",
			"    random_shuffle(edge.begin(), edge.end()); // 打乱节点",
			"    for (auto [x, y] : edge) {",
			"        cout << x << \" \" << y << endl;",
			"    }",
			"}"
		],
		"description": "R"
	},
	"myhash": {
		"scope": "cpp",
		"prefix": "myhash",
		"body": [
			"struct myhash {",
			"    static uint64_t hash(uint64_t x) {",
			"        x += 0x9e3779b97f4a7c15;",
			"        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
			"        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
			"        return x ^ (x >> 31);",
			"    }",
			"    size_t operator()(uint64_t x) const {",
			"        static const uint64_t SEED = chrono::steady_clock::now().time_since_epoch().std::count();",
			"        return hash(x + SEED);",
			"    }",
			"    size_t operator()(std::pair<uint64_t, uint64_t> x) const {",
			"        static const uint64_t SEED = chrono::steady_clock::now().time_since_epoch().std::count();",
			"        return hash(x.first + SEED) ^ (hash(x.second + SEED) >> 1);",
			"    }",
			"};",
			"// unordered_map<int, int, myhash>"
		],
		"description": "Myhash"
	},
	"for_14": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"for (int i : {1, 2}) {} // GNU C++11 支持范围表达式",
			"",
			"auto cc = [&](int x) { x++; }; // GNU C++11 支持 auto 与 lambda 表达式",
			"cc(2);",
			"",
			"std::tuple<std::string, int, int> V; // GNU C++11 引入",
			"std::array<int, 3> C; // GNU C++11 引入",
			"",
			"auto dfs = [&](auto self, int x) -> void { // GNU C++14 支持 auto 自递归",
			"    if (x > 10) return;",
			"    self(self, x + 1);",
			"};",
			"dfs(dfs, 1);",
			"",
			"std::vector in(1, std::vector<int>(1)); // GNU C++17 支持 std::vector 模板类型缺失",
			"",
			"std::map<int, int> dic;",
			"for (auto [u, v] : dic) {} // GNU C++17 支持 auto 解绑",
			"dic.contains(12); // GNU C++20 支持 contains 函数",
			"",
			"constexpr double Pi = numbers::pi; // C++20 支持"
		],
		"description": "For"
	},
	"code_16": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"using i64 = __int128; // 64 位 GNU C++11 支持"
		],
		"description": "Code"
	},
	"code_17": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"#define int long long",
			"std::map<int, int> dic;",
			"int x = dic.size() - 1;",
			"std::cout << x << std::endl;"
		],
		"description": "Code"
	},
	"std_11": {
		"scope": "cpp",
		"prefix": "std",
		"body": [
			"// #pragma GCC optimize(\"Ofast\", \"unroll-loops\")",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"signed main() {",
			"    int n = 4E3, cnt = 0;",
			"    bitset<30> ans;",
			"    for (int i = 1; i <= n; i++) {",
			"        for (int j = 1; j <= n; j += 2) {",
			"            for (int k = 1; k <= n; k += 4) {",
			"                ans |= i | j | k;",
			"                cnt++;",
			"            }",
			"        }",
			"    }",
			"    cout << cnt << \"\\n\";",
			"}"
		],
		"description": "Std"
	},
	"std_12": {
		"scope": "cpp",
		"prefix": "std",
		"body": [
			"// #pragma GCC optimize(\"Ofast\", \"unroll-loops\")",
			"",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"mt19937 rnd(chrono::steady_clock::now().time_since_epoch().std::count());",
			"",
			"signed main() {",
			"    size_t n = 340000000, seed = 0;",
			"    for (int i = 1; i <= n; i++) {",
			"        seed ^= rnd();",
			"    }",
			"",
			"    return 0;",
			"}"
		],
		"description": "Std"
	},
	"code_18": {
		"scope": "cpp",
		"prefix": "code",
		"body": [
			"g++ -O2 -std=c++20 -pipe",
			"-Wall -Wextra -Wconversion /* 这部分是警告相关，可能用不到 */",
			"-fstack-protector",
			"-Wl,--std::stack=268435456"
		],
		"description": "Code"
	}
}
