## 数论

本文对于数论的开头部分做一个简介。

### 整除

**定义**
设 $a,b\in\mathbf{Z}$，$a\ne 0$。如果 $\exists q\in\mathbf{Z}$，使得 $b=aq$，那么就说 $b$ 可被 $a$  **整除**，记作 $a\mid b$；$b$ 不被 $a$ 整除记作 $a\nmid b$。

整除的性质：

- $a\mid b\iff-a\mid b\iff a\mid-b\iff|a|\mid|b|$
- $a\mid b\land b\mid c\implies a\mid c$
- $a\mid b\land a\mid c\iff\forall x,y\in\mathbf{Z}, a\mid(xb+yc)$
- $a\mid b\land b\mid a\implies b=\pm a$
- 设 $m\ne0$，那么 $a\mid b\iff ma\mid mb$。
- 设 $b\ne0$，那么 $a\mid b\implies|a|\le|b|$。
- 设 $a\ne0,b=qa+c$，那么 $a\mid b\iff a\mid c$。

#### 约数

**定义**
若 $a\mid b$，则称 $b$ 是 $a$ 的 **倍数**，$a$ 是 $b$ 的 **约数**。

$0$ 是所有非 $0$ 整数的倍数。对于整数 $b\ne0$，$b$ 的约数只有有限个。

平凡约数（平凡因数）：对于整数 $b\ne0$，$\pm1$、$\pm b$ 是 $b$ 的平凡约数。当 $b=\pm1$ 时，$b$ 只有两个平凡约数。

对于整数 $b\ne 0$，$b$ 的其他约数称为真约数（真因数、非平凡约数、非平凡因数）。

约数的性质：

- 设整数 $b\ne0$。当 $d$ 遍历 $b$ 的全体约数的时候，$\dfrac{b}{d}$ 也遍历 $b$ 的全体约数。
- 设整数 $b\gt 0$，则当 $d$ 遍历 $b$ 的全体正约数的时候，$\dfrac{b}{d}$ 也遍历 $b$ 的全体正约数。

### 带余数除法

**余数**
设 $a,b$ 为两个给定的整数，$a\ne0$。设 $d$ 是一个给定的整数。那么，一定存在唯一的一对整数 $q$ 和 $r$，满足 $b=qa+r,d\le r<|a|+d$。

无论整数 $d$ 取何值，$r$ 统称为余数。$a\mid b$ 等价于 $a\mid r$。

一般情况下，$d$ 取 $0$，此时等式 $b=qa+r,0\le r<|a|$ 称为带余数除法（带余除法）。这里的余数 $r$ 称为最小非负余数。

余数往往还有两种常见取法：

- 绝对最小余数：$d$ 取 $a$ 的绝对值的一半的相反数。即 $b=qa+r,-\dfrac{|a|}{2}\le r<|a|-\dfrac{|a|}{2}$。
- 最小正余数：$d$ 取 $1$。即 $b=qa+r,1\le r<|a|+1$。

带余数除法的余数只有最小非负余数。**如果没有特别说明，余数总是指最小非负余数。**

余数的性质：

- 任一整数被正整数 $a$ 除后，余数一定是且仅是 $0$ 到 $(a-1)$ 这 $a$ 个数中的一个。
- 相邻的 $a$ 个整数被正整数 $a$ 除后，恰好取到上述 $a$ 个余数。特别地，一定有且仅有一个数被 $a$ 整除。

### 最大公约数与最小公倍数

关于公约数、公倍数、最大公约数与最小公倍数，四个名词的定义，见 [最大公约数](./gcd.md)。

**Warning**
一些作者认为 $0$ 和 $0$ 的最大公约数无定义，其余作者一般将其视为 $0$。C++ STL 的实现中采用后者，即认为 $0$ 和 $0$ 的最大公约数为 $0$[^gcdcpp]。

最大公约数有如下性质：

- $(a_1,\dots,a_n)=(|a_1|,\dots,|a_n|)$；
- $(a,b)=(b,a)$；
- 若 $a\ne 0$，则 $(a,0)=(a,a)=|a|$；
- $(bq+r,b)=(r,b)$；
- $(a_1,\dots,a_n)=((a_1,a_2),a_3,\dots,a_n)$。进而 $\forall 1<k<n-1,~(a_1,\dots,a_n)=((a_1,\dots,a_k),(a_{k+1},\dots,a_n))$；
- 对不全为 $0$ 的整数 $a_1,\dots,a_n$ 和非零整数 $m$，$(ma_1,\dots,ma_n)=|m|(a_1,\dots,a_n)$；
- 对不全为 $0$ 的整数 $a_1,\dots,a_n$，若 $(a_1,\dots,a_n)=d$，则 $(a_1/d,\dots,a_n/d)=1$；
- $(a^n,b^n)=(a,b)^n$。

最大公约数还有如下与互素相关的性质：

- 若 $b|ac$ 且 $(a,b)=1$，则 $b\mid c$；
- 若 $b|c$、$a|c$ 且 $(a,b)=1$，则 $ab\mid c$；
- 若 $(a,b)=1$，则 $(a,bc)=(a,c)$；
- 若 $(a_i,b_j)=1,~\forall 1\leq i\leq n,1\leq j\leq m$，则 $\left(\prod_i a_i,\prod_j b_j\right)=1$。特别地，若 $(a,b)=1$，则 $(a^n,b^m)=1$；
- 对整数 $a_1,\dots,a_n$，若 $\exists v\in \mathbf{Z},~\prod_i a_i=v^m$，且 $(a_i,a_j)=1,~\forall i\ne j$，则 $\forall 1\leq i\leq n,~\sqrt[m]{a_i}\in\mathbf{Z}$。

最小公倍数有如下性质：

- $[a_1,\dots,a_n]=[|a_1|,\dots,|a_n|]$；
- $[a,b]=[b,a]$；
- 若 $a\ne 0$，则 $[a,1]=[a,a]=|a|$；
- 若 $a\mid b$，则 $[a,b]=|b|$；
- $[a_1,\dots,a_n]=[[a_1,a_2],a_3,\dots,a_n]$。进而 $\forall 1<k<n-1,~[a_1,\dots,a_n]=[[a_1,\dots,a_k],[a_{k+1},\dots,a_n]]$；
- 若 $a_i\mid m,~\forall 1\leq i\leq n$，则 $[a_1,\dots,a_n]\mid m$；
- $[ma_1,\dots,ma_n]=|m|[a_1,\dots,a_n]$；
- $[a,b,c][ab,bc,ca]=[a,b][b,c][c,a]$；
- $[a^n,b^n]=[a,b]^n$。

最大公约数和最小公倍数可以组合出很多奇妙的等式，如：

- $(a,b)[a,b]=|ab|$；
- $(ab,bc,ca)[a,b,c]=|abc|$；
- $\dfrac{(a,b,c)^2}{(a,b)(b,c)(a,c)}=\dfrac{[a,b,c]^2}{[a,b][b,c][a,c]}$。

这些性质均可通过定义或 [唯一分解定理](#算术基本定理) 证明，其中使用唯一分解定理的证明更容易理解。

#### 互素

**定义**
若 $(a_1,a_2)=1$，则称 $a_1$ 和 $a_2$  **互素**（**既约**）。

若 $(a_1,\ldots,a_k)=1$，则称 $a_1,\ldots,a_k$  **互素**（**既约**）。

多个整数互素，不一定两两互素。例如 $6$、$10$ 和 $15$ 互素，但是任意两个都不互素。

互素的性质与最大公约数理论：裴蜀定理（Bézout's identity）。见 [裴蜀定理](./bezouts.md)。

### 素数与合数

关于素数的算法见 [素数](./prime.md)。

**定义**
设整数 $p\ne0,\pm1$。如果 $p$ 除了平凡约数外没有其他约数，那么称 $p$ 为 **素数**（**不可约数**）。

若整数 $a\ne0,\pm 1$ 且 $a$ 不是素数，则称 $a$ 为 **合数**。

$p$ 和 $-p$ 总是同为素数或者同为合数。**如果没有特别说明，素数总是指正的素数。**

整数的因数是素数，则该素数称为该整数的素因数（素约数）。

素数与合数的简单性质：

- 大于 $1$ 的整数 $a$ 是合数，等价于 $a$ 可以表示为整数 $d$ 和 $e$（$1<d,e<a$）的乘积。
- 如果素数 $p$ 有大于 $1$ 的约数 $d$，那么 $d=p$。
- 大于 $1$ 的整数 $a$ 一定可以表示为素数的乘积。
- 对于合数 $a$，一定存在素数 $p\le\sqrt{a}$ 使得 $p\mid a$。
- 素数有无穷多个。
- 所有大于 $3$ 的素数都可以表示为 $6n\pm 1$ 的形式[^ref1]。

### 算术基本定理

**算术基本引理**
设 $p$ 是素数，$p\mid a_1a_2$，那么 $p\mid a_1$ 和 $p\mid a_2$ 至少有一个成立。

算术基本引理的逆命题稍加修改也可以得到素数的另一种定义。

**素数的另一种定义**
对整数 $p\ne 0,\pm 1$，若对任意满足 $p\mid a_1a_2$ 的整数 $a_1,a_2$ 均有 $p\mid a_1$ 或 $p\mid a_2$ 成立，则称 $p$ 是素数。

**Tip**
这个定义的动机可以从 [素理想](../algebra/ring-theory.md#素理想) 中找到。

**算术基本定理（唯一分解定理）**
设正整数 $a$，那么必有表示：

$$
a=p_1p_2\cdots p_s
$$

其中 $p_j(1\le j\le s)$ 是素数。并且在不计次序的意义下，该表示唯一。

**标准素因数分解式**
将上述表示中，相同的素数合并，可得：

$$
a={p_1}^{\alpha_1}{p_2}^{\alpha_2}\cdots{p_s}^{\alpha_s},p_1<p_2<\cdots<p_s
$$

称为正整数 $a$ 的标准素因数分解式。

算术基本定理和算术基本引理，两个定理是等价的。

### 同余

**定义**
设整数 $m\ne0$。若 $m\mid(a-b)$，称 $m$ 为 **模数**（**模**），$a$ 同余于 $b$ 模 $m$，$b$ 是 $a$ 对模 $m$ 的 **剩余**。记作 $a\equiv b\pmod m$。

否则，$a$ 不同余于 $b$ 模 $m$，$b$ 不是 $a$ 对模 $m$ 的剩余。记作 $a\not\equiv b\pmod m$。

这样的等式，称为模 $m$ 的同余式，简称 **同余式**。

根据整除的性质，上述同余式也等价于 $a\equiv b\pmod{(-m)}$。

后文中，如果没有特别说明，模数总是 **正整数**。

式中的 $b$ 是 $a$ 对模 $m$ 的剩余，这个概念与余数完全一致。通过限定 $b$ 的范围，相应的有 $a$ 对模 $m$ 的最小非负剩余、绝对最小剩余、最小正剩余。

同余的性质：

- 同余是 [等价关系](../order-theory.md#二元关系)，即同余具有
  - 自反性：$a\equiv a\pmod m$。
  - 对称性：若 $a\equiv b\pmod m$，则 $b\equiv a\pmod m$。
  - 传递性：若 $a\equiv b\pmod m,b\equiv c\pmod m$，则 $a\equiv c\pmod m$。
- 线性运算：若 $a,b,c,d\in\mathbf{Z},m\in\mathbf{N}^*,a\equiv b\pmod m,c\equiv d\pmod m$ 则有：
  - $a\pm c\equiv b\pm d\pmod m$。
  - $a\times c\equiv b\times d\pmod m$。
- 设 $f(x)=\sum_{i=0}^n a_ix^i$ 和 $g(x)=\sum_{i=0}^n b_ix^i$ 是两个整系数多项式，$m\in\mathbf{N}^*$，且 $a_i\equiv b_i\pmod m,~0\leq i\leq n$，则对任意整数 $x$ 均有 $f(x)\equiv g(x)\pmod m$。进而若 $s\equiv t\pmod m$，则 $f(s)\equiv g(t)\pmod m$。
- 若 $a,b\in\mathbf{Z},k,m\in\mathbf{N}^*,a\equiv b\pmod m$, 则 $ak\equiv bk\pmod{mk}$。
- 若 $a,b\in\mathbf{Z},d,m\in\mathbf{N}^*,d\mid a,d\mid b,d\mid m$，则当 $a\equiv b\pmod m$ 成立时，有 $\dfrac{a}{d}\equiv\dfrac{b}{d}\left(\bmod\;{\dfrac{m}{d}}\right)$。
- 若 $a,b\in\mathbf{Z},d,m\in\mathbf{N}^*,d\mid m$，则当 $a\equiv b\pmod m$ 成立时，有 $a\equiv b\pmod d$。
- 若 $a,b\in\mathbf{Z},d,m\in\mathbf{N}^*$，则当 $a\equiv b\pmod m$ 成立时，有 $(a,m)=(b,m)$。若 $d$ 能整除 $m$ 及 $a,b$ 中的一个，则 $d$ 必定能整除 $a,b$ 中的另一个。

还有性质是乘法逆元。见 [乘法逆元](./inverse.md)。

### 同余类与剩余系

为方便讨论，对集合 $A,B$ 和元素 $r$，我们引入如下记号：

- $r+A:=\{r+a:a\in A\}$；
- $rA:=\{ra:a\in A\}$；
- $A+B:=\{a+b:a\in A,b\in B\}$；
- $AB:=\{ab:a\in A,b\in B\}$。

**同余类**
对非零整数 $m$，把全体整数分成 $|m|$ 个两两不交的集合，且同一个集合中的任意两个数模 $m$ 均同余，我们把这 $|m|$ 个集合均称为模 $m$ 的 **同余类** 或 **剩余类**。用 $r\bmod m$ 表示含有整数 $r$ 的模 $m$ 的同余类。

不难证明对任意非零整数 $m$，上述划分方案一定存在且唯一。

由同余类的定义可知：

- $r\bmod m=\{r+km:k\in\mathbf{Z}\}$；
- $r\bmod m=s\bmod m\iff r\equiv s\pmod m$；
- 对任意 $r,s\in\mathbf{Z}$，要么 $r\bmod m=s\bmod m$，要么 $(r\bmod m)\cap (s\bmod m)=\varnothing$；
- 若 $m_1\mid m$，则对任意整数 $r$ 均有 $r+m\mathbf{Z}\subseteq r+m_1\mathbf{Z}$。

注意到同余是等价关系，所以同余类即为同余关系的等价类。

我们把模 $m$ 的同余类全体构成的集合记为 $\mathbf{Z}_m$，即

$$
\mathbf{Z}_m:=\{r\bmod m:0\leq r<m\}
$$

不难发现：

- 对任意整数 $a$，$a+\mathbf{Z}_m=\mathbf{Z}_m$；
- 对任意与 $m$ 互质的整数 $b$，$b\mathbf{Z}_m=\mathbf{Z}_m$。

由 [商群](../algebra/group-theory.md#商群) 的定义可知 $\mathbf{Z}_m=\mathbf{Z}/m\mathbf{Z}$，所以有时我们也会用 $\mathbf{Z}/m\mathbf{Z}$ 表示 $\mathbf{Z}_m$。

由 [抽屉原理](../combinatorics/drawer-principle.md) 可知：

- 任取 $m+1$ 个整数，必有两个整数模 $m$ 同余。
- 存在 $m$ 个两两模 $m$ 不同余的整数。

由此我们给出完全剩余系的定义：

**完全）剩余系**
对 $m$ 个整数 $a_1,a_2,\dots,a_m$，若对任意的数 $x$，有且仅有一个数 $a_i$ 使得 $x$ 与 $a_i$ 模 $m$ 同余，则称这 $m$ 个整数 $a_1,a_2,\dots,a_m$ 为模 $m$ 的 **完全剩余系**，简称 **剩余系**。

我们还可以定义模 $m$ 的：

- 最小非负（完全）剩余系：$0,\dots,m-1$；
- 最小正（完全）剩余系：$1,\dots,m$；
- 绝对最小（完全）剩余系：$-\lfloor m/2\rfloor,\dots,-\lfloor -m/2\rfloor-1$；
- 最大非正（完全）剩余系：$-m+1,\dots,0$；
- 最大负（完全）剩余系：$-m,\dots,-1$。

若无特殊说明，一般我们只用最小非负剩余系。

我们注意到如下命题成立：

- 在模 $m$ 的任意一个同余类中，任取两个整数 $a_1,a_2$ 均有 $(a_1,m)=(a_2,m)$。

考虑同余类 $r\bmod m$，若 $(r,m)=1$，则该同余类的所有元素均与 $m$ 互质，这说明我们也许可以通过类似方式得知所有与 $m$ 互质的整数构成的集合的结构。

**既约同余类**
对同余类 $r\bmod m$，若 $(r,m)=1$，则称该同余类为 **既约同余类** 或 **既约剩余类**。

我们把模 $m$ 既约剩余类的个数记作 $\varphi(m)$，称其为 [Euler 函数](./euler-totient.md)。

我们把模 $m$ 的既约同余类全体构成的集合记为 $\mathbf{Z}_m^*$，即

$$
\mathbf{Z}_m^*:=\{r\bmod m:0\leq r<m,(r,m)=1\}
$$

**Warning**
对于任意的整数 $a$ 和与 $m$ 互质的整数 $b$，$b\mathbf{Z}_m^*=\mathbf{Z}_m^*$，但是 $a+\mathbf{Z}_m^*$ 不一定为 $\mathbf{Z}_m^*$。这一点与 $\mathbf{Z}_m$ 不同。

由 [抽屉原理](../combinatorics/drawer-principle.md) 可知：

- 任取 $\varphi(m)+1$ 个与 $m$ 互质的整数，必有两个整数模 $m$ 同余。
- 存在 $\varphi(m)$ 个与 $m$ 互质且两两模 $m$ 不同余的整数。

由此我们给出既约剩余系的定义：

**既约剩余系**
对 $t=\varphi(m)$ 个整数 $a_1,a_2,\dots,a_t$，若 $(a_i,m)=1,~\forall 1\leq i\leq t$，且对任意满足 $(x,m)=1$ 的数 $x$，有且仅有一个数 $a_i$ 使得 $x$ 与 $a_i$ 模 $m$ 同余，则称这 $t$ 个整数 $a_1,a_2,\dots,a_t$ 为模 $m$ 的 **既约剩余系**、**缩剩余系** 或 **简化剩余系**。

类似地，我们也可以定义最小非负既约剩余系等概念。

若无特殊说明，一般我们只用最小非负既约剩余系。

#### 剩余系的复合

对正整数 $m$，我们有如下定理：

- 若 $m=m_1m_2,~1\leq m_1,m_2$，令 $Z_{m_1},Z_{m_2}$ 分别为模 $m_1,m_2$ 的 **完全** 剩余系，则对任意与 $m_1$ 互质的 $a$ 均有：

$$
Z_m=aZ_{m_1}+m_1Z_{m_2}.
$$

为模 $m$ 的 **完全** 剩余系。进而，若 $m=\prod_{i=1}^k m_i,~1\leq m_1,m_2,\dots,m_k$，令 $Z_{m_1},\dots,Z_{m_k}$ 分别为模 $m_1,\dots,m_k$ 的 **完全** 剩余系，则：

$$
Z_m=\sum_{i=1}^k\left(\prod_{j=1}^{i-1}m_j\right)Z_{m_i}.
$$

为模 $m$ 的 **完全** 剩余系。

**证明**
只需证明对任意满足 $ax+m_1y\equiv ax'+m_1y'\pmod{m_1m_2}$ 的 $x,x'\in Z_{m_1}$，$y,y'\in Z_{m_2}$，都有：

$$
ax+m_1y=ax'+m_1y'.
$$

实际上，由 $m_1\mid m_1m_2$，我们有 $ax+m_1y\equiv ax'+m_1y'\pmod{m_1}$，进而 $ax\equiv ax'\pmod{m_1}$，由 $(a,m_1)=1$ 可知 $x\equiv x'\pmod{m_1}$，进而有 $x=x'$。

进一步，$m_1y\equiv m_1y'\pmod{m_1m_2}$，则 $y\equiv y'\pmod{m_2}$，即 $y=y'$。

因此，

$$
ax+m_1y=ax'+m_1y'.
$$

- 若 $m=m_1m_2,~1\leq m_1,m_2,(m_1,m_2)=1$，令 $Z_{m_1}^*,Z_{m_2}^*$ 分别为模 $m_1,m_2$ 的 **既约** 剩余系，则：

$$
Z_m^*=m_2Z_{m_1}^*+m_1Z_{m_2}^*.
$$

为模 $m$ 的 **既约** 剩余系。

**Tip**
该定理等价于证明 Euler 函数为 [积性函数](#积性函数)。

**证明**
令 $Z_{m_1},Z_{m_2}$ 分别为模 $m_1,m_2$ 的完全剩余系，我们已经证明了

$$
Z_m=m_2Z_{m_1}+m_1Z_{m_2}
$$

为模 $m$ 的完全剩余系。令 $M=\{a\in Z_m:(a,m)=1\}\subseteq Z_m$，显然 $M$ 为模 $m$ 的既约剩余系，所以我们只需证明 $M=Z_m^*$ 即可。

显然 $Z_m^*\subseteq Z_m$。

任取 $m_2x+m_1y\in M$，其中 $x\in Z_{m_1}$ 且 $y\in Z_{m_2}$，有 $(m_2x+m_1y,m_1m_2)=1$，由 $(m_1,m_2)=1$ 可得

$$
1=(m_2x+m_1y,m_1)=(m_2x,m_1)=(x,m_1),
$$

$$
1=(m_2x+m_1y,m_2)=(m_1y,m_2)=(y,m_2).
$$

因此可得 $x\in Z_{m_1}^*$ 且 $y\in Z_{m_2}^*$，即 $M\subseteq Z_m^*$。

任取 $m_2x+m_1y\in Z_m^*$，其中 $x\in Z_{m_1}^*$ 且 $y\in Z_{m_2}^*$，有 $(x,m_1)=1$ 且 $(y,m_2)=1$，由 $(m_1,m_2)=1$ 可得

$$
(m_2x+m_1y,m_1)=(m_2x,m_1)=(x,m_1)=1,
$$

$$
(m_2x+m_1y,m_2)=(m_1y,m_2)=(x,m_2)=1,
$$

因此可得 $(m_2x+m_1y,m_1m_2)=1$，即 $Z_m^*\subseteq M$。

综上所述，

$$
Z_m^*=m_2Z_{m_1}^*+m_1Z_{m_2}^*.
$$

为模 $m$ 的 **既约** 剩余系。

### 数论函数

数论函数（也称算术函数）指定义域为正整数的函数。数论函数也可以视作一个数列。

#### 积性函数

**定义**
在数论中，若函数 $f(n)$ 满足 $f(1)=1$，且 $f(xy)=f(x)f(y)$ 对任意互质的 $x, y \in\mathbf{N}^*$ 都成立，则 $f(n)$ 为 **积性函数**。

在数论中，若函数 $f(n)$ 满足 $f(1)=1$ 且 $f(xy)=f(x)f(y)$ 对任意的 $x, y \in\mathbf{N}^*$ 都成立，则 $f(n)$ 为 **完全积性函数**。

##### 性质

若 $f(x)$ 和 $g(x)$ 均为积性函数，则以下函数也为积性函数：

$$
\begin{aligned}
h(x)&=f(x^p)\\
h(x)&=f^p(x)\\
h(x)&=f(x)g(x)\\
h(x)&=\sum_{d\mid x}f(d)g\left(\dfrac{x}{d}\right)
\end{aligned}
$$

对正整数 $x$，设其唯一质因数分解为 $x=\prod p_i^{k_i}$，其中 $p_i$ 为质数。

若 $F(x)$ 为积性函数，则有 $F(x)=\prod F(p_i^{k_i})$。

若 $F(x)$ 为完全积性函数，则有 $F(x)=\prod F(p_i^{k_i})=\prod F(p_i)^{k_i}$。

##### 例子

- 单位函数：$\varepsilon(n)=[n=1]$。（完全积性）
- 恒等函数：$\operatorname{id}_k(n)=n^k$，$\operatorname{id}_{1}(n)$ 通常简记作 $\operatorname{id}(n)$。（完全积性）
- 常数函数：$1(n)=1$。（完全积性）
- 除数函数：$\sigma_{k}(n)=\sum_{d\mid n}d^{k}$。$\sigma_{0}(n)$ 通常简记作 $d(n)$ 或 $\tau(n)$，$\sigma_{1}(n)$ 通常简记作 $\sigma(n)$。
- 欧拉函数：$\varphi(n)=\sum_{i=1}^n[(i,n)=1]$。
- 莫比乌斯函数：$\mu(n)=\begin{cases}1&n=1\\0&\exists d>1,d^{2}\mid n\\(-1)^{\omega(n)}&\text{otherwise}\end{cases}$，其中 $\omega(n)$ 表示 $n$ 的本质不同质因子个数。

#### 加性函数

**定义**
在数论中，若函数 $f(n)$ 满足 $f(1)=0$ 且 $f(xy)=f(x)+f(y)$ 对任意互质的 $x, y \in\mathbf{N}^*$ 都成立，则 $f(n)$ 为 **加性函数**。

在数论中，若函数 $f(n)$ 满足 $f(1)=0$ 且 $f(xy)=f(x)+f(y)$ 对任意的 $x, y \in\mathbf{N}^*$ 都成立，则 $f(n)$ 为 **完全加性函数**。

**加性函数**
    本节中的加性函数指数论上的加性函数 (Additive function)，应与代数中的 Additive map 做区分。

##### 性质

对正整数 $x$，设其唯一质因数分解为 $x=\prod p_i^{k_i}$，其中 $p_i$ 为质数。

若 $F(x)$ 为加性函数，则有 $F(x)=\sum F(p_i^{k_i})$。

若 $F(x)$ 为完全加性函数，则有 $F(x)=\sum F(p_i^{k_i})=\sum F(p_i)\cdot k_i$。

##### 例子

为方便叙述，令所有质数组成的集合为 $\mathbf P$.

- 素因数分解中 $p$ 的重数：$\nu_p(n) = \max\{k\in\mathbf N: p^k\mid n\}$，其中，$p\in\mathbf P$。（完全加性）
- 所有质因子数目：$\Omega(n)=\sum_{p \in\mathbf P} \nu_p(n)$。（完全加性）
- 相异质因子数目：$\omega(n)=\sum_{p \in\mathbf P} [p \mid n]$。
- 所有质因子之和：$a_0(n)=\sum_{p \in\mathbf P} \nu_p(n)\cdot p$。（完全加性）
- 相异质因子之和：$a_1(n)=\sum_{p \in\mathbf P} [p \mid n] \cdot p$。

### 取整函数

对于实数 $x$，定义 **下取整函数**（floor function）和 **上取整函数**（ceiling function）分别为

$$
\lfloor x\rfloor = \max\{k\in\mathbf Z:k\le x\},~\lceil x\rceil = \min\{k\in\mathbf Z:k\ge x\}.
$$

利用下取整函数，一个实数可以分解为整数部分和小数部分：$x = \lfloor x\rfloor + \{x\}$。其中，$\{x\}$ 表示 $x$ 的小数部分。

取整函数有如下基本性质：（$x\in\mathbf R,~n\in\mathbf Z$）

- $x\in\mathbf Z \iff x = \lfloor x\rfloor = \lceil x\rceil$。
- $\lceil x\rceil - \lfloor x\rfloor = [x\notin\mathbf Z]$。
- $x - 1 < \lfloor x\rfloor \le x \le \lceil x\rceil < x + 1$。
- $\lfloor -x\rfloor = -\lceil x\rceil,~\lceil -x\rceil = -\lfloor x\rfloor$。
- $\lfloor x + n\rfloor = \lfloor x\rfloor + n,~\lceil x + n\rceil = \lceil x \rceil + n$。
- $\lfloor x\rfloor$ 和 $\lceil x\rceil$ 都是关于 $x$ 的单调弱增函数。

证明关于下（上）取整函数的等式经常用到如下等价形式：（$x\in\mathbf R,~n\in\mathbf Z$）

- $\lfloor x\rfloor = n \iff n \le x < n + 1 \iff x - 1 < n \le x$。
- $\lceil x\rceil = n \iff n - 1 < x \le n \iff x \le n < x + 1$。

证明关于下（上）取整函数的不等式经常用到如下等价形式：（$x\in\mathbf R,~n\in\mathbf Z$）

- $x < n \iff \lfloor x\rfloor < n$。
- $n < x \iff n < \lceil x\rceil$。
- $x \le n \iff \lceil x\rceil \le n$。
- $n \le x \iff n \le \lfloor x\rfloor$。

涉及和、差的性质如下：（$x,y\in\mathbf R$）

- $\lfloor x\rfloor + \lfloor y\rfloor \le \lfloor x + y\rfloor \le \lfloor x\rfloor + \lfloor y\rfloor + 1$，且恰有一个等号成立。
- $\lceil x\rceil +\lceil y\rceil -1\leq \lceil x+y\rceil \leq \lceil x\rceil +\lceil y\rceil$，且恰有一个等号成立。
- $\lfloor|x - y|\rfloor \le |\lfloor x\rfloor - \lfloor y\rfloor| \le \lceil|x - y|\rceil$。
- $\lfloor|x - y|\rfloor \le |\lceil x\rceil - \lceil y\rceil| \le \lceil|x-y|\rceil$。

涉及商的性质如下：（$x\in\mathbf R,~n\in\mathbf Z,~m\in\mathbf Z_+$）

- $\left\lceil\dfrac{n}{m}\right\rceil = \left\lfloor\dfrac{n+m-1}{m}\right\rfloor,~\left\lfloor\dfrac{n}{m}\right\rfloor = \left\lceil\dfrac{n-m+1}{m}\right\rceil$。
- $\left\lfloor\dfrac{x + n}{m} \right\rfloor = \left\lfloor\dfrac{\lfloor x\rfloor + n}{m} \right\rfloor,~\left\lceil\dfrac{x + n}{m} \right\rceil = \left\lceil\dfrac{\lceil x\rceil + n}{m} \right\rceil$。
- $\left\lfloor\dfrac{\lfloor x/n\rfloor}{m}\right\rfloor = \left\lfloor\dfrac{x}{nm}\right\rfloor,~\left\lceil\dfrac{\lceil x/n\rceil}{m}\right\rceil = \left\lceil\dfrac{x}{nm}\right\rceil$。
- 对于 $x > 0$，有 $\displaystyle\left\lfloor\dfrac{x}{m}\right\rfloor = \sum_{k=1}^{\lfloor x\rfloor}[m\mid k]$。

其中，第二条和第三条性质都可以看作是如下结论的直接推论：

- 设 $f$ 为连续单增函数，且只要 $f(x)\in\mathbf Z$，就有 $x\in\mathbf Z$，那么

$$
\lfloor f(x)\rfloor = \lfloor f(\lfloor x\rfloor)\rfloor,~ \lceil f(x)\rceil = \lceil f(\lceil x\rceil)\rceil.
$$

**证明**
由对称性，只需要证明第一个等式。如果 $x$ 是整数，那么命题显然。否则，$\lfloor x\rfloor < x$。由 $f$ 和下取整函数的单调性可知，$\lfloor f(x)\rfloor \ge \lfloor f(\lfloor x\rfloor)\rfloor$。如果等号不成立，那么设 $y = \lfloor f(x)\rfloor$，它满足 $\lfloor f(\lfloor x\rfloor)\rfloor < y \le \lfloor f(x)\rfloor$，这等价于 $f(\lfloor x\rfloor) < y \le f(x)$。由 $f$ 的连续性可知，存在 $\lfloor x\rfloor < x_0 \le x$ 使得 $f(x_0)=y$。因为 $y\in\mathbf Z$，所以 $x_0\in\mathbf Z$，这与 $\lfloor x\rfloor$ 的定义矛盾。故而，等号成立，即 $\lfloor f(x)\rfloor = \lfloor f(\lfloor x\rfloor)\rfloor$。

最后是一组关于带有取整函数的求和式的结论：（$x\in\mathbf R,~n\in\mathbf Z,~m\in\mathbf Z_+$）

- $n = \left\lfloor\dfrac{n}{2}\right\rfloor + \left\lceil\dfrac{n}{2}\right\rceil$。
- $n = \left\lfloor\dfrac{n}{m} \right\rfloor + \left\lfloor\dfrac{n+1}{m} \right\rfloor + \cdots + \left\lfloor\dfrac{n+m-1}{m} \right\rfloor$。
- $n = \left\lceil\dfrac{n}{m} \right\rceil + \left\lceil\dfrac{n-1}{m} \right\rceil + \cdots + \left\lceil\dfrac{n-m+1}{m} \right\rceil$。
- $\lfloor mx\rfloor = \lfloor x\rfloor + \left\lfloor x+\dfrac{1}{m}\right\rfloor + \cdots + \left\lfloor x+\dfrac{m-1}{m}\right\rfloor$。
- $\lceil mx\rceil = \lceil x\rceil + \left\lceil x - \dfrac{1}{m}\right\rceil + \cdots + \left\lceil x - \dfrac{m-1}{m}\right\rceil$。
- 当 $m\perp n$ 时，$\displaystyle\sum_{k=1}^{m-1}\left\lfloor\dfrac{kn}{m}\right\rfloor=\dfrac{1}{2}(n-1)(m-1)$。
- 当 $m\perp n$ 时，$\displaystyle\sum_{k=1}^{m-1}\left\lceil\dfrac{kn}{m}\right\rceil=\dfrac{1}{2}(n+1)(m-1)$。

### 常见数列

#### 调和级数

满足调和级数 $\mathcal O\left( \dfrac{N}{1} +\dfrac{N}{2}+\dfrac{N}{3}+\dots + \dfrac{N}{N} \right)$，可以用 $ \approx N\ln N$ 来拟合，但是会略小，误差量级在 $10\%$ 左右。本地可以在 500ms 内完成 $10^8$ 量级的预处理计算。

| N 的量级 |  1  |  2  |   3   |   4    |     5     |     6      |      7      |       8       |       9        |
| :------: | :-: | :-: | :---: | :----: | :-------: | :--------: | :---------: | :-----------: | :------------: |
|  累加和  | 27  | 482 | 7’069 | 93‘668 | 1’166‘750 | 13‘970’034 | 162‘725’364 | 1‘857’511‘568 | 20’877‘697’634 |

下方示例为求解 $1$ 到 $N$ 中各个数字的因数值。

```cpp
const int N = 1E5;
vector<vector<int>> dic(N + 1);
for (int i = 1; i <= N; i++) {
    for (int j = i; j <= N; j += i) {
        dic[j].push_back(i);
    }
}
```

#### 素数密度与分布

| N 的量级 |  1  |  2  |  3  |   4   |   5   |   6    |    7    |     8     |     9      |
| :------: | :-: | :-: | :-: | :---: | :---: | :----: | :-----: | :-------: | :--------: |
| 素数数量 |  4  | 25  | 168 | 1‘229 | 9’592 | 78‘498 | 664’579 | 5‘761’455 | 50‘847’534 |

除此之外，对于任意两个相邻的素数 $p_1,p_2 \le 10^9$ ，有 $|p_1-p_2|<300$ 成立，更具体的说，最大的差值为 $282$ 。

#### 因数最多数字与其因数数量

|        N 的量级        |  1  |  2  |  3  |     4      |      5       |                   6                    |  7  |
| :--------------------: | :-: | :-: | :-: | :--------: | :----------: | :------------------------------------: | :-: |
| 因数最多数字的因数数量 |  4  | 25  | 32  |     64     |     128      |                  240                   | 448 |
|     因数最多的数字     |  -  |  -  |  -  | 7560, 9240 | 83160, 98280 | 720720, 831600, 942480, 982800, 997920 |  -  |

### 欧拉筛（线性筛）

时间复杂度为 $\mathcal{O}(N\log\log N)$ 。

```cpp
vector<int> prime; // 这里储存筛出来的全部质数
auto euler_Prime = [&](int n) -> void {
    vector<int> v(n + 1);
    for (int i = 2; i <= n; ++i) {
        if (!v[i]) {
            v[i] = i;
            prime.push_back(i);
        }
        for (int j = 0; j < prime.size(); ++j) {
            if (prime[j] > v[i] || prime[j] > n / i) break;
            v[i * prime[j]] = prime[j];
        }
    }
};
```

#### 最小质因数

```cpp
std::vector<int> minp, primes;

void sieve(int n) {
    minp.assign(n + 1, 0);
    primes.clear();

    for (int i = 2; i <= n; i++) {
        if (minp[i] == 0) {
            minp[i] = i;
            primes.push_back(i);
        }

        for (auto p : primes) {
            if (i * p > n) {
                break;
            }
            minp[i * p] = p;
            if (p == minp[i]) {
                break;
            }
        }
    }
}
```

### 防爆模乘

#### 借助浮点数实现

以 $\mathcal O(1)$ 计算 $a\cdot b\bmod p$ ，由于不取模，常数比 int128 法小很多。其中 $1 \le n, k, p \le 10^{18}$ 。

```cpp
int mul(int a, int b, int m) {
    int r = a * b - m * (int)(1.L / m * a * b);
    return r - m * (r >= m) + m * (r < 0);
}
```

#### 借助 int128 实现

```cpp
int mul(int a, int b, int m) {
    return (__int128)a * b % m;
}
```

### 威尔逊定理

1. 当且仅当 p 为素数时，$( p -1 )! ≡ -1 ( \mod p )$
2. 当且仅当 p 为素数时，$( p -1 )! ≡ p-1 ( \mod p )$
3. 若 p 为质数，则 p 能被$(p-1)!+1$整除
4. 当且仅当 p 为素数时，$p∣(p−1)!+1$

### 裴蜀定理

> $ax+by=c\ (x \in Z^∗,y \in Z^∗)$ 成立的充要条件是 $gcd⁡(a, b) ∣ c$（ $Z^*$ 表示正整数集）。

#### 逆定理

设 $a, b$ 是不全为零的整数，若 $d > 0$ 是 $a, b$ 的公因数，且存在整数 $x, y$, 使得 $ax+by=d$，则 $d = \gcd(a, b)$。

特殊地，设 $a, b$ 是不全为零的整数，若存在整数 $x, y$, 使得 $ax+by=1$，则 $a, b$ 互质。

#### 多个整数

裴蜀定理可以推广到 $n$ 个整数的情形：设 $a_1, a_2, \dots, a_n$ 是不全为零的整数，则存在整数 $x_1, x_2, \dots, x_n$, 使得 $a_1 x_1 + a_2 x_2 + \cdots + a_n x_n=\gcd(a_1, a_2, \dots, a_n)$。其逆定理也成立：设 $a_1, a_2, \dots, a_n$ 是不全为零的整数，$d > 0$ 是 $a_1, a_2, \dots, a_n$ 的公因数，若存在整数 $x_1, x_2, \dots, x_n$, 使得 $a_1 x_1 + a_2 x_2 + \cdots + a_n x_n=d$，则 $d = \gcd(a_1, a_2, \dots, a_n)$。

例题：给定一个序列 $a$，找到一个序列 $x$，使得 $\sum_{i = 1}^n a_ix_i$ 最小。

```cpp
LL n, a, ans;
LL gcd(LL a, LL b){
    return b ? gcd(b, a % b) : a;
}
int main(){
    cin >> n;
    for (int i = 0; i < n; i ++ ){
        cin >> a;
        if (a < 0) a = -a;
        ans = gcd(ans, a);
    }
    cout << ans << "\n";
    return 0;
}
```

### 逆元

#### 费马小定理解（借助快速幂）

若 $p$ 为素数，$\gcd(a, p) = 1$，则 $a^{p - 1} \equiv 1 \pmod{p}$。

另一个形式：对于任意整数 $a$，有 $a^p \equiv a \pmod{p}$。

单次计算的复杂度即为快速幂的复杂度 $\mathcal O(\log X)$ 。限制：$MOD$ 必须是质数，且需要满足 $x$ 与 $MOD$ 互质。

```cpp
LL inv(LL x) { return mypow(x, mod - 2, mod);}
```

#### 扩展欧几里得解

此方法的 $MOD$ 没有限制，复杂度为 $\mathcal O(\log X)$ ，但是比快速幂法常数大一些。

```cpp
int x, y;
int exgcd(int a, int b, int &x, int &y) { //扩展欧几里得算法
    if (b == 0) {
        x = 1, y = 0;
        return a; //到达递归边界开始向上一层返回
    }
    int r = exgcd(b, a % b, x, y);
    int temp = y; //把x y变成上一层的
    y = x - (a / b) * y;
    x = temp;
    return r; //得到a b的最大公因数
}
LL getInv(int a, int mod) { //求a在mod下的逆元，不存在逆元返回-1
    LL x, y, d = exgcd(a, mod, x, y);
    return d == 1 ? (x % mod + mod) % mod : -1;
}
```

#### 离线求解：线性递推解

以 $\mathcal O(N)$ 的复杂度完成 $1-N$ 中全部逆元的计算。

```cpp
inv[1] = 1;
for (int i = 2; i <= n; i ++ )
    inv[i] = (p - p / i) * inv[p % i] % p;
```

### 扩展欧几里得 exgcd

求解形如 $a\cdot x + b\cdot y = \gcd(a,b)$ 的不定方程的任意一组解。

```cpp
int exgcd(int a, int b, int &x, int &y) {
    if (!b) {
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}
```

例题：求解二元一次不定方程 $A\cdot x + B\cdot y = C$ 。

```cpp
auto clac = [&](int a, int b, int c) {
    int u = 1, v = 1;
    if (a < 0) { // 负数特判，但是没用经过例题测试
        a = -a;
        u = -1;
    }
    if (b < 0) {
        b = -b;
        v = -1;
    }

    int x, y, d = exgcd(a, b, x, y), ans;
    if (c % d != 0) { // 无整数解
        cout << -1 << "\n";
        return;
    }
    a /= d, b /= d, c /= d;
    x *= c, y *= c; // 得到可行解

    ans = (x % b + b - 1) % b + 1;
    auto [A, B] = pair{u * ans, v * (c - ans * a) / b}; // x最小正整数 特解

    ans = (y % a + a - 1) % a + 1;
    auto [C, D] = pair{u * (c - ans * b) / a, v * ans}; // y最小正整数 特解

    int num = (C - A) / b + 1; // xy均为正整数 的 解的组数
};
```

### 类欧几里得

$$
euclidean(a,b,c,n)=\sum_{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor
$$

```cpp
i64 euclidean(i64 a, i64 b, i64 c, i64 n) {
    // sum{0, n}(floor((a * i + b) / c))
    i64 n2 = n * (n + 1) / 2;
    if (a >= c || b >= c)
        return euclidean(a % c, b % c, c, n) + (a / c) * n2 + (b / c) * (n + 1);
    i64 m = (a * n + b) / c;
    if (!m) return 0;
    return m * n - euclidean(c, c - b - 1, a, m - 1);
}
```

### 离散对数 bsgs 与 exbsgs

以 $\mathcal O(\sqrt {P})$ 的复杂度求解 $a^x \equiv b(\bmod P)$ 。其中标准 $\tt BSGS$ 算法不能计算 $a$ 与 $MOD$ 互质的情况，而 exbsgs 则可以。

```cpp
namespace BSGS {
    LL a, b, p;
    map<LL, LL> f;
    inline LL gcd(LL a, LL b) { return b > 0 ? gcd(b, a % b) : a; }
    inline LL ps(LL n, LL k, int p) {
        LL r = 1;
        for (; k; k >>= 1) {
            if (k & 1) r = r * n % p;
            n = n * n % p;
        }
        return r;
    }
    void exgcd(LL a, LL b, LL &x, LL &y) {
        if (!b) {
            x = 1, y = 0;
        } else {
            exgcd(b, a % b, x, y);
            LL t = x;
            x = y;
            y = t - a / b * y;
        }
    }
    LL inv(LL a, LL b) {
        LL x, y;
        exgcd(a, b, x, y);
        return (x % b + b) % b;
    }
    LL bsgs(LL a, LL b, LL p) {
        f.clear();
        int m = ceil(sqrt(p));
        b %= p;
        for (int i = 1; i <= m; i++) {
            b = b * a % p;
            f[b] = i;
        }
        LL tmp = ps(a, m, p);
        b = 1;
        for (int i = 1; i <= m; i++) {
            b = b * tmp % p;
            if (f.count(b) > 0) return (i * m - f[b] + p) % p;
        }
        return -1;
    }
    LL exbsgs(LL a, LL b, LL p) {
        if (b == 1 || p == 1) return 0;
        LL g = gcd(a, p), k = 0, na = 1;
        while (g > 1) {
            if (b % g != 0) return -1;
            k++;
            b /= g;
            p /= g;
            na = na * (a / g) % p;
            if (na == b) return k;
            g = gcd(a, p);
        }
        LL f = bsgs(a, b * inv(na, p) % p, p);
        if (f == -1) return -1;
        return f + k;
    }
} // namespace BSGS

using namespace BSGS;

int main() {
    IOS;
    cin >> p >> a >> b;
    a %= p, b %= p;
    LL ans = exbsgs(a, b, p);
    if (ans == -1) cout << "no solution\n";
    else cout << ans << "\n";
    return 0;
}
```

### 欧拉函数

#### 直接求解单个数的欧拉函数

$1$ 到 $N$ 中与 $N$ 互质数的个数称为欧拉函数，记作 $\varphi (N)$ 。求解欧拉函数的过程即为分解质因数的过程，复杂度 $\mathcal{O}(\sqrt{n})$ 。

```cpp
int phi(int n) { //求解 phi(n)
    int ans = n;
    for(int i = 2; i <= n / i; i ++) { //注意，这里要写 n / i ，以防止 int 型溢出风险和 sqrt 超时风险
        if(n % i == 0) {
            ans = ans / i * (i - 1);
            while(n % i == 0) n /= i;
        }
    }
    if(n > 1) ans = ans / n * (n - 1); //特判 n 为质数的情况
    return ans;
}
```

#### 求解 1 到 N 所有数的欧拉函数

利用上述性质，我们可以快速递推出 $2-N$ 中每个数的欧拉函数，复杂度 $\mathcal{O}(N)$ ，而该算法**即是线性筛的算法**。

$$
\varphi(n)=(1-1/p_1)(1-1/p_2)(1-1/p_3)(1-1/p_4)\cdots(1-1/p_n);
$$

```cpp
const int N = 1e5 + 7;
int v[N], prime[N], phi[N];
void euler(int n) {
    ms(v, 0); //最小质因子
    int m = 0; //质数数量
    for (int i = 2; i <= n; ++ i) {
        if (v[i] == 0) { // i 是质数
            v[i] = i, prime[++ m] = i;
            phi[i] = i - 1;
        }
         //为当前的数 i 乘上一个质因子
        for (int j = 1; j <= m; ++ j) {
             //如 i 有比 prime[j] 更小的质因子，或超出 n ，停止
            if(prime[j] > v[i] || prime[j] > n / i) break;
             // prime[j] 是合数 i * prime[j] 的最小质因子
            v[i * prime[j]] = prime[j];
            phi[i * prime[j]] = phi[i] * (i % prime[j] ? prime[j] - 1 : prime[j]);
        }
    }
}
int main() {
    int n; cin >> n; euler(n);
    for (int i = 1; i <= n; ++ i) cout << phi[i] << endl;
    return 0;
}
```

```cpp
std::vector<int> pri, not_prime, phi;

void init(int n) {
    not_prime.assign(n + 1, 0);
    phi.assign(n + 1, 0);
    phi[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (!not_prime[i]) {
            pri.push_back(i);
            phi[i] = i - 1;
        }
        for (int pri_j : pri) {
            if (i * pri_j > n) break;
            not_prime[i * pri_j] = true;
            if (i % pri_j == 0) {
                phi[i * pri_j] = phi[i] * pri_j;
                break;
            }
            phi[i * pri_j] = phi[i] * phi[pri_j];
        }
    }
}
```

#### 使用莫比乌斯反演求解欧拉函数

```cpp
int phi[N];
vector<int> fac[N];
void get_eulers() {
    for (int i = 1; i <= N - 10; i++) {
        for (int j = i; j <= N - 10; j += i) {
            fac[j].push_back(i);
        }
    }
    phi[1] = 1;
    for (int i = 2; i <= N - 10; i++) {
        phi[i] = i;
        for (auto j : fac[i]) {
            if (j == i) continue;
            phi[i] -= phi[j];
        }
    }
}
```

### 扩展欧拉定理

若正整数 $a$ 与 $m$ 互质，则

$$
a^{\varphi(m)}\equiv1(\mathrm{mod}\,m)
$$

推论：

$$
a^{b}\equiv a^{b \,\mathrm{mod}\,\varphi(m)}(\mathrm{mod}\,m)
$$

当 $a,m$ 不互质时，扩展 Euler 定理表述如下：

$$
a^{b}\equiv a^{b\,\mathrm{mod} \,\varphi(m)+\varphi(m)}(\mathrm{mod}\,m)
$$

式子仅在 $\varphi(m)\leq b$ 时成立

```cpp
#include <bits/stdc++.h>
using namespace std;
bool large_enough = false; // 判断是否有b >= phi(m)
inline int read(int MOD = 1e9 + 7) // 快速读入稍加修改即可以边读入边取模，不取模时直接模一个大于数据范围的数
{
    int ans = 0;
    char c = getchar();
    while (!isdigit(c))
        c = getchar();
    while (isdigit(c))
    {
        ans = ans * 10 + c - '0';
        if (ans >= MOD)
        {
            ans %= MOD;
            large_enough = true;
        }
        c = getchar();
    }
    return ans;
}
int phi(int n) // 求欧拉函数
{
    int res = n;
    for (int i = 2; i * i <= n; i++)
    {
        if (n % i == 0)
            res = res / i * (i - 1);
        while (n % i == 0)
            n /= i;
    }
    if (n > 1)
        res = res / n * (n - 1);
    return res;
}
int qpow(int a, int n, int MOD) // 快速幂
{
    int ans = 1;
    while (n)
    {
        if (n & 1)
            ans = 1LL * ans * a % MOD; // 注意防止溢出
        n >>= 1;
        a = 1LL * a * a % MOD;
    }
    return ans;
}
int main()
{
    int a = read(), m = read(), phiM = phi(m), b = read(phiM);
    cout << qpow(a, b + (large_enough ? phiM : 0), m);
    return 0;
}
```

### 求解连续数字的正约数集合——倍数法

使用规律递推优化，时间复杂度为 $\mathcal{O}(N\log N)$ ，如果不需要详细的输出集合，则直接将 `vector` 换为普通数组即可（时间更快） 。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 7;
vector<int> f[N];

void divide(int n) {
    for (int i = 1; i <= n; ++ i)
        for (int j = 1; j <= n / i; ++ j)
            f[i * j].push_back(i);
    for (int i = 1; i <= n; ++ i) {
        for (auto it : f[i]) cout << it << " ";
        cout << endl;
    }
}
int main() {
    int x; cin >> x; divide(x);
    return 0;
}
```

### 试除法判是否是质数

#### 标准解

$\mathcal O(\sqrt N)$ 。

```cpp
bool is_prime(int n) {
    if (n < 2) return false;
    for (int i = 2; i <= x / i; i++) {
        if (n % i == 0) return false;
    }
    return true;
}
```

#### 常数优化法

常数优化，达到 $\mathcal O(\frac {\sqrt N}{3})$ 。

```cpp
bool is_prime(int n) {
    if (n < 2) return false;
    if (n == 2 || n == 3) return true;
    if (n % 6 != 1 && n % 6 != 5) return false;
    for (int i = 5, j = n / i; i <= j; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) {
            return false;
        }
    }
    return true;
}
```

### 同余方程组、拓展中国剩余定理 excrt

公式：$x \equiv b_i(\bmod\ a_i)$ ，即 $(x - b_i) \mid a_i$ 。

```cpp
int n; LL ai[maxn], bi[maxn];
inline int mypow(int n, int k, int p) {
    int r = 1;
    for (; k; k >>= 1, n = n * n % p)
        if (k & 1) r = r * n % p;
    return r;
}
LL exgcd(LL a, LL b, LL &x, LL &y) {
    if (b == 0) { x = 1, y = 0; return a; }
    LL gcd = exgcd(b, a % b, x, y), tp = x;
    x = y, y = tp - a / b * y;
    return gcd;
}
LL excrt() {
    LL x, y, k;
    LL M = bi[1], ans = ai[1];
    for (int i = 2; i <= n; ++ i) {
        LL a = M, b = bi[i], c = (ai[i] - ans % b + b) % b;
        LL gcd = exgcd(a, b, x, y), bg = b / gcd;
        if (c % gcd != 0) return -1;
        x = mul(x, c / gcd, bg);
        ans += x * M;
        M *= bg;
        ans = (ans % M + M) % M;
    }
    return (ans % M + M) % M;
}
int main() {
    cin >> n;
    for (int i = 1; i <= n; ++ i) cin >> bi[i] >> ai[i];
    cout << excrt() << endl;
    return 0;
}
```

### 求解连续按位异或

以 $\mathcal O(1)$ 复杂度计算 $0\oplus1\oplus\dots\oplus n$ 。

```cpp
unsigned xor_n(unsigned n) {
    unsigned t = n & 3;
    if (t & 1) return t / 2u ^ 1;
    return t / 2u ^ n;
}
```

```cpp
i64 xor_n(i64 n) {
    if (n % 4 == 1) return 1;
    else if (n % 4 == 2) return n + 1;
    else if (n % 4 == 3) return 0;
    else return n;
}
```

### 高斯消元求解线性方程组

题目大意：输入一个包含 $N$ 个方程 $N$ 个未知数的线性方程组，系数与常数均为实数（两位小数）。求解这个方程组。如果存在唯一解，则输出所有 $N$ 个未知数的解，结果保留两位小数。如果无数解，则输出 $\tt{}X$ ，如果无解，则输出 $\tt{}N$ 。

```cpp
const int N = 110;
const double eps = 1e-8;
LL n;
double a[N][N];
LL gauss(){
    LL c, r;
    for (c = 0, r = 0; c < n; c ++ ){
        LL t = r;
        for (int i = r; i < n; i ++ )    //找到绝对值最大的行
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;
        if (fabs(a[t][c]) < eps) continue;
        for (int j = c; j < n + 1; j ++ ) swap(a[t][j], a[r][j]);    //将绝对值最大的一行换到最顶端
        for (int j = n; j >= c; j -- ) a[r][j] /= a[r][c];    //将当前行首位变成 1
        for (int i = r + 1; i < n; i ++ )    //将下面列消成 0
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j -- )
                    a[i][j] -= a[r][j] * a[i][c];
        r ++ ;
    }
    if (r < n){
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][n]) > eps)
                return 2;
        return 1;
    }
    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[i][j] * a[j][n];
    return 0;
}
int main(){
    cin >> n;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n + 1; j ++ )
            cin >> a[i][j];
    LL t = gauss();
    if (t == 0){
        for (int i = 0; i < n; i ++ ){
            if (fabs(a[i][n]) < eps) a[i][n] = abs(a[i][n]);
            printf("%.2lf\n", a[i][n]);
        }
    }
    else if (t == 1) cout << "Infinite group solutions\n";
    else cout << "No solution\n";
    return 0;
}

```

### Min25 筛

求解 $1-N$ 的质数和，其中 $N \le 10^{10}$ 。

```cpp
namespace min25{
    const int N = 1000000 + 10;
    int prime[N], id1[N], id2[N], flag[N], ncnt, m;
    LL g[N], sum[N], a[N], T;
    LL n;
    LL mod;
    inline LL ps(LL n,LL k) {LL r=1;for(;k;k>>=1){if(k&1)r=r*n%mod;n=n*n%mod;}return r;}
    void finit(){ // 最开始清0
        memset(g, 0, sizeof(g));
        memset(a, 0, sizeof(a));
        memset(sum, 0, sizeof(sum));
        memset(prime, 0, sizeof(prime));
        memset(id1, 0, sizeof(id1));
        memset(id2, 0, sizeof(id2));
        memset(flag, 0, sizeof(flag));
        ncnt = m = 0;
    }
    int ID(LL x) {
        return x <= T ? id1[x] : id2[n / x];
    }

    LL calc(LL x) {
        return x * (x + 1) / 2 - 1;
    }

    LL init(LL x) {
        T = sqrt(x + 0.5);
        for (int i = 2; i <= T; i++) {
            if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
            for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
                flag[i * prime[j]] = 1;
                if (i % prime[j] == 0) break;
            }
        }
        for (LL l = 1; l <= x; l = x / (x / l) + 1) {
            a[++m] = x / l;
            if (a[m] <= T) id1[a[m]] = m; else id2[x / a[m]] = m;
            g[m] = calc(a[m]);
        }
        for (int i = 1; i <= ncnt; i++)
            for (int j = 1; j <= m && (LL) prime[i] * prime[i] <= a[j]; j++)
                g[j] = g[j] - (LL) prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
    }
    LL solve(LL x) {
        if (x <= 1) return x;
        return n = x, init(n), g[ID(n)];
    }
}

using namespace min25;

int main() {
    // while (1) {
    int tt;
    scanf("%d",&tt);
    while(tt--){
        finit();
        scanf("%lld%lld", &n, &mod);
        LL ans = (n + 3) % mod * n % mod  * ps(2 , mod - 2) % mod + solve(n + 1) - 4;
        // cout << solve(n) << endl;
        // ans = (ans + mod) % mod;
        ans = (ans + mod) % mod;
        printf("%lld\n", ans);
    }

    // }
}
```

### 矩阵四则运算

[封装来自](https://ac.nowcoder.com/acm/contest/view-submission?submissionId=48594258) 。矩阵乘法复杂度 $\mathcal O(N^3)$ 。

```cpp
const int SIZE = 2;
struct Matrix {
    ll M[SIZE + 5][SIZE + 5];
    void clear() { memset(M, 0, sizeof(M)); }
    void reset() { //初始化
        clear();
        for (int i = 1; i <= SIZE; ++i) M[i][i] = 1;
    }
    Matrix friend operator*(const Matrix &A, const Matrix &B) {
        Matrix Ans;
        Ans.clear();
        for (int i = 1; i <= SIZE; ++i)
            for (int j = 1; j <= SIZE; ++j)
                for (int k = 1; k <= SIZE; ++k)
                    Ans.M[i][j] = (Ans.M[i][j] + A.M[i][k] * B.M[k][j]) % mod;
        return Ans;
    }
    Matrix friend operator+(const Matrix &A, const Matrix &B) {
        Matrix Ans;
        Ans.clear();
        for (int i = 1; i <= SIZE; ++i)
            for (int j = 1; j <= SIZE; ++j)
                Ans.M[i][j] = (A.M[i][j] + B.M[i][j]) % mod;
        return Ans;
    }
};

inline int mypow(LL n, LL k, int p = MOD) {
    LL r = 1;
    for (; k; k >>= 1, n = n * n % p) {
        if (k & 1) r = r * n % p;
    }
    return r;
}
bool ok = 1;
Matrix getinv(Matrix a) { //矩阵求逆
    int n = SIZE, m = SIZE * 2;
    for (int i = 1; i <= n; i++) a.M[i][i + n] = 1;
    for (int i = 1; i <= n; i++) {
        int pos = i;
        for (int j = i + 1; j <= n; j++)
            if (abs(a.M[j][i]) > abs(a.M[pos][i])) pos = j;
        if (i != pos) swap(a.M[i], a.M[pos]);
        if (!a.M[i][i]) {
            puts("No Solution");
            ok = 0;
        }
        ll inv = q_pow(a.M[i][i], mod - 2);
        for (int j = 1; j <= n; j++)
            if (j != i) {
                ll mul = a.M[j][i] * inv % mod;
                for (int k = i; k <= m; k++)
                    a.M[j][k] = ((a.M[j][k] - a.M[i][k] * mul) % mod + mod) % mod;
            }
        for (int j = 1; j <= m; j++) a.M[i][j] = a.M[i][j] * inv % mod;
    }
    Matrix res;
    res.clear();
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            res.M[i][j] = a.M[i][n + j];
    return res;
}
```

### 矩阵快速幂

以 $\mathcal O(N^3\log M)$ 的复杂度计算。

```cpp
const int N = 40;
using mat = std::array<std::array<i64, N + 1>, N + 1>;
mat operator*(const mat& a, const mat& b) {
    mat ans{};
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            for (int k = 1; k <= N; k++)
                ans[i][j] = (ans[i][j] + a[i][k] * b[k][j]) % mod;
        }
    }
    return ans;
}

mat MatPow(mat a, i64 b) {
    mat ans{};
    for (int i = 1;i <= N;i++) ans[i][i] = 1;
    while (b) {
        if (b & 1) ans = ans * a;
        b >>= 1;
        a = a * a;
    }
    return ans;
}
```

### 矩阵加速

```cpp
const int mod = 1e9 + 7;
LL T, n, t[5][5], a[5][5], b[5][5];
void matrixQp(LL y){
    while (y){
        if (y & 1){
            memset(t, 0, sizeof t);
            for (int i = 1; i <= 3; i ++ )
                for (int j = 1; j <= 1; j ++ )
                    for (int k = 1; k <= 3; k ++ )
                        t[i][j] = ( t[i][j] + (a[i][k] * b[k][j]) % mod ) % mod;
            memcpy(b, t, sizeof t);
        }
        y >>= 1;
        memset(t, 0, sizeof t);
        for (int i = 1; i <= 3; i ++ )
            for (int j = 1; j <= 3; j ++ )
                for (int k = 1; k <= 3; k ++ )
                    t[i][j] = ( t[i][j] + (a[i][k] * a[k][j]) % mod ) % mod;
        memcpy(a, t, sizeof t);
    }
}
void init(){
    b[1][1] = b[2][1] = b[3][1] = 1;
    memset(a, 0, sizeof a);
    a[1][1] = a[2][1] = a[1][3] = a[3][2] = 1;
}
void solve(){
    cin >> n;
    if (n <= 3) cout << "1\n";
    else{
        init();
        matrixQp(n - 3);
        cout << b[1][1] << "\n";
    }
}
int main(){
    cin >> T;
    while ( T -- )
        solve();
    return 0;
}

```

### 莫比乌斯函数/反演

莫比乌斯函数定义：$\displaystyle {\mu(n) = \begin{cases} 1 &n = 1 \\ (-1)^k &n = \prod_{i = 1}^k p_i \text{ 且 } p_i \text{ 互质 } \\ 0 &else \end{cases}}$ 。

> 莫比乌斯函数性质：对于任意正整数 $n$ 满足 $\displaystyle {\sum_{d|n}\mu(d) = \begin{cases} 1 & n = 1 \\ 0 & n \neq 1\end{cases}}$ ；$\displaystyle {\sum_{d|n} \frac{\mu(d)}{d} = \frac{\varphi(n)}{n}}$ 。

莫比乌斯反演定义：定义：$F(n)$ 和 $f(n)$ 是定义在非负整数集合上的两个函数，并且满足 $\displaystyle F(n) = \sum_{d|n}f(d)$ ，可得 $\displaystyle f(n) = \sum_{d|n}\mu(d)F(\left \lfloor \frac{n}{d} \right \rfloor)$ 。

```cpp
const int N = 5e4 + 10;
bool st[N];
int mu[N], prime[N], cnt, sum[N];
void getMu() {
    mu[1] = 1;
    for (int i = 2; i <= N - 10; i++) {
        if (!st[i]) {
            prime[++cnt] = i;
            mu[i] = -1;
        }
        for (int j = 1; j <= cnt && i * prime[j] <= N - 10; j++) {
            st[i * prime[j]] = true;
            if (i % prime[j] == 0) {
                mu[i * prime[j]] = 0;
                break;
            }
            mu[i * prime[j]] = -mu[i];
        }
    }
    for (int i = 1; i <= N - 10; i++) {
        sum[i] = sum[i - 1] + mu[i];
    }
}
void solve() {
    int n, m, k; cin >> n >> m >> k;
    n = n / k, m = m / k;
    if (n < m) swap(n, m);
    LL ans = 0;
    for (int i = 1, j = 0; i <= m; i = j + 1) {
        j = min(n / (n / i), m / (m / i));
        ans += (LL)(sum[j] - sum[i - 1]) * (n / i) * (m / i);
    }
    cout << ans << "\n";
}
int main() {
    getMu();
    int T; cin >> T;
    while (T--) solve();
}
```

### 整除（数论）分块

$\displaystyle \left\lfloor \frac{n}{l} \right\rfloor = \left\lfloor \frac{n}{l + 1} \right\rfloor = ... = \left\lfloor \frac{n}{r} \right\rfloor \iff \left\lfloor \frac{n}{l} \right\rfloor \le \frac{n}{r} < \left\lfloor \frac{n}{l} \right\rfloor + 1$ ，根据不等式左侧，得到 $\displaystyle r \le \left\lfloor \frac{n}{\lfloor \frac{n}{l} \rfloor} \right\rfloor$ 。

```cpp
void solve() {
    LL n; cin >> n;
    LL ans = 0;
    for (LL i = 1, j; i <= n; i = j + 1) {
        j = n / (n / i);
        ans += (LL)(j - i + 1) * (n / i);
    }
    cout << ans << "\n";
}
int main() {
    int T; cin >> T;
    while (T--) solve();
}
```

### Miller - Rabin 素数测试

以平均 $\mathcal O (4\cdot \log^3X)$ 的复杂度判定数字 $X$ 是否是素数，这里记录的版本复杂度非常优秀，基本可以看作是 $\mathcal O(1)$ 。

```cpp
int mul(int a, int b, int m) {
    int r = a * b - m * (int)(1.L / m * a * b);
    return r - m * (r >= m) + m * (r < 0);
}
int mypow(int a, int b, int m) {
    int res = 1 % m;
    for (; b; b >>= 1, a = mul(a, a, m)) {
        if (b & 1) {
            res = mul(res, a, m);
        }
    }
    return res;
}

int B[] = {2, 3, 5, 7, 11, 13, 17, 19, 23};
bool MR(int n) {
    if (n <= 1) return 0;
    for (int p : B) {
        if (n == p) return 1;
        if (n % p == 0) return 0;
    }
    int m = (n - 1) >> __builtin_ctz(n - 1);
    for (int p : B) {
        int t = m, a = mypow(p, m, n);
        while (t != n - 1 && a != 1 && a != n - 1) {
            a = mul(a, a, n);
            t *= 2;
        }
        if (a != n - 1 && t % 2 == 0) return 0;
    }
    return 1;
}
```

### Pollard - Rho 因式分解

以单个因子 $\mathcal O (\log X)$ 的复杂度输出数字 $X$ 的全部质因数，由于需要结合素数测试，总复杂度会略高一些。如果遇到超时的情况，可能需要考虑进一步优化，例如检查题目是否强制要求枚举全部质因数等等。此外，还有一个[较长的模板](https://www.luogu.com.cn/record/114757731)可供参考，比这里记录的版本常数小约五倍。

```cpp
int PR(int n) {
    for (int p : B) {
        if (n % p == 0) return p;
    }
    auto f = [&](int x) -> int {
        x = mul(x, x, n) + 1;
        return x >= n ? x - n : x;
    };
    int x = 0, y = 0, tot = 0, p = 1, q, g;
    for (int i = 0; (i & 255) || (g = gcd(p, n)) == 1; i++, x = f(x), y = f(f(y))) {
        if (x == y) {
            x = tot++;
            y = f(x);
        }
        q = mul(p, abs(x - y), n);
        if (q) p = q;
    }
    return g;
}
vector<int> fac(int n) {
    #define pb emplace_back
    if (n == 1) return {};
    if (MR(n)) return {n};
    int d = PR(n);
    auto v1 = fac(d), v2 = fac(n / d);
    auto i1 = v1.begin(), i2 = v2.begin();
    vector<int> ans;
    while (i1 != v1.end() || i2 != v2.end()) {
        if (i1 == v1.end()) {
            ans.pb(*i2++);
        } else if (i2 == v2.end()) {
            ans.pb(*i1++);
        } else {
            if (*i1 < *i2) {
                ans.pb(*i1++);
            } else {
                ans.pb(*i2++);
            }
        }
    }
    return ans;
}
```

### 常见结论和定理

#### 麦乐鸡定理

给定两个互质的数 $n,m$ ，定义 $x=a*n+b*m（a \ge 0,b \ge 0）$，当 $x > n*m-n-m$ 时，该式子恒成立。

#### 抽屉原理（鸽巢原理）

将 $n+1$ 个物体，划分为 $n$ 组，那么有至少一组有两个（或以上）的物体。

#### 哥德巴赫猜想

任何一个大于 $5$ 的整数都可写成三个质数之和；任何一个大于 $2$ 的偶数都可写成两个素数之和。

#### 除法、取模运算的本质

有公式：$x \div i=\left\lfloor\dfrac{x}{i}\right\rfloor+x-i\cdot \left\lfloor\dfrac{x}{i}\right\rfloor$ ，$x \mod i=x-i\cdot \left\lfloor\dfrac{x}{i}\right\rfloor$ 。

#### 与、或、异或

| 运算 |  运算符、数学符号表示   |   解释    |
| :--: | :---------------------: | :-------: |
|  与  |       `&`、`and`        | 同 1 出 1 |
|  或  |       `\|`、`or`        | 有 1 出 1 |
| 异或 | `^`、$\bigoplus$、`xor` | 不同出 1  |

一些结论：

> 对于给定的 $X$ 和序列 $[a_1,a_2,…,a_n]$ ，有：$\pmb {X=(X \&a_1)or(X\&a_2)or…or(X\&a_n)}$ 。
> 原理是 $and$ 意味着取交集，$or$ 意味着取子集。[来源 - 牛客小白月赛 49C](https://ac.nowcoder.com/acm/contest/11226/C)

#### 调和级数近似公式

```c++
log(n) + 0.5772156649 + 1.0 / (2 * n)
```

#### 欧拉函数常见性质

- $1-n$ 中与 $n$ 互质的数之和为 $n * \varphi(n) / 2$ 。

- 若 $a，b$ 互质，则 $\varphi (a*b) = \varphi (a) * \varphi(b)$ 。实际上，所有满足这一条件的函数统称为积性函数。

- 若 $f$ 是积性函数，且有 $\displaystyle n = \prod ^m _{i =1} p_i ^ {c_i}$ ，那么 $\displaystyle f(n) = \prod ^m _{i =1} f( p_i ^ {c_i} )$ 。

- 若 $p$ 为质数，且满足 $p \mid  n$ ，

  - $p^2 \mid n$ ，那么 $\varphi (n) = \varphi (n / p) * p$ 。
  - $p^2 \nmid n$，那么 $\varphi (n) = \varphi (n / p) * (p-1)$ 。

- $\displaystyle\sum _{d \mid n} \varphi (d)= n$ 。

  > 如 $n=10$ ，则 $d=10/5/2/1$ ，那么 $10 = \varphi(10) + \varphi(5) + \varphi(2) + \varphi(1)$ 。

- $\displaystyle\sum_{i = 1}^{n} \gcd(i, n) = \sum_{d|n} \left\lfloor \frac{n}{d} \right\rfloor \varphi(d)$ （欧拉反演）。

#### 狄利克雷卷积

$\displaystyle \sum_{d | n} \varphi(d) = n$ ，$\displaystyle \sum_{d|n} \mu(d) \frac{n}{d} = \varphi(n)$ 。

#### 斐波那契数列

通项公式：$F_n=\dfrac{1}{\sqrt 5}*  \Big[ \Big( \dfrac{1+\sqrt 5}{2} \Big)^n - \Big( \dfrac{1-\sqrt 5}{2} \Big)^n \Big]$ 。

直接结论：

- 卡西尼性质：$F_{n-1} * F_{n+1}-F_n^2=(-1)^n$ ；
- $F_{n}^2+F_{n+1}^2=F_{2n+1}$ ；
- $F_{n+1}^2-F_{n-1}^2=F_{2n}$ （由上一条写两遍相减得到）；
- 若存在序列 $a_0=1,a_n=a_{n-1}+a_{n-3}+a_{n-5}+...(n\ge 1)$ 则 $a_n=F_n(n\ge 1)$ ；
- 齐肯多夫定理：任何正整数都可以表示成若干个不连续的斐波那契数（ $F_2$ 开始）可以用贪心实现。

求和公式结论：

- 奇数项求和：$F_1+F_3+F_5+...+F_{2n-1}=F_{2n}$ ；
- 偶数项求和：$F_2+F_4+F_6+...+F_{2n}=F_{2n+1}-1$ ；
- 平方和：$F_1^2+F_2^2+F_3^2+...+F_n^2=F_n*F_{n+1}$ ；
- $F_1+2F_2+3F_3+...+nF_n=nF_{n+2}-F_{n+3}+2$ ；
- $-F_1+F_2-F_3+...+(-1)^nF_n=(-1)^n(F_{n+1}-F_n)+1$ ；
- $F_{2n-2m-2}(F_{2n}+F_{2n+2})=F_{2m+2}+F_{4n-2m}$ 。

数论结论：

- $F_a \mid F_b \Leftrightarrow a \mid b$ ；
- $\gcd(F_a,F_b)=F_{\gcd(a,b)}$ ；
- 当 $p$ 为 $5k\pm 1$ 型素数时，$\begin{cases} F_{p-1}\equiv 0\pmod p \\ F_p\equiv 1\pmod p \\ F_{p+1}\equiv 1\pmod p \end{cases}$ ；
- 当 $p$ 为 $5k\pm 2$ 型素数时，$\begin{cases} F_{p-1}\equiv 1\pmod p \\ F_p\equiv -1\pmod p \\ F_{p+1}\equiv 0\pmod p \end{cases}$ ；
- $F(n)\%m$ 的周期 $\le 6m$ （ $m=2\times 5^k$ 时取到等号）；
- 既是斐波那契数又是平方数的有且仅有 $1,144$ 。

#### 杂

- 负数取模得到的是负数，如果要用 $0/1$ 判断的话请取绝对值；

- 辗转相除法原式为 $\gcd (x,y)=\gcd (x,y-x)$ ，推广到 $N$ 项为 $\gcd(a_1,a_2,\ldots,a_N)=\gcd(a_1,a_2-a_1,\dots,a_N-a_{N-1})$ ，

  - 该推论在“四则运算后 $\gcd$ ”这类题中有特殊意义，如求解 $\gcd(a_1+X,a_2+X,\dots,a_N+X)$ 时[See](https://codeforces.com/problemset/problem/1458/A)；

- 以下式子成立： $\gcd (a, m) = \gcd(a+x,m) \Leftrightarrow  \gcd(a, m)=\gcd(x,m)$ 。求解上式满足条件的 $x$ 的数量即为求比 $\dfrac{m}{\gcd(a,m)}$ 小且与其互质的数的个数，即用欧拉函数求解 $\varphi \Big(\dfrac{m}{\gcd(a,m)} \Big)$ 。

- 已知序列 $a$ ，定义集合 $S=\{a_i\cdot a_j \ \vert\  i<j\}$ ，现在要求解 $\gcd(S)$ ，即为求解 $\gcd(a_j,\gcd(a_i \ \vert\ i<j))$ ，换句话说，即为求解后缀 $\gcd$ 。

- 连续四个数互质的情况如下，当 $n$ 为奇数时，$n,n-1,n-2$ 一定互质；而当 $n$ 为偶数时，$\left\{\begin{matrix}n,n-1,n-3 \text{互质}& \gcd(n,n-3)=1\text{时}\\
  n-1,n-2,n-3 \text{互质}& \gcd(n,n-3)\neq1\text{时}
  \end{matrix}\right.$ [See](https://codeforces.com/problemset/problem/235/A)；

- 由 $a\mod b=(b+a)\mod b=(2\cdot b+a)\mod b=\dots=(K\cdot b+a)\mod b$ 可以推广得到 $(a\mod b)\mod c=((K\cdot bc+a)\mod b)\mod c$ ，由此可以得到一个 $bc$ 的答案周期[See](https://codeforces.com/problemset/problem/1342/C)；

- 对于长度为 $2\cdot N$ 的数列 $a$ ，将其任意均分为两个长度为 $N$ 的数列 $p,q$ ，随后对 $p$ 非递减排序、对 $q$ 非递增排序，定义 $\displaystyle f(p,q)=\sum_{i=1}^{n}|p_i-q_i|$ ，那么答案为 $a$ 数列前 $N$ 大的数之和减去前 $N$ 小的数之和[See](https://codeforces.com/problemset/problem/1444/B)。

- 令 $\left\{\begin{matrix} X=a+b\\
  Y=a\oplus b
  \end{matrix}\right.$ ，**如果**该式子**有解**，那么存在前提条件 $\left\{\begin{matrix} X \ge Y \\
  X,Y \text{同奇偶}
  \end{matrix}\right.$ ；进一步，此时最小的 $a$ 的取值为 $\dfrac{X-Y}{2}$ [See](https://codeforces.com/problemset/problem/76/D)。

  然而，上方方程并不总是有解的，只有当变量增加到三个时，才**一定有解**，即：**在保证上方前提条件成立的情况下**，求解 $\left\{\begin{matrix} X=a+b+c\\Y=a\oplus b\oplus c\end{matrix}\right.$ ，则一定存在一组解 $\{\dfrac{X-Y}{2},\dfrac{X-Y}{2},Y\}$ [See](https://codeforces.com/problemset/problem/1325/D)。

- 已知序列 $p$ 是由序列 $a_1$ 、序列 $a_2$ 、……、序列 $a_n$ 合并而成，且合并过程中各序列内元素相对顺序不变，记 $T(p)$ 是 $p$ 序列的最大前缀和，则 $\displaystyle T(p)=\sum_{i=1}^nT(a_i)$ [See](https://codeforces.com/problemset/problem/1469/B) 。

- $x+y=x|y+x\&y$ ，对于两个数字 $x$ 和 $y$ ，如果将 $x$ 变为 $x|y$ ，同时将 $y$ 变为 $x\&y$ ，那么在本质上即将 $x$ 二进制模式下的全部 $1$ 移动到了 $y$ 的对应的位置上 [See](https://codeforces.com/contest/1368/problem/D) 。

- 一个正整数 $x$ 异或、加上另一个正整数 $y$ 后奇偶性不发生变化：$a+b\equiv a\oplus b(\bmod2)$ [See](https://codeforces.com/contest/1634/problem/B) 。

### 常见例题

题意：将 $1$ 至 $N$ 的每个数字分组，使得每一组的数字之和均为质数。输出每一个数字所在的组别，且要求分出的组数最少 [See](https://codeforces.com/contest/45/problem/G) 。

考察哥德巴赫猜想，记全部数字之和为 $S$ ，分类讨论如下：

- 为 $S$ 质数时，只需要分入同一组；
- 当 $S$ 为偶数时，由猜想可知一定能分成两个质数，可以证明其中较小的那个一定小于 $N$ ，暴力枚举分组；
- 当 $S-2$ 为质数时，特殊判断出答案；
- 其余情况一定能被分成三组，其中 $3$ 单独成组，$S-3$ 后成为偶数，重复讨论二的过程即可。

---

题意：给定一个长度为 $n$ 的数组，定义这个数组是 $BAD$ 的，当且仅当可以把数组分成两个子序列，这两个子序列的元素之和相等。现在你需要删除**最少的**元素，使得删除后的数组不是 $BAD$ 的。

**最少删除一个元素**——如果原数组存在奇数，则直接删除这个奇数即可；反之，我们发现，对数列同除以一个数不影响计算，故我们只需要找到最大的满足 $2^k\mid a_i$ 成立的 $2^k$ ，随后将全部的 $a_i$ 变为 $\dfrac{a_i}{2^k}$ ，此时一定有一个奇数（换句话说，我们可以对原数列的每一个元素不断的除以 $2$ 直到出现奇数为止），删除这个奇数即可 [See](https://codeforces.com/contest/1516/problem/C) 。

---

题意：设当前有一个数字为 $x$ ，减去、加上最少的数字使得其能被 $k$ 整除。

最少减去 $x\bmod k$ 这个很好想；最少加上 $\left(\left\lceil\dfrac{x}{k}\right\rceil * k\right)\bmod k$ 也比较好想，但是更简便的方法为加上 $k-x\bmod k$ ，这个式子等价于前面这一坨。

---

题意：给定一个整数 $n$ ，用恰好 $k$ 个 $2$ 的幂次数之和表示它。例如：$n=9,k=4$ ，答案为 $1+2+2+4$ 。

结论 1：$k$ 合法当且仅当 `__builtin_popcountll(n) <= k && k <= n` ，显然。

结论 2：$2^{k+1}=2\cdot2^{k}$ ，所以我们可以将二进制位看作是数组，然后从高位向低位推，一个高位等于两个低位，直到数组之和恰好等于 $k$ ，随后依次输出即可。举例说明，$\{ 1,0,0,1\} \rightarrow \{ 0,2,0,1\} \rightarrow \{ 0,1,2,1\}$ ，即答案为 $0$ 个 $2^3$ 、$1$ 个 $2^2$ 、……。

```c++
signed main() {
    int n, k;
    cin >> n >> k;

    int cnt = __builtin_popcountll(n);

    if (k < cnt || n < k) {
        cout << "NO\n";
        return 0;
    }
    cout << "YES\n";

    vector<int> num;
    while (n) {
        num.push_back(n % 2);
        n /= 2;
    }

    for (int i = num.size() - 1; i > 0; i--) {
        int p = min(k - cnt, num[i]);
        num[i] -= p;
        num[i - 1] += 2 * p;
        cnt += p;
    }

    for (int i = 0; i < num.size(); i++) {
        for (int j = 1; j <= num[i]; j++) {
            cout << (1LL << i) << " ";
        }
    }
}
```

---

题意：$n$ 个取值在 $[0,k)$ 之间的数之和为 $m$ 的方案数

答案为 $\displaystyle \sum^n_{i=0}-1^i\cdot\binom{n}{i}\cdot\binom{m-i\cdot k+n-1}{n-1}$ [See1](http://acm.hdu.edu.cn/showproblem.php?pid=6397) [See2](https://codeforces.com/gym/103428/problem/M)。

```c++
 Z clac(int n, int k, int m) {
    Z ans = 0;
    for(int i = 0; i <= n; ++i) {
        ans += C(n, i) * C(m - i * k + n - 1, n - 1) * pow(-1, i);
    }
    return ans;
}
```

$\tt ^1$ 先考虑没有 $k$ 的限制，那么即球盒模型：$m$ 个球放入 $n$ 个盒子，球同、盒子不同、能空。使用隔板法得到公式：`C(m + n - 1, n - 1)` ；$\tt ^2$ 下面加上取值范围后进一步考虑：假设现在 $n$ 个数之和为 $m-k$ ，运用上述隔板法可得公式：`C(m - k + n - 1, n - 1)` ；$\tt ^3$ 随后，选择任意一个数字，将其加上 $k$ ，这样，这个数字一定不满足条件，选法为：`C(n, 1)` ；$\tt ^4$ 此时，至少有一个数字是不满足条件的，按照一般流程，到这里，`C(m + n - 1, n - 1) - C(n, 1) * C(m - k + n - 1, n - 1)` 即是答案；但是，这样的操作会导致重复的部分，所以这里要使用容斥原理将重复部分去除（关于为什么会重复，试比较概率论中的加法公式）。

### 约瑟夫问题

$n$ 个人编号 $0,1,2…,n-1$ ，每次数到 $k$ 出局，求最后剩下的人的编号。

$\mathcal O(N)$ 。

```c++
int jos(int n,int k){
    int res=0;
    repeat(i,1,n+1)res=(res+k)%i;
    return res; // res+1，如果编号从1开始
}
```

$\mathcal O(K\log N)$ ，适用于 $K$ 较小的情况。

```c++
int jos(int n,int k){
    if(n==1 || k==1)return n-1;
    if(k>n)return (jos(n-1,k)+k)%n; // 线性算法
    int res=jos(n-n/k,k)-n%k;
    if(res<0)res+=n; // mod n
    else res+=res/(k-1); // 还原位置
    return res; // res+1，如果编号从1开始
}
```

$\mathcal O(\sqrt N)$

```cpp
void jos(){
 int64_t n, k, a{}, b{ 1 }; cin >> n >> k; --k;
    while (b < n) {
        auto s = a / k + 1, u = b / k + 1, v = min(k - a / s, (min(u * k, n) - b + u - 1) / u);
        a += s * v, b += u * v;
    }
    cout << a + 1 << '\n';
}
```
